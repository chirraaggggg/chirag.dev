import type { Result, ResultAsync } from 'neverthrow';
import type { LoggableError } from '../core/types';
/**
 * Logs any errors in a Result without changing the Result.
 *
 * @param result - The Result to check for errors
 * @param customLogger - An object with an error method for logging (defaults to the standard logger)
 * @param messagePrefix - Optional prefix for the error message
 * @returns The original Result unchanged
 *
 * @example
 * ```ts
 * // Automatically log errors but continue the Result flow
 * const result = logResult(
 *   validateUser(data),
 *   logger,
 *   'User validation error'
 * );
 *
 * // Continue processing with the result
 * if (result.isOk()) {
 *   // Use the value...
 * }
 * ```
 *
 * @public
 */
export declare const logResult: <ValueType, ErrorType extends LoggableError>(result: Result<ValueType, ErrorType>, customLogger?: {
    error: (message: string, ...args: unknown[]) => void;
}, messagePrefix?: string) => Result<ValueType, ErrorType>;
/**
 * Logs any errors from a ResultAsync without changing the ResultAsync.
 *
 * @param resultAsync - The ResultAsync to check for errors
 * @param customLogger - An object with an error method for logging (defaults to the standard logger)
 * @param messagePrefix - Optional prefix for the error message
 * @returns The original ResultAsync unchanged
 *
 * @example
 * ```ts
 * // Log async errors but continue the flow
 * const result = await logResultAsync(
 *   fetchUserData(userId),
 *   logger,
 *   'Failed to fetch user data'
 * );
 *
 * // Continue with the result
 * if (result.isOk()) {
 *   // Use the data...
 * }
 * ```
 *
 * @public
 */
export declare const logResultAsync: <ValueType, ErrorType extends LoggableError>(resultAsync: ResultAsync<ValueType, ErrorType>, customLogger?: {
    error: (message: string, ...args: unknown[]) => void;
}, messagePrefix?: string) => ResultAsync<ValueType, ErrorType>;
//# sourceMappingURL=result.d.ts.map