"use strict";
var __webpack_exports__ = {};
const external_neverthrow_namespaceObject = require("neverthrow");
const external_vitest_namespaceObject = require("vitest");
const result_cjs_namespaceObject = require("../../utils/result.cjs");
(0, external_vitest_namespaceObject.describe)('result-logging', ()=>{
    (0, external_vitest_namespaceObject.describe)('logResult', ()=>{
        (0, external_vitest_namespaceObject.it)('should log error from a Result and return the original Result', ()=>{
            const logger = {
                error: external_vitest_namespaceObject.vi.fn()
            };
            const testError = {
                message: 'Test error',
                code: 'TEST_ERROR',
                status: 400,
                meta: {
                    test: true
                },
                category: 'test',
                stack: 'Error stack'
            };
            const errorResult = (0, external_neverthrow_namespaceObject.err)(testError);
            const result = (0, result_cjs_namespaceObject.logResult)(errorResult, logger);
            (0, external_vitest_namespaceObject.expect)(logger.error).toHaveBeenCalledTimes(1);
            (0, external_vitest_namespaceObject.expect)(logger.error).toHaveBeenCalledWith('Error: Test error', testError);
            (0, external_vitest_namespaceObject.expect)(result).toStrictEqual(errorResult);
            result.mapErr((error)=>{
                (0, external_vitest_namespaceObject.expect)(error).toEqual(testError);
                return error;
            });
        });
        (0, external_vitest_namespaceObject.it)('should not log anything for a successful Result', ()=>{
            const logger = {
                error: external_vitest_namespaceObject.vi.fn()
            };
            const successResult = (0, external_neverthrow_namespaceObject.ok)('Success');
            const result = (0, result_cjs_namespaceObject.logResult)(successResult, logger);
            (0, external_vitest_namespaceObject.expect)(logger.error).not.toHaveBeenCalled();
            (0, external_vitest_namespaceObject.expect)(result).toStrictEqual(successResult);
        });
        (0, external_vitest_namespaceObject.it)('should use custom message prefix when provided', ()=>{
            const logger = {
                error: external_vitest_namespaceObject.vi.fn()
            };
            const testError = {
                message: 'Test error'
            };
            const errorResult = (0, external_neverthrow_namespaceObject.err)(testError);
            (0, result_cjs_namespaceObject.logResult)(errorResult, logger, 'Custom prefix:');
            (0, external_vitest_namespaceObject.expect)(logger.error).toHaveBeenCalledWith('Custom prefix: Test error', external_vitest_namespaceObject.expect.any(Object));
        });
        (0, external_vitest_namespaceObject.it)('should handle errors with minimal properties', ()=>{
            const logger = {
                error: external_vitest_namespaceObject.vi.fn()
            };
            const minimalError = {
                message: 'Minimal error'
            };
            const errorResult = (0, external_neverthrow_namespaceObject.err)(minimalError);
            (0, result_cjs_namespaceObject.logResult)(errorResult, logger);
            (0, external_vitest_namespaceObject.expect)(logger.error).toHaveBeenCalledWith('Error: Minimal error', minimalError);
        });
    });
    (0, external_vitest_namespaceObject.describe)('logResultAsync', ()=>{
        (0, external_vitest_namespaceObject.it)('should log error from a ResultAsync and return the original ResultAsync', async ()=>{
            const logger = {
                error: external_vitest_namespaceObject.vi.fn()
            };
            const testError = {
                message: 'Async test error',
                code: 'ASYNC_TEST_ERROR',
                status: 500
            };
            const errorResultAsync = (0, external_neverthrow_namespaceObject.errAsync)(testError);
            const resultAsync = (0, result_cjs_namespaceObject.logResultAsync)(errorResultAsync, logger);
            await resultAsync.match(()=>{}, ()=>{});
            (0, external_vitest_namespaceObject.expect)(logger.error).toHaveBeenCalledTimes(1);
            (0, external_vitest_namespaceObject.expect)(logger.error).toHaveBeenCalledWith('Error: Async test error', testError);
        });
        (0, external_vitest_namespaceObject.it)('should not log anything for a successful ResultAsync', async ()=>{
            const logger = {
                error: external_vitest_namespaceObject.vi.fn()
            };
            const successResultAsync = (0, external_neverthrow_namespaceObject.okAsync)('Async Success');
            const resultAsync = (0, result_cjs_namespaceObject.logResultAsync)(successResultAsync, logger);
            await resultAsync.match(()=>{}, ()=>{});
            (0, external_vitest_namespaceObject.expect)(logger.error).not.toHaveBeenCalled();
        });
        (0, external_vitest_namespaceObject.it)('should use custom message prefix for async errors', async ()=>{
            const logger = {
                error: external_vitest_namespaceObject.vi.fn()
            };
            const testError = {
                message: 'Async error'
            };
            const errorResultAsync = (0, external_neverthrow_namespaceObject.errAsync)(testError);
            const resultAsync = (0, result_cjs_namespaceObject.logResultAsync)(errorResultAsync, logger, 'Async error:');
            await resultAsync.match(()=>{}, ()=>{});
            (0, external_vitest_namespaceObject.expect)(logger.error).toHaveBeenCalledWith('Async error: Async error', external_vitest_namespaceObject.expect.any(Object));
        });
    });
});
for(var __webpack_i__ in __webpack_exports__)exports[__webpack_i__] = __webpack_exports__[__webpack_i__];
Object.defineProperty(exports, '__esModule', {
    value: true
});
