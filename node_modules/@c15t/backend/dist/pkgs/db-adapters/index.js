import "neverthrow";
import { ORPCError } from "@orpc/server";
import { SpanStatusCode, trace } from "@opentelemetry/api";
import { createLogger as logger_createLogger } from "@c15t/logger";
import base_x from "base-x";
import { z } from "zod";
import { Kysely, MssqlDialect, MysqlDialect, PostgresDialect, SqliteDialect } from "kysely";
import superjson from "superjson";
import { and as external_drizzle_orm_and, asc, count as external_drizzle_orm_count, desc, eq, inArray, like, or as external_drizzle_orm_or } from "drizzle-orm";
const error_codes_ERROR_CODES = Object.freeze({
    NOT_FOUND: 'Resource not found',
    BAD_REQUEST: 'Bad request',
    CONFLICT: 'Conflict with current state',
    MISSING_REQUIRED_PARAMETER: 'Missing required parameter',
    UNAUTHORIZED: 'Unauthorized',
    FORBIDDEN: 'Forbidden',
    INTERNAL_SERVER_ERROR: 'Internal server error',
    INITIALIZATION_FAILED: 'Initialization failed',
    DATABASE_CONNECTION_ERROR: 'Database connection error',
    DATABASE_QUERY_ERROR: 'Database query error',
    INVALID_CONFIGURATION: 'Invalid configuration',
    REQUEST_HANDLER_ERROR: 'Request handler error',
    INVALID_REQUEST: 'Invalid request',
    UNKNOWN_ERROR: 'Unknown error',
    NETWORK_ERROR: 'Network error',
    PLUGIN_INITIALIZATION_FAILED: 'Plugin initialization failed',
    API_RETRIEVAL_ERROR: 'API retrieval error',
    VALIDATION_ERROR: 'Validation error',
    UNEXPECTED: 'Unexpected error'
});
const ERROR_CATEGORIES = Object.freeze({
    VALIDATION: 'validation',
    AUTHORIZATION: 'authorization',
    STORAGE: 'storage',
    NETWORK: 'network',
    PLUGIN: 'plugin',
    CONFIGURATION: 'configuration',
    UNEXPECTED: 'unexpected'
});
const tracer = trace.getTracer('@doubletie/results');
async function tracing_withSpan(name, fn, attributes = {}) {
    return await tracer.startActiveSpan(name, async (span)=>{
        try {
            span.setAttributes(attributes);
            const result = await fn(span);
            span.setStatus({
                code: SpanStatusCode.OK
            });
            span.end();
            return result;
        } catch (error) {
            if (error instanceof error_class_DoubleTieError) {
                span.setAttributes({
                    'error.type': 'DoubleTieError',
                    'error.code': error.code,
                    'error.statusCode': error.statusCode,
                    'error.message': error.message
                });
                if (error.meta) span.setAttributes({
                    'error.meta': JSON.stringify(error.meta)
                });
            } else span.setAttributes({
                'error.type': error instanceof Error ? error.constructor.name : 'Unknown',
                'error.message': error instanceof Error ? error.message : String(error)
            });
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: error instanceof Error ? error.message : String(error)
            });
            span.end();
            throw error;
        }
    });
}
class error_class_DoubleTieError extends ORPCError {
    category;
    meta;
    statusCode;
    constructor(message, options = {
        code: error_codes_ERROR_CODES.UNKNOWN_ERROR,
        status: 500,
        category: ERROR_CATEGORIES.UNEXPECTED,
        cause: void 0,
        meta: {}
    }){
        super(options.code ?? error_codes_ERROR_CODES.UNKNOWN_ERROR, {
            message,
            cause: options.cause,
            data: options.meta ?? {}
        });
        this.name = 'DoubleTieError';
        this.category = options.category ?? ERROR_CATEGORIES.UNEXPECTED;
        this.meta = options.meta ?? {};
        this.statusCode = options.status ?? 500;
        tracing_withSpan('create_doubletie_error', async (span)=>{
            span.setAttributes({
                'error.name': this.constructor.name,
                'error.message': message,
                'error.code': this.code,
                'error.status': this.statusCode,
                'error.category': this.category,
                'error.has_cause': !!this.cause,
                'error.cause_type': this.cause instanceof Error ? this.cause.constructor.name : typeof this.cause,
                'error.has_meta': !!this.meta
            });
            if (this.cause instanceof Error) span.recordException(this.cause);
        });
        if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
    }
    static isDoubleTieError(error) {
        return error instanceof error_class_DoubleTieError;
    }
    toJSON() {
        const validationErrorMessage = this.meta?.validationErrors ? String(this.meta.validationErrors) : void 0;
        const stackTrace = this.stack ? this.stack.split('\n').map((line)=>line.trim()).filter((line)=>line && !line.includes('Error: ')) : [];
        return {
            code: this.code,
            message: validationErrorMessage || this.message,
            status: this.statusCode,
            defined: true,
            data: {
                category: this.category,
                meta: this.meta,
                ...'production' === process.env.NODE_ENV ? {} : {
                    stack: stackTrace
                },
                ...validationErrorMessage && this.message ? {
                    originalMessage: this.message
                } : {},
                ...this.cause ? {
                    cause: this.cause instanceof Error ? {
                        name: this.cause.name,
                        message: this.cause.message,
                        stack: this.cause.stack ? this.cause.stack.split('\n').map((line)=>line.trim()) : void 0
                    } : this.cause
                } : {}
            }
        };
    }
    static fromResponse(response, data) {
        let message = `HTTP error ${response.status}`;
        let errorCode = `HTTP ${response.status}`;
        let errorMeta = {};
        if (data && 'object' == typeof data && null !== data) {
            const errorObj = data;
            if ('string' == typeof errorObj.message) message = errorObj.message;
            if ('string' == typeof errorObj.code) errorCode = errorObj.code;
            if ('object' == typeof errorObj.data && null !== errorObj.data) errorMeta = errorObj.data;
        }
        return new error_class_DoubleTieError(message, {
            code: errorCode,
            status: response.status,
            meta: errorMeta
        });
    }
    withMeta(additionalMeta) {
        return new error_class_DoubleTieError(this.message, {
            code: this.code,
            status: this.statusCode,
            category: this.category,
            cause: this.cause instanceof Error ? this.cause : void 0,
            meta: {
                ...this.meta,
                ...additionalMeta
            }
        });
    }
    static createSubclass(name) {
        const ErrorSubclass = class extends error_class_DoubleTieError {
            constructor(message, options){
                super(message, options);
                Object.defineProperty(this, 'name', {
                    value: name
                });
            }
        };
        Object.defineProperty(ErrorSubclass, 'name', {
            value: name
        });
        return ErrorSubclass;
    }
    static formatValidationError(error) {
        if (!error.meta) return error.message;
        let formattedMessage = `${error.message} (${error.code})`;
        if (error.meta.validationErrors) formattedMessage += `\nValidation Errors: ${JSON.stringify(error.meta.validationErrors, null, 2)}`;
        const otherMeta = Object.fromEntries(Object.entries(error.meta).filter(([key])=>'validationErrors' !== key));
        if (Object.keys(otherMeta).length > 0) formattedMessage += `\nAdditional Context: ${JSON.stringify(otherMeta, null, 2)}`;
        return formattedMessage;
    }
}
let globalLogger;
function getLogger(options) {
    if (!globalLogger) globalLogger = logger_createLogger({
        level: 'info',
        appName: 'c15t',
        ...options
    });
    return globalLogger;
}
const COMMON_TIMEZONES = {
    UTC: 'UTC',
    GMT: 'GMT',
    EASTERN: 'America/New_York',
    CENTRAL: 'America/Chicago',
    MOUNTAIN: 'America/Denver',
    PACIFIC: 'America/Los_Angeles',
    LONDON: 'Europe/London',
    PARIS: 'Europe/Paris',
    BERLIN: 'Europe/Berlin',
    TOKYO: 'Asia/Tokyo',
    SHANGHAI: 'Asia/Shanghai',
    SINGAPORE: 'Asia/Singapore',
    SYDNEY: 'Australia/Sydney',
    SAO_PAULO: 'America/Sao_Paulo'
};
const b58 = base_x('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');
function generateId(prefix) {
    const buf = crypto.getRandomValues(new Uint8Array(20));
    const EPOCH_TIMESTAMP = 1700000000000;
    const t = Date.now() - EPOCH_TIMESTAMP;
    const high = Math.floor(t / 0x100000000);
    const low = t >>> 0;
    buf[0] = high >>> 24 & 255;
    buf[1] = high >>> 16 & 255;
    buf[2] = high >>> 8 & 255;
    buf[3] = 255 & high;
    buf[4] = low >>> 24 & 255;
    buf[5] = low >>> 16 & 255;
    buf[6] = low >>> 8 & 255;
    buf[7] = 255 & low;
    return `${prefix}_${b58.encode(buf)}`;
}
const fieldConfigSchema = z.object({
    required: z.boolean().prefault(true),
    returned: z.boolean().prefault(true),
    input: z.boolean().prefault(true),
    defaultValue: z.any().optional(),
    transform: z.object({
        input: z.any().optional(),
        output: z.any().optional()
    }).optional(),
    validator: z.any().optional(),
    unique: z.boolean().optional(),
    indexed: z.boolean().optional(),
    sortable: z.boolean().prefault(true),
    fieldName: z.string().optional(),
    bigint: z.boolean().prefault(false)
});
const stringFieldSchema = fieldConfigSchema.extend({
    type: z.literal('string'),
    minLength: z.number().optional(),
    maxLength: z.number().optional(),
    pattern: z.string().optional()
});
const numberFieldSchema = fieldConfigSchema.extend({
    type: z.literal('number'),
    min: z.number().optional(),
    max: z.number().optional()
});
const booleanFieldSchema = fieldConfigSchema.extend({
    type: z.literal('boolean')
});
const dateFieldSchema = fieldConfigSchema.extend({
    type: z.literal('date'),
    minDate: z.date().optional(),
    maxDate: z.date().optional(),
    dateOnly: z.boolean().prefault(false),
    format: z.record(z.string(), z.unknown()).optional()
});
const timezoneFieldSchema = fieldConfigSchema.extend({
    type: z.literal('timezone'),
    validateTimezone: z.boolean().prefault(true),
    suggestedValues: z.array(z.string()).optional(),
    restrictToSuggestedValues: z.boolean().prefault(false)
});
const jsonFieldSchema = fieldConfigSchema.extend({
    type: z.literal('json'),
    validateJson: z.boolean().prefault(true)
});
const stringArrayFieldSchema = fieldConfigSchema.extend({
    type: z.literal('string[]')
});
const numberArrayFieldSchema = fieldConfigSchema.extend({
    type: z.literal('number[]')
});
z.discriminatedUnion('type', [
    stringFieldSchema,
    numberFieldSchema,
    booleanFieldSchema,
    dateFieldSchema,
    timezoneFieldSchema,
    jsonFieldSchema,
    stringArrayFieldSchema,
    numberArrayFieldSchema
]);
const schema_auditLogSchema = z.object({
    id: z.string(),
    entityType: z.string(),
    entityId: z.string(),
    actionType: z.string(),
    subjectId: z.string().optional(),
    ipAddress: z.string().optional(),
    userAgent: z.string().optional(),
    changes: z.record(z.string(), z.unknown()).optional(),
    metadata: z.record(z.string(), z.unknown()).optional(),
    createdAt: z.date().prefault(()=>new Date())
});
function getAuditLogTable(options, auditLogFields) {
    const auditLogConfig = options.tables?.auditLog;
    const subjectConfig = options.tables?.subject;
    return {
        entityName: auditLogConfig?.entityName || 'auditLog',
        entityPrefix: auditLogConfig?.entityPrefix || 'log',
        schema: schema_auditLogSchema,
        fields: {
            entityType: {
                type: 'string',
                required: true,
                fieldName: auditLogConfig?.fields?.entityType || 'entityType'
            },
            entityId: {
                type: 'string',
                required: true,
                fieldName: auditLogConfig?.fields?.entityId || 'entityId'
            },
            actionType: {
                type: 'string',
                required: true,
                fieldName: auditLogConfig?.fields?.actionType || 'actionType'
            },
            subjectId: {
                type: 'string',
                required: false,
                fieldName: auditLogConfig?.fields?.subjectId || 'subjectId',
                references: {
                    model: subjectConfig?.entityName || 'subject',
                    field: 'id'
                }
            },
            ipAddress: {
                type: 'string',
                required: false,
                fieldName: auditLogConfig?.fields?.ipAddress || 'ipAddress'
            },
            userAgent: {
                type: 'string',
                required: false,
                fieldName: auditLogConfig?.fields?.userAgent || 'userAgent'
            },
            changes: {
                type: 'json',
                required: false,
                fieldName: auditLogConfig?.fields?.changes || 'changes'
            },
            metadata: {
                type: 'json',
                required: false,
                fieldName: auditLogConfig?.fields?.metadata || 'metadata'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: auditLogConfig?.fields?.createdAt || 'createdAt'
            },
            eventTimezone: {
                type: 'timezone',
                required: true,
                defaultValue: COMMON_TIMEZONES.UTC,
                fieldName: auditLogConfig?.fields?.eventTimezone || 'eventTimezone'
            },
            ...auditLogFields || {},
            ...auditLogConfig?.additionalFields || {}
        },
        indexes: [
            {
                name: 'entity_index',
                fields: [
                    'entityType',
                    'entityId'
                ]
            },
            {
                name: 'action_type_index',
                fields: [
                    'actionType'
                ]
            },
            {
                name: 'subject_id_index',
                fields: [
                    'subjectId'
                ]
            },
            {
                name: 'created_at_index',
                fields: [
                    'createdAt'
                ]
            }
        ],
        order: 5
    };
}
const schema_consentSchema = z.object({
    id: z.string(),
    subjectId: z.string(),
    domainId: z.string(),
    purposeIds: z.array(z.string()),
    metadata: z.record(z.string(), z.unknown()).nullable().optional(),
    policyId: z.string().optional(),
    ipAddress: z.string().nullable().optional(),
    userAgent: z.string().nullable().optional(),
    status: z["enum"]([
        'active',
        'withdrawn',
        'expired'
    ]).prefault('active'),
    withdrawalReason: z.string().nullable().optional(),
    givenAt: z.date().prefault(()=>new Date()),
    validUntil: z.date().nullable().optional(),
    isActive: z.boolean().prefault(true)
});
function getConsentTable(options, consentFields) {
    const consentConfig = options.tables?.consent;
    const subjectConfig = options.tables?.subject;
    const domainConfig = options.tables?.domain;
    const policyConfig = options.tables?.consentPolicy;
    return {
        entityName: consentConfig?.entityName || 'consent',
        entityPrefix: consentConfig?.entityPrefix || 'cns',
        schema: schema_consentSchema,
        fields: {
            subjectId: {
                type: 'string',
                required: true,
                fieldName: consentConfig?.fields?.subjectId || 'subjectId',
                references: {
                    model: subjectConfig?.entityName || 'subject',
                    field: 'id'
                }
            },
            domainId: {
                type: 'string',
                required: true,
                fieldName: consentConfig?.fields?.domainId || 'domainId',
                references: {
                    model: domainConfig?.entityName || 'domain',
                    field: 'id'
                }
            },
            purposeIds: {
                type: 'json',
                required: false,
                fieldName: consentConfig?.fields?.purposeIds || 'purposeIds'
            },
            metadata: {
                type: 'json',
                required: false,
                fieldName: consentConfig?.fields?.metadata || 'metadata'
            },
            policyId: {
                type: 'string',
                required: false,
                fieldName: consentConfig?.fields?.policyId || 'policyId',
                references: {
                    model: policyConfig?.entityName || 'consentPolicy',
                    field: 'id'
                }
            },
            ipAddress: {
                type: 'string',
                required: false,
                fieldName: consentConfig?.fields?.ipAddress || 'ipAddress'
            },
            userAgent: {
                type: 'string',
                required: false,
                fieldName: consentConfig?.fields?.userAgent || 'userAgent'
            },
            status: {
                type: 'string',
                defaultValue: ()=>'active',
                required: true,
                fieldName: consentConfig?.fields?.status || 'status'
            },
            withdrawalReason: {
                type: 'string',
                required: false,
                fieldName: consentConfig?.fields?.withdrawalReason || 'withdrawalReason'
            },
            givenAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: consentConfig?.fields?.givenAt || 'givenAt'
            },
            validUntil: {
                type: 'date',
                required: false,
                fieldName: consentConfig?.fields?.validUntil || 'validUntil',
                transform: {
                    input: (val, data)=>{
                        if (val) return val;
                        const expiresIn = consentConfig?.expiresIn || 31536000;
                        const givenAt = data.givenAt instanceof Date ? data.givenAt : new Date();
                        if (expiresIn > 0) {
                            const validUntil = new Date(givenAt);
                            validUntil.setSeconds(validUntil.getSeconds() + expiresIn);
                            return validUntil;
                        }
                    }
                }
            },
            isActive: {
                type: 'boolean',
                defaultValue: true,
                required: true,
                fieldName: consentConfig?.fields?.isActive || 'isActive'
            },
            ...consentFields || {},
            ...consentConfig?.additionalFields || {}
        },
        order: 3
    };
}
const PolicyTypeSchema = z["enum"]([
    'cookie_banner',
    'privacy_policy',
    'dpa',
    'terms_and_conditions',
    'marketing_communications',
    'age_verification',
    'other'
]);
const schema_consentPolicySchema = z.object({
    id: z.string(),
    version: z.string(),
    type: PolicyTypeSchema,
    name: z.string(),
    effectiveDate: z.date(),
    expirationDate: z.date().nullable().optional(),
    content: z.string(),
    contentHash: z.string(),
    isActive: z.boolean().prefault(true),
    createdAt: z.date().prefault(()=>new Date()),
    updatedAt: z.date().prefault(()=>new Date())
});
function getConsentPolicyTable(options, policyFields) {
    const consentPolicyConfig = options.tables?.consentPolicy;
    return {
        entityName: consentPolicyConfig?.entityName || 'consentPolicy',
        entityPrefix: consentPolicyConfig?.entityPrefix || 'pol',
        schema: schema_consentPolicySchema,
        fields: {
            version: {
                type: 'string',
                required: true,
                fieldName: consentPolicyConfig?.fields?.version || 'version'
            },
            type: {
                type: 'string',
                required: true,
                fieldName: consentPolicyConfig?.fields?.type || 'type'
            },
            name: {
                type: 'string',
                required: true,
                fieldName: consentPolicyConfig?.fields?.name || 'name'
            },
            effectiveDate: {
                type: 'date',
                required: true,
                fieldName: consentPolicyConfig?.fields?.effectiveDate || 'effectiveDate'
            },
            expirationDate: {
                type: 'date',
                required: false,
                fieldName: consentPolicyConfig?.fields?.expirationDate || 'expirationDate'
            },
            content: {
                type: 'string',
                required: true,
                fieldName: consentPolicyConfig?.fields?.content || 'content'
            },
            contentHash: {
                type: 'string',
                required: true,
                fieldName: consentPolicyConfig?.fields?.contentHash || 'contentHash'
            },
            isActive: {
                type: 'boolean',
                defaultValue: true,
                required: true,
                fieldName: consentPolicyConfig?.fields?.isActive || 'isActive'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: consentPolicyConfig?.fields?.createdAt || 'createdAt'
            },
            ...policyFields || {},
            ...consentPolicyConfig?.additionalFields || {}
        },
        order: 2
    };
}
const schema_purposeSchema = z.object({
    id: z.string(),
    code: z.string(),
    name: z.string(),
    description: z.string(),
    isEssential: z.boolean().prefault(false),
    dataCategory: z.string().nullish(),
    legalBasis: z.string().nullish(),
    isActive: z.boolean().prefault(true),
    createdAt: z.date().prefault(()=>new Date()),
    updatedAt: z.date().prefault(()=>new Date())
});
function getPurposeTable(options, purposeFields) {
    const purposeConfig = options.tables?.consentPurpose;
    return {
        entityName: purposeConfig?.entityName || 'consentPurpose',
        entityPrefix: purposeConfig?.entityPrefix || 'pur',
        schema: schema_purposeSchema,
        fields: {
            code: {
                type: 'string',
                required: true,
                fieldName: purposeConfig?.fields?.code || 'code'
            },
            name: {
                type: 'string',
                required: true,
                fieldName: purposeConfig?.fields?.name || 'name'
            },
            description: {
                type: 'string',
                required: true,
                fieldName: purposeConfig?.fields?.description || "description"
            },
            isEssential: {
                type: 'boolean',
                defaultValue: ()=>false,
                required: true,
                fieldName: purposeConfig?.fields?.isEssential || 'isEssential'
            },
            dataCategory: {
                type: 'string',
                required: false,
                fieldName: purposeConfig?.fields?.dataCategory || 'dataCategory'
            },
            legalBasis: {
                type: 'string',
                required: false,
                fieldName: purposeConfig?.fields?.legalBasis || 'legalBasis'
            },
            isActive: {
                type: 'boolean',
                defaultValue: true,
                required: true,
                fieldName: purposeConfig?.fields?.isActive || 'isActive'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: purposeConfig?.fields?.createdAt || 'createdAt'
            },
            updatedAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: purposeConfig?.fields?.updatedAt || 'updatedAt'
            },
            ...purposeFields || {},
            ...purposeConfig?.additionalFields || {}
        },
        order: 1
    };
}
const schema_consentRecordSchema = z.object({
    id: z.string(),
    subjectId: z.string(),
    consentId: z.string().optional(),
    actionType: z.string(),
    details: z.record(z.string(), z.unknown()).optional(),
    createdAt: z.date().prefault(()=>new Date()),
    updatedAt: z.date().prefault(()=>new Date())
});
function getConsentRecordTable(options, recordFields) {
    const recordConfig = options.tables?.record;
    const subjectConfig = options.tables?.subject;
    const consentConfig = options.tables?.consent;
    return {
        entityName: recordConfig?.entityName || 'consentRecord',
        entityPrefix: recordConfig?.entityPrefix || 'rec',
        schema: schema_consentRecordSchema,
        fields: {
            subjectId: {
                type: 'string',
                required: true,
                fieldName: recordConfig?.fields?.subjectId || 'subjectId',
                references: {
                    model: subjectConfig?.entityName || 'subject',
                    field: 'id'
                }
            },
            consentId: {
                type: 'string',
                required: false,
                fieldName: recordConfig?.fields?.consentId || 'consentId',
                references: {
                    model: consentConfig?.entityName || 'consent',
                    field: 'id'
                }
            },
            actionType: {
                type: 'string',
                required: true,
                fieldName: recordConfig?.fields?.actionType || 'actionType'
            },
            details: {
                type: 'json',
                required: false,
                fieldName: recordConfig?.fields?.details || 'details'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: recordConfig?.fields?.createdAt || 'createdAt'
            },
            ...recordFields || {},
            ...recordConfig?.additionalFields || {}
        },
        order: 4
    };
}
const schema_domainSchema = z.object({
    id: z.string(),
    name: z.string().min(1),
    description: z.string().optional(),
    allowedOrigins: z.array(z.string()).optional().prefault([]),
    isVerified: z.boolean().prefault(true),
    isActive: z.boolean().prefault(true),
    createdAt: z.date().prefault(()=>new Date()),
    updatedAt: z.date().prefault(()=>new Date())
});
function getDomainTable(options, domainFields) {
    const domainConfig = options.tables?.domain;
    return {
        entityName: domainConfig?.entityName || 'domain',
        entityPrefix: domainConfig?.entityPrefix || 'dom',
        schema: schema_domainSchema,
        fields: {
            name: {
                type: 'string',
                required: true,
                unique: true,
                fieldName: domainConfig?.fields?.name || 'name'
            },
            description: {
                type: 'string',
                required: false,
                fieldName: domainConfig?.fields?.description || "description"
            },
            allowedOrigins: {
                type: 'json',
                defaultValue: ()=>[],
                required: false,
                fieldName: domainConfig?.fields?.allowedOrigins || 'allowedOrigins'
            },
            isVerified: {
                type: 'boolean',
                defaultValue: true,
                required: true,
                fieldName: domainConfig?.fields?.isVerified || 'isVerified'
            },
            isActive: {
                type: 'boolean',
                defaultValue: true,
                required: true,
                fieldName: domainConfig?.fields?.isActive || 'isActive'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: domainConfig?.fields?.createdAt || 'createdAt'
            },
            updatedAt: {
                type: 'date',
                required: false,
                fieldName: domainConfig?.fields?.updatedAt || 'updatedAt'
            },
            ...domainFields || {},
            ...domainConfig?.additionalFields || {}
        },
        order: 1
    };
}
const schema_subjectSchema = z.object({
    id: z.string(),
    isIdentified: z.boolean().prefault(false),
    externalId: z.string().nullable().optional(),
    identityProvider: z.string().optional(),
    lastIpAddress: z.string().optional(),
    createdAt: z.date().prefault(()=>new Date()),
    updatedAt: z.date().prefault(()=>new Date())
});
function getSubjectTable(options, subjectFields) {
    const subjectConfig = options.tables?.subject;
    return {
        entityName: subjectConfig?.entityName || 'subject',
        entityPrefix: subjectConfig?.entityPrefix || 'sub',
        schema: schema_subjectSchema,
        fields: {
            isIdentified: {
                type: 'boolean',
                defaultValue: ()=>false,
                required: true,
                fieldName: subjectConfig?.fields?.isIdentified || 'isIdentified'
            },
            externalId: {
                type: 'string',
                required: false,
                fieldName: subjectConfig?.fields?.externalId || 'externalId'
            },
            identityProvider: {
                type: 'string',
                required: false,
                fieldName: subjectConfig?.fields?.identityProvider || 'identityProvider'
            },
            lastIpAddress: {
                type: 'string',
                required: false,
                fieldName: subjectConfig?.fields?.lastIpAddress || 'lastIpAddress'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: subjectConfig?.fields?.createdAt || 'createdAt'
            },
            updatedAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: subjectConfig?.fields?.updatedAt || 'updatedAt'
            },
            subjectTimezone: {
                type: 'timezone',
                required: false,
                defaultValue: COMMON_TIMEZONES.UTC,
                fieldName: subjectConfig?.fields?.subjectTimezone || 'subjectTimezone'
            },
            ...subjectFields || {},
            ...subjectConfig?.additionalFields || {}
        },
        order: 1
    };
}
const getConsentTables = (options)=>{
    const pluginSchema = options.plugins?.reduce((acc, plugin)=>{
        const schema = plugin.schema;
        if (!schema) return acc;
        for (const [key, value] of Object.entries(schema))acc[key] = {
            fields: {
                ...acc[key]?.fields,
                ...value.fields
            },
            entityName: key
        };
        return acc;
    }, {});
    const { subject, consentPurpose, consentPolicy, domain, geoLocation, consent, consentPurposeJunction, record, consentGeoLocation, consentWithdrawal, auditLog, ...pluginTables } = pluginSchema || {};
    return {
        subject: getSubjectTable(options, subject?.fields),
        consentPurpose: getPurposeTable(options, consentPurpose?.fields),
        consentPolicy: getConsentPolicyTable(options, consentPolicy?.fields),
        domain: getDomainTable(options, domain?.fields),
        consent: getConsentTable(options, consent?.fields),
        consentRecord: getConsentRecordTable(options, record?.fields),
        auditLog: getAuditLogTable(options, auditLog?.fields),
        ...pluginTables
    };
};
function dialect_getDatabaseType(db) {
    if (!db) return null;
    if ('dialect' in db) return dialect_getDatabaseType(db.dialect);
    if (db && 'object' == typeof db && 'createDriver' in db) {
        if (db instanceof SqliteDialect) return 'sqlite';
        if (db instanceof MysqlDialect) return 'mysql';
        if (db instanceof PostgresDialect) return 'postgres';
        if (db instanceof MssqlDialect) return 'mssql';
    }
    if (db && 'object' == typeof db && 'aggregate' in db) return 'sqlite';
    if (db && 'object' == typeof db && 'getConnection' in db) return 'mysql';
    if (db && 'object' == typeof db && 'connect' in db) return 'postgres';
    return null;
}
const createKyselyAdapter = async (config)=>{
    const db = config.database;
    if (!db) return {
        kysely: null,
        databaseType: null
    };
    if (db && 'object' == typeof db && 'db' in db) {
        const kyselyConfig = db;
        return {
            kysely: kyselyConfig.db,
            databaseType: kyselyConfig.type
        };
    }
    if (db && 'object' == typeof db && 'dialect' in db) {
        const dialectConfig = db;
        return {
            kysely: new Kysely({
                dialect: dialectConfig.dialect
            }),
            databaseType: dialectConfig.type
        };
    }
    let dialect;
    const databaseType = dialect_getDatabaseType(db);
    if (db && 'object' == typeof db && 'createDriver' in db) dialect = db;
    if (db && 'object' == typeof db && 'aggregate' in db) dialect = new SqliteDialect({
        database: db
    });
    if (db && 'object' == typeof db && 'getConnection' in db) dialect = new MysqlDialect({
        pool: db
    });
    if (db && 'object' == typeof db && 'connect' in db) dialect = new PostgresDialect({
        pool: db
    });
    return {
        kysely: dialect ? new Kysely({
            dialect
        }) : null,
        databaseType
    };
};
function applyDefaultValue(inputValue, field, operation) {
    if ('update' === operation) return inputValue;
    if (null == inputValue && field.defaultValue) {
        if ('function' == typeof field.defaultValue) return field.defaultValue();
        return field.defaultValue;
    }
    return inputValue;
}
const createEntityTransformer = (db, config, options)=>{
    const schema = getConsentTables(options);
    function getField(model, field) {
        if ('id' === field) return field;
        const f = schema[model].fields[field];
        return f.fieldName || field;
    }
    function getSchema(entityName) {
        const schema = config.schema || db._.fullSchema;
        if (!schema) throw new error_class_DoubleTieError('The schema could not be found. Please ensure the schema is properly configured in the adapter.', {
            code: error_codes_ERROR_CODES.DATABASE_CONNECTION_ERROR,
            status: 500,
            meta: {
                provider: config.provider
            }
        });
        const model = getEntityName(entityName);
        const schemaModel = schema[model];
        if (!schemaModel) throw new error_class_DoubleTieError(`The model "${model}" does not exist in the schema. Please verify the model name and ensure it is defined in your schema.`, {
            code: error_codes_ERROR_CODES.DATABASE_QUERY_ERROR,
            status: 404,
            meta: {
                model,
                availableModels: Object.keys(schema)
            }
        });
        return schemaModel;
    }
    const getEntityName = (model)=>{
        if (schema[model].entityName !== model) return schema[model].entityName;
        if (config.usePlural) return `${model}s`;
        return model;
    };
    function convertWhereClause(where, model) {
        const schemaModel = getSchema(model);
        if (!where) return [];
        if (1 === where.length) {
            const w = where[0];
            if (!w) return [];
            const field = getField(model, w.field);
            if (!schemaModel[field]) throw new error_class_DoubleTieError(`The field "${field}" does not exist in model "${model}". Please verify the field name and ensure it is defined in your schema.`, {
                code: error_codes_ERROR_CODES.DATABASE_QUERY_ERROR,
                status: 404,
                meta: {
                    model,
                    field,
                    availableFields: Object.keys(schemaModel)
                }
            });
            if ('in' === w.operator) {
                if (!Array.isArray(w.value)) throw new error_class_DoubleTieError(`The value for the field "${field}" must be an array when using the "in" operator.`, {
                    code: error_codes_ERROR_CODES.BAD_REQUEST,
                    status: 400,
                    meta: {
                        field,
                        operator: w.operator,
                        expectedType: 'array',
                        actualType: typeof w.value
                    }
                });
                return [
                    inArray(schemaModel[field], w.value)
                ];
            }
            if ('contains' === w.operator) return [
                like(schemaModel[field], `%${w.value}%`)
            ];
            if ('starts_with' === w.operator) return [
                like(schemaModel[field], `${w.value}%`)
            ];
            if ('ends_with' === w.operator) return [
                like(schemaModel[field], `%${w.value}`)
            ];
            return [
                eq(schemaModel[field], w.value)
            ];
        }
        const andGroup = where.filter((w)=>'AND' === w.connector || !w.connector);
        const orGroup = where.filter((w)=>'OR' === w.connector);
        const andClause = external_drizzle_orm_and(...andGroup.map((w)=>{
            const field = getField(model, w.field);
            if ('in' === w.operator) {
                if (!Array.isArray(w.value)) throw new error_class_DoubleTieError(`The value for the field "${field}" must be an array when using the "in" operator.`, {
                    code: error_codes_ERROR_CODES.BAD_REQUEST,
                    status: 400,
                    meta: {
                        field,
                        operator: w.operator,
                        expectedType: 'array',
                        actualType: typeof w.value
                    }
                });
                return inArray(schemaModel[field], w.value);
            }
            return eq(schemaModel[field], w.value);
        }));
        const orClause = external_drizzle_orm_or(...orGroup.map((w)=>{
            const field = getField(model, w.field);
            return eq(schemaModel[field], w.value);
        }));
        const clause = [];
        if (andGroup.length && andClause) clause.push(andClause);
        if (orGroup.length && orClause) clause.push(orClause);
        return clause;
    }
    const useDatabaseGeneratedId = options?.advanced?.generateId === false;
    return {
        getSchema,
        transformInput (data, model, action) {
            const transformedData = useDatabaseGeneratedId || 'update' === action ? {} : {
                id: options.advanced?.generateId ? options.advanced.generateId({
                    model
                }) : data.id || generateId(schema[model].entityPrefix)
            };
            const fields = schema[model].fields;
            for(const field in fields)if (Object.hasOwn(fields, field)) {
                const value = data[field];
                if (void 0 === value && !fields[field].defaultValue) continue;
                transformedData[fields[field].fieldName || field] = applyDefaultValue(value, fields[field], action);
            }
            return transformedData;
        },
        transformOutput (data, model, select = []) {
            if (!data) return null;
            let transformedData = {};
            if ((data.id || data._id) && (0 === select.length || select.includes('id'))) transformedData = {
                id: data.id
            };
            const tableSchema = schema[model].fields;
            for(const key in tableSchema){
                if (select.length && !select.includes(key)) continue;
                const field = tableSchema[key];
                if (field) transformedData[key] = data[field.fieldName || key];
            }
            return transformedData;
        },
        convertWhereClause,
        withReturning: async (model, builder, data, where)=>{
            if ('mysql' !== config.provider) {
                const c = await builder.returning();
                return c[0];
            }
            await builder.execute();
            const schemaModel = getSchema(model);
            const builderVal = builder.config?.values;
            if (where?.length) {
                const clause = convertWhereClause(where, model);
                const res = await db.select().from(schemaModel).where(...clause);
                return res[0];
            }
            if (builderVal) {
                const tId = builderVal[0]?.id.value;
                const res = await db.select().from(schemaModel).where(eq(schemaModel.id, tId));
                return res[0];
            }
            if (data.id) {
                const res = await db.select().from(schemaModel).where(eq(schemaModel.id, data.id));
                return res[0];
            }
        },
        getField,
        getEntityName
    };
};
function checkMissingFields(schema, model, values) {
    if (!schema) throw new error_class_DoubleTieError('The schema could not be found. Please ensure the schema is properly configured in the adapter.', {
        code: error_codes_ERROR_CODES.DATABASE_CONNECTION_ERROR,
        status: 500
    });
    for(const key in values)if (!schema[key]) throw new error_class_DoubleTieError(`The field "${key}" does not exist in the "${model}" schema. Please update your drizzle schema or re-generate using "npx @c15t/cli generate".`);
}
const drizzleAdapter = (db, config)=>(options)=>{
        const { transformInput, transformOutput, convertWhereClause, getSchema, withReturning, getField, getEntityName } = createEntityTransformer(db, config, options);
        return {
            id: 'drizzle',
            async create (data) {
                const { model, data: values } = data;
                const transformed = transformInput(values, model, 'create');
                const schemaModel = getSchema(model);
                checkMissingFields(schemaModel, getEntityName(model), transformed);
                const builder = db.insert(schemaModel).values(transformed);
                const returned = await withReturning(model, builder, transformed);
                return transformOutput(returned, model);
            },
            async findOne (data) {
                const { model, where, select } = data;
                const schemaModel = getSchema(model);
                const clause = convertWhereClause(where, model);
                const res = await db.select().from(schemaModel).where(...clause);
                if (!res.length) return null;
                return transformOutput(res[0], model, select);
            },
            async findMany (data) {
                const { model, where, sortBy, limit, offset } = data;
                const schemaModel = getSchema(model);
                const clause = where ? convertWhereClause(where, model) : [];
                const sortFn = sortBy?.direction === 'desc' ? desc : asc;
                const builder = db.select().from(schemaModel).limit(limit || 100).offset(offset || 0);
                if (sortBy?.field) builder.orderBy(sortFn(schemaModel[getField(model, sortBy?.field)]));
                const res = await builder.where(...clause);
                return res.map((r)=>transformOutput(r, model));
            },
            async count (data) {
                const { model, where } = data;
                const schemaModel = getSchema(model);
                const clause = where ? convertWhereClause(where, model) : [];
                const res = await db.select({
                    count: external_drizzle_orm_count()
                }).from(schemaModel).where(...clause);
                return res[0].count;
            },
            async update (data) {
                const { model, where, update } = data;
                const schemaModel = getSchema(model);
                const clause = convertWhereClause(where, model);
                const transformed = transformInput(update, model, 'update');
                const result = await db.update(schemaModel).set(transformed).where(clause).returning();
                return result.length ? transformOutput(result[0], model) : null;
            },
            async updateMany (data) {
                const { model, where, update: values } = data;
                const schemaModel = getSchema(model);
                const clause = convertWhereClause(where, model);
                const transformed = transformInput(values, model, 'update');
                const builder = db.update(schemaModel).set(transformed).where(...clause);
                const res = await builder;
                return res ? res.changes : 0;
            },
            async delete (data) {
                const { model, where } = data;
                const schemaModel = getSchema(model);
                const clause = convertWhereClause(where, model);
                const builder = db.delete(schemaModel).where(...clause);
                await builder;
            },
            async deleteMany (data) {
                const { model, where } = data;
                const schemaModel = getSchema(model);
                const clause = convertWhereClause(where, model);
                const result = await db.delete(schemaModel).where(clause);
                return result ? result.rowCount : 0;
            },
            async transaction (data) {
                const { callback } = data;
                return await db.transaction(async (tx)=>{
                    const transactionAdapter = drizzleAdapter(tx, config)(options);
                    return await callback(transactionAdapter);
                });
            },
            options: config
        };
    };
const memory_adapter_createEntityTransformer = (options)=>{
    const schema = getConsentTables(options);
    function getField(model, field) {
        if ('id' === field) return field;
        const modelFields = schema[model]?.fields;
        const f = modelFields ? modelFields[field] : void 0;
        return f?.fieldName || field;
    }
    return {
        transformInput (data, model, action) {
            const advancedOptions = options.advanced || {};
            const transformedData = 'update' === action ? {} : {
                id: advancedOptions.generateId ? advancedOptions.generateId({
                    model
                }) : data.id || generateId(schema[model].entityPrefix)
            };
            const fields = schema[model].fields;
            for(const field in fields)if (Object.hasOwn(fields, field)) {
                const value = data[field];
                const fieldInfo = fields[field];
                if (void 0 === value && !fieldInfo?.defaultValue) continue;
                const fieldName = fieldInfo?.fieldName || field;
                transformedData[fieldName] = applyDefaultValue(value, fieldInfo, action);
            }
            return transformedData;
        },
        transformOutput (data, model, select = []) {
            if (!data) return null;
            const transformedData = {};
            const hasId = data.id || data._id;
            if (hasId && (0 === select.length || select.includes('id'))) transformedData.id = data.id;
            const tableSchema = schema[model].fields;
            for(const key in tableSchema){
                if (select.length && !select.includes(key)) continue;
                const field = tableSchema[key];
                if (field) transformedData[key] = data[field.fieldName || key];
            }
            return transformedData;
        },
        convertWhereClause (where, table, model) {
            return table.filter((record)=>where.every((clause)=>{
                    const { field: _field, value, operator = '=' } = clause;
                    const field = getField(model, _field);
                    if ('in' === operator) {
                        if (!Array.isArray(value)) throw new Error('Value must be an array');
                        return value.includes(record[field]);
                    }
                    if ('contains' === operator) {
                        const fieldValue = record[field];
                        return 'string' == typeof fieldValue && fieldValue.includes(value);
                    }
                    if ('starts_with' === operator) {
                        const fieldValue = record[field];
                        return 'string' == typeof fieldValue && fieldValue.startsWith(value);
                    }
                    if ('ends_with' === operator) {
                        const fieldValue = record[field];
                        return 'string' == typeof fieldValue && fieldValue.endsWith(value);
                    }
                    if ('eq' === operator) return record[field] === value;
                    if ('ne' === operator) return record[field] !== value;
                    return record[field] === value;
                }));
        },
        getField
    };
};
const memoryAdapter = (db)=>(options)=>{
        const { transformInput, transformOutput, convertWhereClause, getField } = memory_adapter_createEntityTransformer(options);
        const schema = getConsentTables(options);
        for(const model in schema)if (!db[model]) db[model] = [];
        return {
            id: 'memory',
            async create (data) {
                const { model, data: values, select } = data;
                const transformed = transformInput(values, model, 'create');
                if (!db[model]) db[model] = [];
                db[model].push(transformed);
                return transformOutput(transformed, model, select);
            },
            async findOne (data) {
                const { model, where, select } = data;
                const table = db[model] || [];
                const whereArray = Array.isArray(where) ? where : [
                    where
                ];
                const res = convertWhereClause(whereArray, table, model);
                const record = res[0] || null;
                return transformOutput(record, model, select);
            },
            async findMany (data) {
                const { model, where, sortBy, limit, offset } = data;
                let table = db[model] || [];
                if (where) {
                    const whereArray = Array.isArray(where) ? where : [
                        where
                    ];
                    table = convertWhereClause(whereArray, table, model);
                }
                if (sortBy) {
                    const field = getField(model, sortBy.field);
                    table = [
                        ...table
                    ].sort((a, b)=>{
                        if ('asc' === sortBy.direction) return a[field] > b[field] ? 1 : -1;
                        return a[field] < b[field] ? 1 : -1;
                    });
                }
                let result = table;
                if (void 0 !== offset) result = result.slice(offset);
                if (void 0 !== limit) result = result.slice(0, limit);
                return result.map((record)=>transformOutput(record, model));
            },
            async count (data) {
                const { model, where } = data;
                const table = db[model] || [];
                if (!where) return table.length;
                const whereArray = Array.isArray(where) ? where : [
                    where
                ];
                const filtered = convertWhereClause(whereArray, table, model);
                return filtered.length;
            },
            async update (data) {
                const { model, where, update: values } = data;
                const table = db[model] || [];
                const whereArray = Array.isArray(where) ? where : [
                    where
                ];
                const res = convertWhereClause(whereArray, table, model);
                for (const record of res)Object.assign(record, transformInput(values, model, 'update'));
                return transformOutput(res[0] || null, model);
            },
            async updateMany (data) {
                const { model, where, update: values } = data;
                const table = db[model] || [];
                const whereArray = Array.isArray(where) ? where : [
                    where
                ];
                const res = convertWhereClause(whereArray, table, model);
                for (const record of res)Object.assign(record, transformInput(values, model, 'update'));
                return res.map((record)=>transformOutput(record, model));
            },
            async delete (data) {
                const { model, where } = data;
                const table = db[model] || [];
                const whereArray = Array.isArray(where) ? where : [
                    where
                ];
                const res = convertWhereClause(whereArray, table, model);
                db[model] = table.filter((record)=>!res.includes(record));
            },
            async deleteMany (data) {
                const { model, where } = data;
                const table = db[model] || [];
                const whereArray = Array.isArray(where) ? where : [
                    where
                ];
                const res = convertWhereClause(whereArray, table, model);
                let count = 0;
                db[model] = table.filter((record)=>{
                    if (res.includes(record)) {
                        count++;
                        return false;
                    }
                    return true;
                });
                return count;
            },
            async transaction (data) {
                const { callback } = data;
                const tempDb = {};
                for(const key in db)if (Object.hasOwn(db, key)) tempDb[key] = JSON.parse(JSON.stringify(db[key]));
                const transactionAdapter = memoryAdapter(tempDb)(options);
                const result = await callback(transactionAdapter);
                for(const key in tempDb)if (Object.hasOwn(tempDb, key)) db[key] = tempDb[key];
                return result;
            }
        };
    };
const prisma_adapter_createEntityTransformer = (_config, options)=>{
    const schema = getConsentTables(options);
    function getField(model, field) {
        if ('id' === field) return field;
        const f = schema[model].fields[field];
        return f.fieldName || field;
    }
    function operatorToPrismaOperator(operator) {
        switch(operator){
            case 'starts_with':
                return 'startsWith';
            case 'ends_with':
                return 'endsWith';
            default:
                return operator;
        }
    }
    function getEntityName(model) {
        return schema[model].entityName;
    }
    const useDatabaseGeneratedId = options?.advanced?.generateId === false;
    return {
        transformInput (data, model, action) {
            const transformedData = useDatabaseGeneratedId || 'update' === action ? {} : {
                id: options.advanced?.generateId ? options.advanced.generateId({
                    model
                }) : data.id || generateId(schema[model].entityPrefix)
            };
            const fields = schema[model].fields;
            for(const field in fields)if (Object.hasOwn(fields, field)) {
                const value = data[field];
                if (void 0 === value && (!fields[field].defaultValue || 'update' === action)) continue;
                transformedData[fields[field].fieldName || field] = applyDefaultValue(value, fields[field], action);
            }
            return transformedData;
        },
        transformOutput (data, model, select = []) {
            if (!data) return null;
            let transformedData = {};
            if ((data.id || data._id) && (0 === select.length || select.includes('id'))) transformedData = {
                id: data.id
            };
            const tableSchema = schema[model].fields;
            for(const key in tableSchema){
                if (select.length && !select.includes(key)) continue;
                const field = tableSchema[key];
                if (field) transformedData[key] = data[field.fieldName || key];
            }
            return transformedData;
        },
        convertWhereClause (model, where) {
            if (!where) return {};
            if (1 === where.length) {
                const w = where[0];
                if (!w) return;
                return {
                    [getField(model, w.field)]: 'eq' !== w.operator && w.operator ? {
                        [operatorToPrismaOperator(w.operator)]: w.value
                    } : w.value
                };
            }
            const and = where.filter((w)=>'AND' === w.connector || !w.connector);
            const or = where.filter((w)=>'OR' === w.connector);
            const andClause = and.map((w)=>({
                    [getField(model, w.field)]: 'eq' !== w.operator && w.operator ? {
                        [operatorToPrismaOperator(w.operator)]: w.value
                    } : w.value
                }));
            const orClause = or.map((w)=>({
                    [getField(model, w.field)]: {
                        [w.operator || 'eq']: w.value
                    }
                }));
            return {
                ...andClause.length ? {
                    AND: andClause
                } : {},
                ...orClause.length ? {
                    OR: orClause
                } : {}
            };
        },
        convertSelect: (select, model)=>{
            if (!select || !model) return;
            return select.reduce((prev, cur)=>{
                const field = getField(model, cur);
                return Object.assign({}, prev, {
                    [field]: true
                });
            }, {});
        },
        getEntityName,
        getField
    };
};
const prismaAdapter = (prisma, config)=>(options)=>{
        const db = prisma;
        const { transformInput, transformOutput, convertWhereClause, convertSelect, getEntityName, getField } = prisma_adapter_createEntityTransformer(config, options);
        return {
            id: 'prisma',
            async create (data) {
                const { model, data: values, select } = data;
                const transformed = transformInput(values, model, 'create');
                if (!db[getEntityName(model)]) throw new error_class_DoubleTieError(`The model "${model}" does not exist in the Prisma client. Please verify the model name and ensure it is defined in your Prisma schema.`, {
                    code: error_codes_ERROR_CODES.DATABASE_QUERY_ERROR,
                    status: 500,
                    meta: {
                        model,
                        availableModels: Object.keys(prisma).filter((key)=>!key.startsWith('$') && !key.startsWith('_'))
                    }
                });
                const result = await db[getEntityName(model)].create({
                    data: transformed,
                    select: convertSelect(select, model)
                });
                return transformOutput(result, model, select);
            },
            async findOne (data) {
                const { model, where, select } = data;
                const whereClause = convertWhereClause(model, where);
                if (!db[getEntityName(model)]) throw new error_class_DoubleTieError(`The model "${model}" does not exist in the Prisma client. Please verify the model name and ensure it is defined in your Prisma schema.`, {
                    code: error_codes_ERROR_CODES.DATABASE_QUERY_ERROR,
                    status: 500,
                    meta: {
                        model,
                        availableModels: Object.keys(prisma).filter((key)=>!key.startsWith('$') && !key.startsWith('_'))
                    }
                });
                const result = await db[getEntityName(model)].findFirst({
                    where: whereClause,
                    select: convertSelect(select, model)
                });
                return transformOutput(result, model, select);
            },
            async findMany (data) {
                const { model, where, limit, offset, sortBy } = data;
                const whereClause = convertWhereClause(model, where);
                if (!db[getEntityName(model)]) throw new error_class_DoubleTieError(`The model "${model}" does not exist in the Prisma client. Please verify the model name and ensure it is defined in your Prisma schema.`, {
                    code: error_codes_ERROR_CODES.DATABASE_QUERY_ERROR,
                    status: 500,
                    meta: {
                        model,
                        availableModels: Object.keys(prisma).filter((key)=>!key.startsWith('$') && !key.startsWith('_'))
                    }
                });
                const result = await db[getEntityName(model)].findMany({
                    where: whereClause,
                    take: limit || 100,
                    skip: offset || 0,
                    ...sortBy?.field ? {
                        orderBy: {
                            [getField(model, sortBy.field)]: 'desc' === sortBy.direction ? 'desc' : 'asc'
                        }
                    } : {}
                });
                return result.map((r)=>transformOutput(r, model));
            },
            async count (data) {
                const { model, where } = data;
                const whereClause = convertWhereClause(model, where);
                if (!db[getEntityName(model)]) throw new error_class_DoubleTieError(`The model "${model}" does not exist in the Prisma client. Please verify the model name and ensure it is defined in your Prisma schema.`, {
                    code: error_codes_ERROR_CODES.DATABASE_QUERY_ERROR,
                    status: 500,
                    meta: {
                        model,
                        availableModels: Object.keys(prisma).filter((key)=>!key.startsWith('$') && !key.startsWith('_'))
                    }
                });
                const result = await db[getEntityName(model)].count({
                    where: whereClause
                });
                return result;
            },
            async update (data) {
                const { model, where, update } = data;
                const whereClause = convertWhereClause(model, where);
                const transformed = transformInput(update, model, 'update');
                try {
                    const result = await db[getEntityName(model)].update({
                        where: whereClause,
                        data: transformed
                    });
                    return transformOutput(result, model);
                } catch  {
                    return null;
                }
            },
            async updateMany (data) {
                const { model, where, update } = data;
                const whereClause = convertWhereClause(model, where);
                const transformed = transformInput(update, model, 'update');
                const result = await db[getEntityName(model)].updateMany({
                    where: whereClause,
                    data: transformed
                });
                return result ? result.count : 0;
            },
            async delete (data) {
                const { model, where } = data;
                const whereClause = convertWhereClause(model, where);
                try {
                    await db[getEntityName(model)].delete({
                        where: whereClause
                    });
                } catch  {}
            },
            async deleteMany (data) {
                const { model, where } = data;
                const whereClause = convertWhereClause(model, where);
                const result = await db[getEntityName(model)].deleteMany({
                    where: whereClause
                });
                return result ? result.count : 0;
            },
            async transaction (data) {
                const { callback } = data;
                return db.$transaction(async (tx)=>{
                    const txClient = tx;
                    const transactionAdapter = prismaAdapter(txClient, config)(options);
                    return await callback(transactionAdapter);
                });
            },
            options: config
        };
    };
const kysely_adapter_createEntityTransformer = (db, options, config)=>{
    const schema = getConsentTables(options);
    function getField(model, field) {
        if ('id' === field) return field;
        const modelFields = schema[model]?.fields;
        const f = modelFields ? modelFields[field] : void 0;
        if (!f) console.log('Field not found', model, field);
        return f?.fieldName || field;
    }
    function transformValueToDB(value, model, field) {
        if ('id' === field) return value;
        const { type = 'sqlite' } = config || {};
        const modelFields = schema[model]?.fields;
        const f = modelFields ? modelFields[field] : void 0;
        if (f?.type === 'boolean' && ('sqlite' === type || 'mssql' === type) && null != value) return value ? 1 : 0;
        if (f?.type === 'date' && value && value instanceof Date) return 'sqlite' === type ? value.toISOString() : value;
        if (f?.type === 'json' && null != value) {
            if ('postgres' === type || 'mysql' === type) return value;
            return superjson.stringify(value);
        }
        return value;
    }
    function transformValueFromDB(value, model, field) {
        const { type = 'sqlite' } = config || {};
        const modelFields = schema[model]?.fields;
        const f = modelFields ? modelFields[field] : void 0;
        if (f?.type === 'boolean' && ('sqlite' === type || 'mssql' === type) && null !== value) return 1 === value;
        if (f?.type === 'date' && value) return new Date(value);
        if (f?.type === 'json' && null != value) {
            if (('postgres' === type || 'mysql' === type) && 'object' == typeof value) return value;
            if ('string' == typeof value) try {
                return superjson.parse(value);
            } catch  {
                try {
                    return JSON.parse(value);
                } catch  {}
            }
        }
        return value;
    }
    function getEntityName(model) {
        return schema[model].entityName;
    }
    return {
        transformInput (data, model, action) {
            const transformedData = {};
            if ('create' === action) {
                const advancedOptions = options.advanced || {};
                transformedData.id = data.id || (advancedOptions.generateId ? advancedOptions.generateId({
                    model
                }) : generateId(schema[model].entityPrefix));
            }
            const fields = schema[model].fields;
            for(const field in fields)if (Object.hasOwn(fields, field)) {
                const value = data[field];
                const fieldInfo = fields[field];
                const fieldName = fieldInfo?.fieldName || field;
                if (fieldInfo) transformedData[fieldName] = applyDefaultValue(transformValueToDB(value, model, field), fieldInfo, action);
            }
            return transformedData;
        },
        transformOutput (data, model, select = []) {
            if (!data) return null;
            const transformedData = {};
            if (data.id && (0 === select.length || select.includes('id'))) transformedData.id = data.id;
            const tableSchema = schema[model]?.fields;
            for(const key in tableSchema){
                if (select.length && !select.includes(key)) continue;
                const field = tableSchema[key];
                if (field) transformedData[key] = transformValueFromDB(data[field.fieldName || key], model, key);
            }
            return transformedData;
        },
        convertWhereClause (model, whereConditions) {
            if (!whereConditions || 0 === whereConditions.length) return {
                and: null,
                or: null
            };
            const conditions = {
                and: [],
                or: []
            };
            for (const condition of whereConditions){
                let { field: _field, value, operator = '=', connector = 'AND' } = condition;
                const fieldString = getField(model, _field);
                value = transformValueToDB(value, model, _field);
                const expr = (eb)=>{
                    const dbField = fieldString;
                    if ('in' === operator.toLowerCase()) return eb(dbField, 'in', Array.isArray(value) ? value : [
                        value
                    ]);
                    if ('contains' === operator) return eb(dbField, 'like', `%${value}%`);
                    if ('starts_with' === operator) return eb(dbField, 'like', `${value}%`);
                    if ('ends_with' === operator) return eb(dbField, 'like', `%${value}`);
                    if ('ilike' === operator) {
                        const lowerField = eb.fn('lower', [
                            dbField
                        ]);
                        const lowerValue = eb.fn('lower', [
                            eb.val(value?.toString())
                        ]);
                        return eb(lowerField, 'like', lowerValue);
                    }
                    if ('eq' === operator) return eb(dbField, '=', value);
                    if ('ne' === operator) return eb(dbField, '<>', value);
                    if ('gt' === operator) return eb(dbField, '>', value);
                    if ('gte' === operator) return eb(dbField, '>=', value);
                    if ('lt' === operator) return eb(dbField, '<', value);
                    if ('lte' === operator) return eb(dbField, '<=', value);
                    return eb(dbField, operator, value);
                };
                if ('OR' === connector) conditions.or.push(expr);
                else conditions.and.push(expr);
            }
            return {
                and: conditions.and.length ? conditions.and : null,
                or: conditions.or.length ? conditions.or : null
            };
        },
        async withReturning (values, builder, model, where) {
            let res = null;
            if (config?.type === 'mysql') {
                await builder.execute();
                const whereCondition = where[0];
                const field = values.id ? 'id' : whereCondition?.field ?? 'id';
                const value = values[field] ?? whereCondition?.value;
                const fieldString = getField(model, field);
                res = await db.selectFrom(getEntityName(model)).selectAll().where((eb)=>eb(fieldString, '=', value)).executeTakeFirst();
                return res;
            }
            if (config?.type === 'mssql') {
                res = await builder.outputAll('inserted').executeTakeFirst();
                return res;
            }
            res = await builder.returningAll().executeTakeFirst();
            return res;
        },
        getEntityName,
        getField
    };
};
const kyselyAdapter = (db, config)=>(opts)=>{
        const { transformInput, withReturning, transformOutput, convertWhereClause, getEntityName, getField } = kysely_adapter_createEntityTransformer(db, opts, config);
        return {
            id: 'kysely',
            async create (data) {
                const { model, data: values, select } = data;
                const transformed = transformInput(values, model, 'create');
                const tableName = getEntityName(model);
                const builder = db.insertInto(tableName).values(transformed);
                const result = await withReturning(transformed, builder, model, []);
                const output = transformOutput(result, model, select);
                return output;
            },
            async findOne (data) {
                const { model, where, select } = data;
                const whereArray = Array.isArray(where) ? where : [
                    where
                ];
                const { and, or } = convertWhereClause(model, whereArray);
                const tableName = getEntityName(model);
                let query = db.selectFrom(tableName).selectAll();
                if (and) query = query.where((eb)=>{
                    const conditions = and.map((expr)=>expr(eb));
                    return eb.and(conditions);
                });
                if (or) query = query.where((eb)=>{
                    const conditions = or.map((expr)=>expr(eb));
                    return eb.or(conditions);
                });
                const res = await query.executeTakeFirst();
                if (!res) return null;
                return transformOutput(res, model, select);
            },
            async findMany (data) {
                const { model, where, limit, offset, sortBy } = data;
                const whereArray = where ? Array.isArray(where) ? where : [
                    where
                ] : void 0;
                const { and, or } = convertWhereClause(model, whereArray);
                const tableName = getEntityName(model);
                let query = db.selectFrom(tableName);
                if (and) query = query.where((eb)=>{
                    const conditions = and.map((expr)=>expr(eb));
                    return eb.and(conditions);
                });
                if (or) query = query.where((eb)=>{
                    const conditions = or.map((expr)=>expr(eb));
                    return eb.or(conditions);
                });
                if (config?.type === 'mssql') {
                    if (!offset) query = query.top(limit || 100);
                } else query = query.limit(limit || 100);
                if (sortBy) {
                    const sortFieldString = getField(model, sortBy.field);
                    query = query.orderBy(sortFieldString, sortBy.direction);
                }
                if (offset) if (config?.type === 'mssql') {
                    if (!sortBy) query = query.orderBy('id');
                    query = query.offset(offset).fetch(limit || 100);
                } else query = query.offset(offset);
                const res = await query.selectAll().execute();
                if (!res) return [];
                return res.map((r)=>transformOutput(r, model));
            },
            async update (data) {
                const { model, where, update: values } = data;
                const whereArray = Array.isArray(where) ? where : [
                    where
                ];
                const { and, or } = convertWhereClause(model, whereArray);
                const transformedData = transformInput(values, model, 'update');
                const tableName = getEntityName(model);
                let query = db.updateTable(tableName).set(transformedData);
                if (and) query = query.where((eb)=>{
                    const conditions = and.map((expr)=>expr(eb));
                    return eb.and(conditions);
                });
                if (or) query = query.where((eb)=>{
                    const conditions = or.map((expr)=>expr(eb));
                    return eb.or(conditions);
                });
                const result = await withReturning(transformedData, query, model, whereArray);
                return transformOutput(result, model);
            },
            async updateMany (data) {
                const { model, where, update: values } = data;
                const whereArray = Array.isArray(where) ? where : [
                    where
                ];
                const { and, or } = convertWhereClause(model, whereArray);
                const transformedData = transformInput(values, model, 'update');
                const tableName = getEntityName(model);
                let query = db.updateTable(tableName).set(transformedData);
                if (and) query = query.where((eb)=>{
                    const conditions = and.map((expr)=>expr(eb));
                    return eb.and(conditions);
                });
                if (or) query = query.where((eb)=>{
                    const conditions = or.map((expr)=>expr(eb));
                    return eb.or(conditions);
                });
                await query.execute();
                let selectQuery = db.selectFrom(tableName).selectAll();
                if (and) selectQuery = selectQuery.where((eb)=>{
                    const conditions = and.map((expr)=>expr(eb));
                    return eb.and(conditions);
                });
                if (or) selectQuery = selectQuery.where((eb)=>{
                    const conditions = or.map((expr)=>expr(eb));
                    return eb.or(conditions);
                });
                const fetchedResults = await selectQuery.execute();
                if (!fetchedResults || 0 === fetchedResults.length) return [];
                return fetchedResults.map((record)=>transformOutput(record, model));
            },
            async count (data) {
                const { model, where } = data;
                const whereArray = where ? Array.isArray(where) ? where : [
                    where
                ] : void 0;
                const { and, or } = convertWhereClause(model, whereArray);
                const tableName = getEntityName(model);
                let query = db.selectFrom(tableName).select((eb)=>eb.fn.count('id').as('count'));
                if (and) query = query.where((eb)=>{
                    const conditions = and.map((expr)=>expr(eb));
                    return eb.and(conditions);
                });
                if (or) query = query.where((eb)=>{
                    const conditions = or.map((expr)=>expr(eb));
                    return eb.or(conditions);
                });
                const res = await query.execute();
                const count = res[0]?.count;
                return 'number' == typeof count ? count : 0;
            },
            async delete (data) {
                const { model, where } = data;
                const whereArray = Array.isArray(where) ? where : [
                    where
                ];
                const { and, or } = convertWhereClause(model, whereArray);
                const tableName = getEntityName(model);
                let query = db.deleteFrom(tableName);
                if (and) query = query.where((eb)=>{
                    const conditions = and.map((expr)=>expr(eb));
                    return eb.and(conditions);
                });
                if (or) query = query.where((eb)=>{
                    const conditions = or.map((expr)=>expr(eb));
                    return eb.or(conditions);
                });
                await query.execute();
            },
            async deleteMany (data) {
                const { model, where } = data;
                const whereArray = Array.isArray(where) ? where : [
                    where
                ];
                const { and, or } = convertWhereClause(model, whereArray);
                const tableName = getEntityName(model);
                let query = db.deleteFrom(tableName);
                if (and) query = query.where((eb)=>{
                    const conditions = and.map((expr)=>expr(eb));
                    return eb.and(conditions);
                });
                if (or) query = query.where((eb)=>{
                    const conditions = or.map((expr)=>expr(eb));
                    return eb.or(conditions);
                });
                const result = await query.execute();
                const count = result.length;
                return count;
            },
            async transaction (data) {
                const { callback } = data;
                const advancedOptions = opts.advanced || {};
                if (advancedOptions.disableTransactions) {
                    const regularAdapter = kyselyAdapter(db, config)(opts);
                    return await callback(regularAdapter);
                }
                try {
                    return await db.transaction().execute(async (trx)=>{
                        const transactionAdapter = kyselyAdapter(trx, config)(opts);
                        return await callback(transactionAdapter);
                    });
                } catch (error) {
                    if (error instanceof Error && (error.message.includes('transactions are not supported') || error.message.toLowerCase().includes('no transaction support'))) {
                        console.warn("Warning: Database transaction failed. If your database does not support transactions, you can disable this warning by setting opts.advanced.disableTransactions to true.");
                        const regularAdapter = kyselyAdapter(db, config)(opts);
                        return await callback(regularAdapter);
                    }
                    throw error;
                }
            },
            options: config
        };
    };
async function getAdapter(options) {
    const logger = getLogger({
        appName: options.appName ?? 'c15t',
        ...options.logger
    });
    if (!options.database) {
        const tables = getConsentTables(options);
        const memoryDB = Object.keys(tables).reduce((acc, key)=>{
            acc[key] = [];
            return acc;
        }, {});
        logger.warn('No database configuration provided. Using memory adapter in development');
        return memoryAdapter(memoryDB)(options);
    }
    if ('function' == typeof options.database) return options.database(options);
    const { kysely, databaseType } = await createKyselyAdapter(options);
    if (!kysely) throw new error_class_DoubleTieError('Failed to initialize database adapter', {
        code: error_codes_ERROR_CODES.INTERNAL_SERVER_ERROR,
        status: 500
    });
    return kyselyAdapter(kysely, {
        type: databaseType || 'sqlite'
    })(options);
}
export { applyDefaultValue, createKyselyAdapter, drizzleAdapter, getAdapter, kyselyAdapter, memoryAdapter, prismaAdapter };
