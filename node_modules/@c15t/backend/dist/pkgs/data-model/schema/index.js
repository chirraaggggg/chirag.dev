import base_x from "base-x";
import { ZodError, z } from "zod";
import "neverthrow";
import { ORPCError } from "@orpc/server";
import { SpanStatusCode, trace } from "@opentelemetry/api";
import { logger } from "@c15t/logger";
const COMMON_TIMEZONES = {
    UTC: 'UTC',
    GMT: 'GMT',
    EASTERN: 'America/New_York',
    CENTRAL: 'America/Chicago',
    MOUNTAIN: 'America/Denver',
    PACIFIC: 'America/Los_Angeles',
    LONDON: 'Europe/London',
    PARIS: 'Europe/Paris',
    BERLIN: 'Europe/Berlin',
    TOKYO: 'Asia/Tokyo',
    SHANGHAI: 'Asia/Shanghai',
    SINGAPORE: 'Asia/Singapore',
    SYDNEY: 'Australia/Sydney',
    SAO_PAULO: 'America/Sao_Paulo'
};
base_x('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');
const fieldConfigSchema = z.object({
    required: z.boolean().prefault(true),
    returned: z.boolean().prefault(true),
    input: z.boolean().prefault(true),
    defaultValue: z.any().optional(),
    transform: z.object({
        input: z.any().optional(),
        output: z.any().optional()
    }).optional(),
    validator: z.any().optional(),
    unique: z.boolean().optional(),
    indexed: z.boolean().optional(),
    sortable: z.boolean().prefault(true),
    fieldName: z.string().optional(),
    bigint: z.boolean().prefault(false)
});
const stringFieldSchema = fieldConfigSchema.extend({
    type: z.literal('string'),
    minLength: z.number().optional(),
    maxLength: z.number().optional(),
    pattern: z.string().optional()
});
const numberFieldSchema = fieldConfigSchema.extend({
    type: z.literal('number'),
    min: z.number().optional(),
    max: z.number().optional()
});
const booleanFieldSchema = fieldConfigSchema.extend({
    type: z.literal('boolean')
});
const dateFieldSchema = fieldConfigSchema.extend({
    type: z.literal('date'),
    minDate: z.date().optional(),
    maxDate: z.date().optional(),
    dateOnly: z.boolean().prefault(false),
    format: z.record(z.string(), z.unknown()).optional()
});
const timezoneFieldSchema = fieldConfigSchema.extend({
    type: z.literal('timezone'),
    validateTimezone: z.boolean().prefault(true),
    suggestedValues: z.array(z.string()).optional(),
    restrictToSuggestedValues: z.boolean().prefault(false)
});
const jsonFieldSchema = fieldConfigSchema.extend({
    type: z.literal('json'),
    validateJson: z.boolean().prefault(true)
});
const stringArrayFieldSchema = fieldConfigSchema.extend({
    type: z.literal('string[]')
});
const numberArrayFieldSchema = fieldConfigSchema.extend({
    type: z.literal('number[]')
});
z.discriminatedUnion('type', [
    stringFieldSchema,
    numberFieldSchema,
    booleanFieldSchema,
    dateFieldSchema,
    timezoneFieldSchema,
    jsonFieldSchema,
    stringArrayFieldSchema,
    numberArrayFieldSchema
]);
async function processHooks(data, model, operation, phase, hooks, context) {
    let currentData = {
        ...data
    };
    for (const hookSet of hooks){
        const modelHooks = hookSet[model];
        if (!modelHooks) continue;
        const operationHooks = modelHooks[operation];
        if (!operationHooks) continue;
        const hookFn = operationHooks[phase];
        if (hookFn) if ('before' === phase) {
            const result = await hookFn(currentData, context);
            if (result && 'object' == typeof result && 'kind' in result) switch(result.kind){
                case 'abort':
                    return null;
                case 'transform':
                    {
                        const transformData = result.data;
                        currentData = {
                            ...currentData,
                            ...transformData
                        };
                        break;
                    }
                default:
                    break;
            }
        } else await hookFn(currentData, context);
    }
    return currentData;
}
async function processAfterHooksForMany(records, model, hooks, context) {
    if (!records.length) return;
    for (const record of records)await processHooks(record, model, 'update', 'after', hooks, context);
}
async function create_hooks_createWithHooks(adapter, ctx, props) {
    const { data, model, customFn, context } = props;
    const hooks = ctx.hooks || [];
    const transformedData = await processHooks(data, model, 'create', 'before', hooks, context);
    if (null === transformedData) return null;
    let created = null;
    if (customFn) {
        created = await customFn.fn(transformedData);
        if (!customFn.executeMainFn && created) return created;
    }
    if (!created) created = await adapter.create({
        model: model,
        data: transformedData
    });
    if (created) await processHooks(created, model, 'create', 'after', hooks, context);
    return created;
}
async function update_hooks_updateWithHooks(adapter, ctx, props) {
    const { data, where, model, customFn, context } = props;
    const hooks = ctx.hooks || [];
    const transformedData = await processHooks(data, model, 'update', 'before', hooks, context);
    if (null === transformedData) return null;
    let updated = null;
    if (customFn) {
        const result = await customFn.fn(transformedData);
        updated = result;
        if (!customFn.executeMainFn && updated) return updated;
    }
    if (!updated) updated = await adapter.update({
        model: model,
        update: transformedData,
        where
    });
    if (updated) await processHooks(updated, model, 'update', 'after', hooks, context);
    return updated;
}
async function executeCustomFunction(data, customFn) {
    if (!customFn) return {
        result: null,
        shouldContinue: true
    };
    const result = await customFn.fn(data);
    const shouldContinue = !result || !!customFn.executeMainFn;
    return {
        result,
        shouldContinue
    };
}
function processUpdateManyResult(result) {
    if (Array.isArray(result)) return result;
    if ('number' == typeof result && result > 0) return [];
    return null;
}
async function updateManyWithHooks(adapter, ctx, props) {
    const { data, where, model, customFn, context } = props;
    const hooks = ctx.hooks || [];
    const transformedData = await processHooks(data, model, 'update', 'before', hooks, context);
    if (null === transformedData) return null;
    const { result: customResult, shouldContinue } = await executeCustomFunction(transformedData, customFn);
    if (customResult && !shouldContinue) return customResult;
    let updated = customResult;
    if (!updated) {
        const adapterResult = await adapter.updateMany({
            model: model,
            update: transformedData,
            where
        });
        updated = processUpdateManyResult(adapterResult);
    }
    if (updated && updated.length > 0) await processAfterHooksForMany(updated, model, hooks, context);
    return updated;
}
function getWithHooks(adapter, ctx) {
    return {
        createWithHooks: ({ data, model, customFn, context })=>create_hooks_createWithHooks(adapter, ctx, {
                data,
                model,
                customFn,
                context
            }),
        updateWithHooks: (props)=>update_hooks_updateWithHooks(adapter, ctx, props),
        updateManyWithHooks: (props)=>updateManyWithHooks(adapter, ctx, props)
    };
}
const error_codes_ERROR_CODES = Object.freeze({
    NOT_FOUND: 'Resource not found',
    BAD_REQUEST: 'Bad request',
    CONFLICT: 'Conflict with current state',
    MISSING_REQUIRED_PARAMETER: 'Missing required parameter',
    UNAUTHORIZED: 'Unauthorized',
    FORBIDDEN: 'Forbidden',
    INTERNAL_SERVER_ERROR: 'Internal server error',
    INITIALIZATION_FAILED: 'Initialization failed',
    DATABASE_CONNECTION_ERROR: 'Database connection error',
    DATABASE_QUERY_ERROR: 'Database query error',
    INVALID_CONFIGURATION: 'Invalid configuration',
    REQUEST_HANDLER_ERROR: 'Request handler error',
    INVALID_REQUEST: 'Invalid request',
    UNKNOWN_ERROR: 'Unknown error',
    NETWORK_ERROR: 'Network error',
    PLUGIN_INITIALIZATION_FAILED: 'Plugin initialization failed',
    API_RETRIEVAL_ERROR: 'API retrieval error',
    VALIDATION_ERROR: 'Validation error',
    UNEXPECTED: 'Unexpected error'
});
const ERROR_CATEGORIES = Object.freeze({
    VALIDATION: 'validation',
    AUTHORIZATION: 'authorization',
    STORAGE: 'storage',
    NETWORK: 'network',
    PLUGIN: 'plugin',
    CONFIGURATION: 'configuration',
    UNEXPECTED: 'unexpected'
});
const tracer = trace.getTracer('@doubletie/results');
async function tracing_withSpan(name, fn, attributes = {}) {
    return await tracer.startActiveSpan(name, async (span)=>{
        try {
            span.setAttributes(attributes);
            const result = await fn(span);
            span.setStatus({
                code: SpanStatusCode.OK
            });
            span.end();
            return result;
        } catch (error) {
            if (error instanceof error_class_DoubleTieError) {
                span.setAttributes({
                    'error.type': 'DoubleTieError',
                    'error.code': error.code,
                    'error.statusCode': error.statusCode,
                    'error.message': error.message
                });
                if (error.meta) span.setAttributes({
                    'error.meta': JSON.stringify(error.meta)
                });
            } else span.setAttributes({
                'error.type': error instanceof Error ? error.constructor.name : 'Unknown',
                'error.message': error instanceof Error ? error.message : String(error)
            });
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: error instanceof Error ? error.message : String(error)
            });
            span.end();
            throw error;
        }
    });
}
class error_class_DoubleTieError extends ORPCError {
    category;
    meta;
    statusCode;
    constructor(message, options = {
        code: error_codes_ERROR_CODES.UNKNOWN_ERROR,
        status: 500,
        category: ERROR_CATEGORIES.UNEXPECTED,
        cause: void 0,
        meta: {}
    }){
        super(options.code ?? error_codes_ERROR_CODES.UNKNOWN_ERROR, {
            message,
            cause: options.cause,
            data: options.meta ?? {}
        });
        this.name = 'DoubleTieError';
        this.category = options.category ?? ERROR_CATEGORIES.UNEXPECTED;
        this.meta = options.meta ?? {};
        this.statusCode = options.status ?? 500;
        tracing_withSpan('create_doubletie_error', async (span)=>{
            span.setAttributes({
                'error.name': this.constructor.name,
                'error.message': message,
                'error.code': this.code,
                'error.status': this.statusCode,
                'error.category': this.category,
                'error.has_cause': !!this.cause,
                'error.cause_type': this.cause instanceof Error ? this.cause.constructor.name : typeof this.cause,
                'error.has_meta': !!this.meta
            });
            if (this.cause instanceof Error) span.recordException(this.cause);
        });
        if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
    }
    static isDoubleTieError(error) {
        return error instanceof error_class_DoubleTieError;
    }
    toJSON() {
        const validationErrorMessage = this.meta?.validationErrors ? String(this.meta.validationErrors) : void 0;
        const stackTrace = this.stack ? this.stack.split('\n').map((line)=>line.trim()).filter((line)=>line && !line.includes('Error: ')) : [];
        return {
            code: this.code,
            message: validationErrorMessage || this.message,
            status: this.statusCode,
            defined: true,
            data: {
                category: this.category,
                meta: this.meta,
                ...'production' === process.env.NODE_ENV ? {} : {
                    stack: stackTrace
                },
                ...validationErrorMessage && this.message ? {
                    originalMessage: this.message
                } : {},
                ...this.cause ? {
                    cause: this.cause instanceof Error ? {
                        name: this.cause.name,
                        message: this.cause.message,
                        stack: this.cause.stack ? this.cause.stack.split('\n').map((line)=>line.trim()) : void 0
                    } : this.cause
                } : {}
            }
        };
    }
    static fromResponse(response, data) {
        let message = `HTTP error ${response.status}`;
        let errorCode = `HTTP ${response.status}`;
        let errorMeta = {};
        if (data && 'object' == typeof data && null !== data) {
            const errorObj = data;
            if ('string' == typeof errorObj.message) message = errorObj.message;
            if ('string' == typeof errorObj.code) errorCode = errorObj.code;
            if ('object' == typeof errorObj.data && null !== errorObj.data) errorMeta = errorObj.data;
        }
        return new error_class_DoubleTieError(message, {
            code: errorCode,
            status: response.status,
            meta: errorMeta
        });
    }
    withMeta(additionalMeta) {
        return new error_class_DoubleTieError(this.message, {
            code: this.code,
            status: this.statusCode,
            category: this.category,
            cause: this.cause instanceof Error ? this.cause : void 0,
            meta: {
                ...this.meta,
                ...additionalMeta
            }
        });
    }
    static createSubclass(name) {
        const ErrorSubclass = class extends error_class_DoubleTieError {
            constructor(message, options){
                super(message, options);
                Object.defineProperty(this, 'name', {
                    value: name
                });
            }
        };
        Object.defineProperty(ErrorSubclass, 'name', {
            value: name
        });
        return ErrorSubclass;
    }
    static formatValidationError(error) {
        if (!error.meta) return error.message;
        let formattedMessage = `${error.message} (${error.code})`;
        if (error.meta.validationErrors) formattedMessage += `\nValidation Errors: ${JSON.stringify(error.meta.validationErrors, null, 2)}`;
        const otherMeta = Object.fromEntries(Object.entries(error.meta).filter(([key])=>'validationErrors' !== key));
        if (Object.keys(otherMeta).length > 0) formattedMessage += `\nAdditional Context: ${JSON.stringify(otherMeta, null, 2)}`;
        return formattedMessage;
    }
}
function auditLogRegistry({ adapter, ...ctx }) {
    const { createWithHooks } = getWithHooks(adapter, ctx);
    return {
        createAuditLog: async (auditLog, context)=>{
            const createdLog = await createWithHooks({
                data: {
                    createdAt: new Date(),
                    ...auditLog
                },
                model: 'auditLog',
                customFn: void 0,
                context
            });
            if (!createdLog) throw new error_class_DoubleTieError('Failed to create audit log - operation returned null', {
                code: error_codes_ERROR_CODES.INTERNAL_SERVER_ERROR,
                status: 500
            });
            return createdLog;
        }
    };
}
const auditLogSchema = z.object({
    id: z.string(),
    entityType: z.string(),
    entityId: z.string(),
    actionType: z.string(),
    subjectId: z.string().optional(),
    ipAddress: z.string().optional(),
    userAgent: z.string().optional(),
    changes: z.record(z.string(), z.unknown()).optional(),
    metadata: z.record(z.string(), z.unknown()).optional(),
    createdAt: z.date().prefault(()=>new Date())
});
function getAuditLogTable(options, auditLogFields) {
    const auditLogConfig = options.tables?.auditLog;
    const subjectConfig = options.tables?.subject;
    return {
        entityName: auditLogConfig?.entityName || 'auditLog',
        entityPrefix: auditLogConfig?.entityPrefix || 'log',
        schema: auditLogSchema,
        fields: {
            entityType: {
                type: 'string',
                required: true,
                fieldName: auditLogConfig?.fields?.entityType || 'entityType'
            },
            entityId: {
                type: 'string',
                required: true,
                fieldName: auditLogConfig?.fields?.entityId || 'entityId'
            },
            actionType: {
                type: 'string',
                required: true,
                fieldName: auditLogConfig?.fields?.actionType || 'actionType'
            },
            subjectId: {
                type: 'string',
                required: false,
                fieldName: auditLogConfig?.fields?.subjectId || 'subjectId',
                references: {
                    model: subjectConfig?.entityName || 'subject',
                    field: 'id'
                }
            },
            ipAddress: {
                type: 'string',
                required: false,
                fieldName: auditLogConfig?.fields?.ipAddress || 'ipAddress'
            },
            userAgent: {
                type: 'string',
                required: false,
                fieldName: auditLogConfig?.fields?.userAgent || 'userAgent'
            },
            changes: {
                type: 'json',
                required: false,
                fieldName: auditLogConfig?.fields?.changes || 'changes'
            },
            metadata: {
                type: 'json',
                required: false,
                fieldName: auditLogConfig?.fields?.metadata || 'metadata'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: auditLogConfig?.fields?.createdAt || 'createdAt'
            },
            eventTimezone: {
                type: 'timezone',
                required: true,
                defaultValue: COMMON_TIMEZONES.UTC,
                fieldName: auditLogConfig?.fields?.eventTimezone || 'eventTimezone'
            },
            ...auditLogFields || {},
            ...auditLogConfig?.additionalFields || {}
        },
        indexes: [
            {
                name: 'entity_index',
                fields: [
                    'entityType',
                    'entityId'
                ]
            },
            {
                name: 'action_type_index',
                fields: [
                    'actionType'
                ]
            },
            {
                name: 'subject_id_index',
                fields: [
                    'subjectId'
                ]
            },
            {
                name: 'created_at_index',
                fields: [
                    'createdAt'
                ]
            }
        ],
        order: 5
    };
}
const consentSchema = z.object({
    id: z.string(),
    subjectId: z.string(),
    domainId: z.string(),
    purposeIds: z.array(z.string()),
    metadata: z.record(z.string(), z.unknown()).nullable().optional(),
    policyId: z.string().optional(),
    ipAddress: z.string().nullable().optional(),
    userAgent: z.string().nullable().optional(),
    status: z["enum"]([
        'active',
        'withdrawn',
        'expired'
    ]).prefault('active'),
    withdrawalReason: z.string().nullable().optional(),
    givenAt: z.date().prefault(()=>new Date()),
    validUntil: z.date().nullable().optional(),
    isActive: z.boolean().prefault(true)
});
function getConsentTable(options, consentFields) {
    const consentConfig = options.tables?.consent;
    const subjectConfig = options.tables?.subject;
    const domainConfig = options.tables?.domain;
    const policyConfig = options.tables?.consentPolicy;
    return {
        entityName: consentConfig?.entityName || 'consent',
        entityPrefix: consentConfig?.entityPrefix || 'cns',
        schema: consentSchema,
        fields: {
            subjectId: {
                type: 'string',
                required: true,
                fieldName: consentConfig?.fields?.subjectId || 'subjectId',
                references: {
                    model: subjectConfig?.entityName || 'subject',
                    field: 'id'
                }
            },
            domainId: {
                type: 'string',
                required: true,
                fieldName: consentConfig?.fields?.domainId || 'domainId',
                references: {
                    model: domainConfig?.entityName || 'domain',
                    field: 'id'
                }
            },
            purposeIds: {
                type: 'json',
                required: false,
                fieldName: consentConfig?.fields?.purposeIds || 'purposeIds'
            },
            metadata: {
                type: 'json',
                required: false,
                fieldName: consentConfig?.fields?.metadata || 'metadata'
            },
            policyId: {
                type: 'string',
                required: false,
                fieldName: consentConfig?.fields?.policyId || 'policyId',
                references: {
                    model: policyConfig?.entityName || 'consentPolicy',
                    field: 'id'
                }
            },
            ipAddress: {
                type: 'string',
                required: false,
                fieldName: consentConfig?.fields?.ipAddress || 'ipAddress'
            },
            userAgent: {
                type: 'string',
                required: false,
                fieldName: consentConfig?.fields?.userAgent || 'userAgent'
            },
            status: {
                type: 'string',
                defaultValue: ()=>'active',
                required: true,
                fieldName: consentConfig?.fields?.status || 'status'
            },
            withdrawalReason: {
                type: 'string',
                required: false,
                fieldName: consentConfig?.fields?.withdrawalReason || 'withdrawalReason'
            },
            givenAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: consentConfig?.fields?.givenAt || 'givenAt'
            },
            validUntil: {
                type: 'date',
                required: false,
                fieldName: consentConfig?.fields?.validUntil || 'validUntil',
                transform: {
                    input: (val, data)=>{
                        if (val) return val;
                        const expiresIn = consentConfig?.expiresIn || 31536000;
                        const givenAt = data.givenAt instanceof Date ? data.givenAt : new Date();
                        if (expiresIn > 0) {
                            const validUntil = new Date(givenAt);
                            validUntil.setSeconds(validUntil.getSeconds() + expiresIn);
                            return validUntil;
                        }
                    }
                }
            },
            isActive: {
                type: 'boolean',
                defaultValue: true,
                required: true,
                fieldName: consentConfig?.fields?.isActive || 'isActive'
            },
            ...consentFields || {},
            ...consentConfig?.additionalFields || {}
        },
        order: 3
    };
}
const PolicyTypeSchema = z["enum"]([
    'cookie_banner',
    'privacy_policy',
    'dpa',
    'terms_and_conditions',
    'marketing_communications',
    'age_verification',
    'other'
]);
const consentPolicySchema = z.object({
    id: z.string(),
    version: z.string(),
    type: PolicyTypeSchema,
    name: z.string(),
    effectiveDate: z.date(),
    expirationDate: z.date().nullable().optional(),
    content: z.string(),
    contentHash: z.string(),
    isActive: z.boolean().prefault(true),
    createdAt: z.date().prefault(()=>new Date()),
    updatedAt: z.date().prefault(()=>new Date())
});
function getConsentPolicyTable(options, policyFields) {
    const consentPolicyConfig = options.tables?.consentPolicy;
    return {
        entityName: consentPolicyConfig?.entityName || 'consentPolicy',
        entityPrefix: consentPolicyConfig?.entityPrefix || 'pol',
        schema: consentPolicySchema,
        fields: {
            version: {
                type: 'string',
                required: true,
                fieldName: consentPolicyConfig?.fields?.version || 'version'
            },
            type: {
                type: 'string',
                required: true,
                fieldName: consentPolicyConfig?.fields?.type || 'type'
            },
            name: {
                type: 'string',
                required: true,
                fieldName: consentPolicyConfig?.fields?.name || 'name'
            },
            effectiveDate: {
                type: 'date',
                required: true,
                fieldName: consentPolicyConfig?.fields?.effectiveDate || 'effectiveDate'
            },
            expirationDate: {
                type: 'date',
                required: false,
                fieldName: consentPolicyConfig?.fields?.expirationDate || 'expirationDate'
            },
            content: {
                type: 'string',
                required: true,
                fieldName: consentPolicyConfig?.fields?.content || 'content'
            },
            contentHash: {
                type: 'string',
                required: true,
                fieldName: consentPolicyConfig?.fields?.contentHash || 'contentHash'
            },
            isActive: {
                type: 'boolean',
                defaultValue: true,
                required: true,
                fieldName: consentPolicyConfig?.fields?.isActive || 'isActive'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: consentPolicyConfig?.fields?.createdAt || 'createdAt'
            },
            ...policyFields || {},
            ...consentPolicyConfig?.additionalFields || {}
        },
        order: 2
    };
}
const purposeSchema = z.object({
    id: z.string(),
    code: z.string(),
    name: z.string(),
    description: z.string(),
    isEssential: z.boolean().prefault(false),
    dataCategory: z.string().nullish(),
    legalBasis: z.string().nullish(),
    isActive: z.boolean().prefault(true),
    createdAt: z.date().prefault(()=>new Date()),
    updatedAt: z.date().prefault(()=>new Date())
});
function getPurposeTable(options, purposeFields) {
    const purposeConfig = options.tables?.consentPurpose;
    return {
        entityName: purposeConfig?.entityName || 'consentPurpose',
        entityPrefix: purposeConfig?.entityPrefix || 'pur',
        schema: purposeSchema,
        fields: {
            code: {
                type: 'string',
                required: true,
                fieldName: purposeConfig?.fields?.code || 'code'
            },
            name: {
                type: 'string',
                required: true,
                fieldName: purposeConfig?.fields?.name || 'name'
            },
            description: {
                type: 'string',
                required: true,
                fieldName: purposeConfig?.fields?.description || "description"
            },
            isEssential: {
                type: 'boolean',
                defaultValue: ()=>false,
                required: true,
                fieldName: purposeConfig?.fields?.isEssential || 'isEssential'
            },
            dataCategory: {
                type: 'string',
                required: false,
                fieldName: purposeConfig?.fields?.dataCategory || 'dataCategory'
            },
            legalBasis: {
                type: 'string',
                required: false,
                fieldName: purposeConfig?.fields?.legalBasis || 'legalBasis'
            },
            isActive: {
                type: 'boolean',
                defaultValue: true,
                required: true,
                fieldName: purposeConfig?.fields?.isActive || 'isActive'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: purposeConfig?.fields?.createdAt || 'createdAt'
            },
            updatedAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: purposeConfig?.fields?.updatedAt || 'updatedAt'
            },
            ...purposeFields || {},
            ...purposeConfig?.additionalFields || {}
        },
        order: 1
    };
}
const consentRecordSchema = z.object({
    id: z.string(),
    subjectId: z.string(),
    consentId: z.string().optional(),
    actionType: z.string(),
    details: z.record(z.string(), z.unknown()).optional(),
    createdAt: z.date().prefault(()=>new Date()),
    updatedAt: z.date().prefault(()=>new Date())
});
function getConsentRecordTable(options, recordFields) {
    const recordConfig = options.tables?.record;
    const subjectConfig = options.tables?.subject;
    const consentConfig = options.tables?.consent;
    return {
        entityName: recordConfig?.entityName || 'consentRecord',
        entityPrefix: recordConfig?.entityPrefix || 'rec',
        schema: consentRecordSchema,
        fields: {
            subjectId: {
                type: 'string',
                required: true,
                fieldName: recordConfig?.fields?.subjectId || 'subjectId',
                references: {
                    model: subjectConfig?.entityName || 'subject',
                    field: 'id'
                }
            },
            consentId: {
                type: 'string',
                required: false,
                fieldName: recordConfig?.fields?.consentId || 'consentId',
                references: {
                    model: consentConfig?.entityName || 'consent',
                    field: 'id'
                }
            },
            actionType: {
                type: 'string',
                required: true,
                fieldName: recordConfig?.fields?.actionType || 'actionType'
            },
            details: {
                type: 'json',
                required: false,
                fieldName: recordConfig?.fields?.details || 'details'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: recordConfig?.fields?.createdAt || 'createdAt'
            },
            ...recordFields || {},
            ...recordConfig?.additionalFields || {}
        },
        order: 4
    };
}
const domainSchema = z.object({
    id: z.string(),
    name: z.string().min(1),
    description: z.string().optional(),
    allowedOrigins: z.array(z.string()).optional().prefault([]),
    isVerified: z.boolean().prefault(true),
    isActive: z.boolean().prefault(true),
    createdAt: z.date().prefault(()=>new Date()),
    updatedAt: z.date().prefault(()=>new Date())
});
function getDomainTable(options, domainFields) {
    const domainConfig = options.tables?.domain;
    return {
        entityName: domainConfig?.entityName || 'domain',
        entityPrefix: domainConfig?.entityPrefix || 'dom',
        schema: domainSchema,
        fields: {
            name: {
                type: 'string',
                required: true,
                unique: true,
                fieldName: domainConfig?.fields?.name || 'name'
            },
            description: {
                type: 'string',
                required: false,
                fieldName: domainConfig?.fields?.description || "description"
            },
            allowedOrigins: {
                type: 'json',
                defaultValue: ()=>[],
                required: false,
                fieldName: domainConfig?.fields?.allowedOrigins || 'allowedOrigins'
            },
            isVerified: {
                type: 'boolean',
                defaultValue: true,
                required: true,
                fieldName: domainConfig?.fields?.isVerified || 'isVerified'
            },
            isActive: {
                type: 'boolean',
                defaultValue: true,
                required: true,
                fieldName: domainConfig?.fields?.isActive || 'isActive'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: domainConfig?.fields?.createdAt || 'createdAt'
            },
            updatedAt: {
                type: 'date',
                required: false,
                fieldName: domainConfig?.fields?.updatedAt || 'updatedAt'
            },
            ...domainFields || {},
            ...domainConfig?.additionalFields || {}
        },
        order: 1
    };
}
const subjectSchema = z.object({
    id: z.string(),
    isIdentified: z.boolean().prefault(false),
    externalId: z.string().nullable().optional(),
    identityProvider: z.string().optional(),
    lastIpAddress: z.string().optional(),
    createdAt: z.date().prefault(()=>new Date()),
    updatedAt: z.date().prefault(()=>new Date())
});
function getSubjectTable(options, subjectFields) {
    const subjectConfig = options.tables?.subject;
    return {
        entityName: subjectConfig?.entityName || 'subject',
        entityPrefix: subjectConfig?.entityPrefix || 'sub',
        schema: subjectSchema,
        fields: {
            isIdentified: {
                type: 'boolean',
                defaultValue: ()=>false,
                required: true,
                fieldName: subjectConfig?.fields?.isIdentified || 'isIdentified'
            },
            externalId: {
                type: 'string',
                required: false,
                fieldName: subjectConfig?.fields?.externalId || 'externalId'
            },
            identityProvider: {
                type: 'string',
                required: false,
                fieldName: subjectConfig?.fields?.identityProvider || 'identityProvider'
            },
            lastIpAddress: {
                type: 'string',
                required: false,
                fieldName: subjectConfig?.fields?.lastIpAddress || 'lastIpAddress'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: subjectConfig?.fields?.createdAt || 'createdAt'
            },
            updatedAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: subjectConfig?.fields?.updatedAt || 'updatedAt'
            },
            subjectTimezone: {
                type: 'timezone',
                required: false,
                defaultValue: COMMON_TIMEZONES.UTC,
                fieldName: subjectConfig?.fields?.subjectTimezone || 'subjectTimezone'
            },
            ...subjectFields || {},
            ...subjectConfig?.additionalFields || {}
        },
        order: 1
    };
}
const getConsentTables = (options)=>{
    const pluginSchema = options.plugins?.reduce((acc, plugin)=>{
        const schema = plugin.schema;
        if (!schema) return acc;
        for (const [key, value] of Object.entries(schema))acc[key] = {
            fields: {
                ...acc[key]?.fields,
                ...value.fields
            },
            entityName: key
        };
        return acc;
    }, {});
    const { subject, consentPurpose, consentPolicy, domain, geoLocation, consent, consentPurposeJunction, record, consentGeoLocation, consentWithdrawal, auditLog, ...pluginTables } = pluginSchema || {};
    return {
        subject: getSubjectTable(options, subject?.fields),
        consentPurpose: getPurposeTable(options, consentPurpose?.fields),
        consentPolicy: getConsentPolicyTable(options, consentPolicy?.fields),
        domain: getDomainTable(options, domain?.fields),
        consent: getConsentTable(options, consent?.fields),
        consentRecord: getConsentRecordTable(options, record?.fields),
        auditLog: getAuditLogTable(options, auditLog?.fields),
        ...pluginTables
    };
};
function validateEntityOutput(tableName, data, options) {
    const tables = getConsentTables(options);
    const table = tables[tableName];
    if (!table) throw new Error(`Table ${tableName} not found`);
    const processedData = {
        ...data
    };
    for (const [field, def] of Object.entries(table.fields))if ('date' === def.type && 'string' == typeof processedData[field]) processedData[field] = new Date(processedData[field]);
    try {
        return table.schema.parse(processedData);
    } catch (error) {
        if (error instanceof ZodError) logger.error(`[validateEntityOutput] Validation failed for table ${String(tableName)}`, {
            table,
            issues: error.issues
        });
        throw error;
    }
}
function consentRegistry({ adapter, ...ctx }) {
    const { createWithHooks, updateWithHooks } = getWithHooks(adapter, ctx);
    const registry = {
        createConsent: async (consent, context)=>{
            const createdConsent = await createWithHooks({
                data: {
                    createdAt: new Date(),
                    ...consent
                },
                model: 'consent',
                context
            });
            if (!createdConsent) throw new error_class_DoubleTieError('Failed to create consent - operation returned null', {
                code: error_codes_ERROR_CODES.INTERNAL_SERVER_ERROR,
                status: 500
            });
            return createdConsent;
        },
        updateConsent: async (consentId, data, context)=>{
            const consent = await updateWithHooks({
                data: {
                    ...data
                },
                where: [
                    {
                        field: 'id',
                        value: consentId
                    }
                ],
                model: 'consent',
                context
            });
            return consent ? validateEntityOutput('consent', consent, ctx.options) : null;
        }
    };
    return registry;
}
async function generatePolicyPlaceholder(name, date) {
    const content = `[PLACEHOLDER] This is an automatically generated version of the ${name} policy.\n\nThis placeholder content should be replaced with actual policy terms before being presented to users.\n\nGenerated on: ${date.toISOString()}`;
    let contentHash;
    try {
        const encoder = new TextEncoder();
        const data = encoder.encode(content);
        const hashBuffer = await crypto.subtle.digest('SHA-256', data);
        contentHash = Array.from(new Uint8Array(hashBuffer)).map((b)=>b.toString(16).padStart(2, '0')).join('');
    } catch (error) {
        throw new error_class_DoubleTieError('Failed to generate policy content hash', {
            code: error_codes_ERROR_CODES.INTERNAL_SERVER_ERROR,
            status: 500,
            cause: error instanceof Error ? error : new Error(String(error))
        });
    }
    return {
        content,
        contentHash
    };
}
function policyRegistry({ adapter, ...ctx }) {
    const { createWithHooks } = getWithHooks(adapter, ctx);
    const registry = {
        createConsentPolicy: async (policy, context)=>{
            const createdPolicy = await createWithHooks({
                data: {
                    createdAt: new Date(),
                    ...policy
                },
                model: 'consentPolicy',
                context
            });
            if (!createdPolicy) throw new error_class_DoubleTieError('Failed to create consent policy - operation returned null', {
                code: error_codes_ERROR_CODES.INTERNAL_SERVER_ERROR,
                status: 500
            });
            return createdPolicy;
        },
        findPolicies: async (params = {})=>{
            const whereConditions = [];
            if (!params.includeInactive) whereConditions.push({
                field: 'isActive',
                value: true
            });
            if (params.domainId) whereConditions.push({
                field: 'id',
                value: params.domainId
            });
            if (params.version) whereConditions.push({
                field: 'version',
                value: params.version
            });
            const policies = await adapter.findMany({
                model: 'consentPolicy',
                where: whereConditions,
                sortBy: {
                    field: 'effectiveDate',
                    direction: 'desc'
                }
            });
            return policies.map((policy)=>validateEntityOutput('consentPolicy', policy, ctx.options));
        },
        findConsentPolicyById: async (policyId)=>{
            const policy = await adapter.findOne({
                model: 'consentPolicy',
                where: [
                    {
                        field: 'id',
                        value: policyId
                    }
                ]
            });
            return policy ? validateEntityOutput('consentPolicy', policy, ctx.options) : null;
        },
        findOrCreatePolicy: async (type)=>await adapter.transaction({
                callback: async (txAdapter)=>{
                    try {
                        const now = new Date();
                        const txRegistry = policyRegistry({
                            adapter: txAdapter,
                            ...ctx
                        });
                        const rawLatestPolicy = await txAdapter.findOne({
                            model: 'consentPolicy',
                            where: [
                                {
                                    field: 'isActive',
                                    value: true
                                },
                                {
                                    field: 'type',
                                    value: type
                                }
                            ],
                            sortBy: {
                                field: 'effectiveDate',
                                direction: 'desc'
                            }
                        });
                        const latestPolicy = rawLatestPolicy ? validateEntityOutput('consentPolicy', rawLatestPolicy, ctx.options) : null;
                        if (latestPolicy) return latestPolicy;
                        const { content: defaultContent, contentHash } = await generatePolicyPlaceholder(type, now);
                        return txRegistry.createConsentPolicy({
                            version: '1.0.0',
                            type,
                            name: type,
                            effectiveDate: now,
                            content: defaultContent,
                            contentHash,
                            isActive: true,
                            updatedAt: now,
                            expirationDate: null
                        });
                    } catch (error) {
                        ctx.logger.error('Error in findOrCreatePolicy transaction:', error);
                        throw new error_class_DoubleTieError('Failed to find or create policy', {
                            code: error_codes_ERROR_CODES.INTERNAL_SERVER_ERROR,
                            status: 500,
                            cause: error instanceof Error ? error : new Error(String(error))
                        });
                    }
                }
            })
    };
    return registry;
}
function consentPurposeRegistry({ adapter, ...ctx }) {
    const { createWithHooks } = getWithHooks(adapter, ctx);
    return {
        createConsentPurpose: async (consentPurpose, context)=>{
            const createdPurpose = await createWithHooks({
                data: {
                    id: consentPurpose.id || '',
                    createdAt: new Date(),
                    updatedAt: new Date(),
                    ...consentPurpose
                },
                model: 'consentPurpose',
                context
            });
            if (!createdPurpose) throw new error_class_DoubleTieError('Failed to create consent purpose - operation returned null', {
                code: error_codes_ERROR_CODES.INTERNAL_SERVER_ERROR,
                status: 500
            });
            return validateEntityOutput('consentPurpose', createdPurpose, ctx.options);
        },
        findConsentPurposeByCode: async (code)=>{
            const consentPurpose = await adapter.findOne({
                model: 'consentPurpose',
                where: [
                    {
                        field: 'code',
                        value: code
                    }
                ]
            });
            return consentPurpose ? validateEntityOutput('consentPurpose', consentPurpose, ctx.options) : null;
        }
    };
}
function domainRegistry({ adapter, ...ctx }) {
    const { createWithHooks } = getWithHooks(adapter, ctx);
    const registry = {
        createDomain: async (domain, context)=>{
            const createdDomain = await createWithHooks({
                data: {
                    ...domain,
                    createdAt: new Date(),
                    updatedAt: new Date()
                },
                model: 'domain',
                customFn: void 0,
                context
            });
            if (!createdDomain) throw new error_class_DoubleTieError('Failed to create domain - operation returned null', {
                code: error_codes_ERROR_CODES.INTERNAL_SERVER_ERROR,
                status: 500
            });
            return createdDomain;
        },
        findOrCreateDomain: async function(name, context) {
            const existingDomain = await this.findDomainByName(name);
            if (existingDomain) return existingDomain;
            const domain = await this.createDomain({
                name,
                description: `Auto-created domain for ${name}`,
                isActive: true,
                isVerified: true,
                allowedOrigins: []
            }, context);
            if (!domain) throw new error_class_DoubleTieError('Failed to create domain', {
                code: error_codes_ERROR_CODES.INTERNAL_SERVER_ERROR,
                status: 503
            });
            return domain;
        },
        findDomains: async (params = {})=>{
            const whereConditions = [];
            if (!params.includeInactive) whereConditions.push({
                field: 'isActive',
                value: true
            });
            if (params.name) whereConditions.push({
                field: 'name',
                value: params.name
            });
            const domains = await adapter.findMany({
                model: 'domain',
                where: whereConditions,
                sortBy: {
                    field: 'name',
                    direction: 'asc'
                }
            });
            return domains.map((domain)=>validateEntityOutput('domain', domain, ctx.options));
        },
        findDomain: async (name)=>{
            const domains = await registry.findDomains({
                name,
                includeInactive: false
            });
            return domains[0] || null;
        },
        findDomainByName: async (name)=>{
            const domain = await adapter.findOne({
                model: 'domain',
                where: [
                    {
                        field: 'name',
                        value: name
                    }
                ]
            });
            return domain ? validateEntityOutput('domain', domain, ctx.options) : null;
        }
    };
    return registry;
}
function subjectRegistry({ adapter, ...ctx }) {
    const { createWithHooks } = getWithHooks(adapter, ctx);
    return {
        createSubject: async (subject, context)=>{
            const createdSubject = await createWithHooks({
                data: {
                    createdAt: new Date(),
                    updatedAt: new Date(),
                    ...subject
                },
                model: 'subject',
                customFn: void 0,
                context
            });
            return createdSubject ? validateEntityOutput('subject', createdSubject, ctx.options) : null;
        },
        findOrCreateSubject: async function({ subjectId, externalSubjectId, identityProvider, ipAddress = 'unknown', context }) {
            if (subjectId && externalSubjectId) {
                const [subjectById, subjectByExternalId] = await Promise.all([
                    this.findSubjectById(subjectId),
                    this.findSubjectByExternalId(externalSubjectId)
                ]);
                if (!subjectById || !subjectByExternalId) {
                    ctx.logger?.error('Subject validation failed: One or both subjects not found', {
                        providedSubjectId: subjectId,
                        providedExternalId: externalSubjectId,
                        subjectByIdFound: !!subjectById,
                        subjectByExternalIdFound: !!subjectByExternalId
                    });
                    throw new error_class_DoubleTieError('The specified subject could not be found. Please verify the subject identifiers and try again.', {
                        code: error_codes_ERROR_CODES.NOT_FOUND,
                        status: 404,
                        meta: {
                            providedSubjectId: subjectId,
                            providedExternalId: externalSubjectId
                        }
                    });
                }
                if (subjectById.id !== subjectByExternalId.id) {
                    ctx.logger?.warn('Subject validation failed: IDs do not match the same subject', {
                        providedSubjectId: subjectId,
                        providedExternalId: externalSubjectId,
                        subjectByIdId: subjectById.id,
                        subjectByExternalIdId: subjectByExternalId.id
                    });
                    throw new error_class_DoubleTieError('The provided subjectId and externalSubjectId do not match the same subject. Please ensure both identifiers refer to the same subject.', {
                        code: error_codes_ERROR_CODES.CONFLICT,
                        status: 409,
                        meta: {
                            providedSubjectId: subjectId,
                            providedExternalId: externalSubjectId,
                            subjectByIdId: subjectById.id,
                            subjectByExternalIdId: subjectByExternalId.id
                        }
                    });
                }
                return subjectById;
            }
            if (subjectId) {
                const subject = await this.findSubjectById(subjectId);
                if (subject) return subject;
                throw new error_class_DoubleTieError('Subject not found by subjectId', {
                    code: error_codes_ERROR_CODES.NOT_FOUND,
                    status: 404
                });
            }
            if (externalSubjectId) try {
                const subject = await this.findSubjectByExternalId(externalSubjectId);
                if (subject) {
                    ctx.logger?.debug('Found existing subject by external ID', {
                        externalSubjectId
                    });
                    return subject;
                }
                ctx.logger?.info('Creating new subject with external ID', {
                    externalSubjectId
                });
                return await this.createSubject({
                    externalId: externalSubjectId,
                    identityProvider: identityProvider ?? 'external',
                    lastIpAddress: ipAddress,
                    isIdentified: true
                }, context);
            } catch (error) {
                if (error instanceof Error && error.message.includes('unique constraint')) {
                    ctx.logger?.info('Handling duplicate key violation for external ID', {
                        externalSubjectId
                    });
                    const subject = await this.findSubjectByExternalId(externalSubjectId);
                    if (subject) return subject;
                }
                ctx.logger?.error('Failed to create or find subject with external ID', {
                    externalSubjectId,
                    error: error instanceof Error ? error.message : 'Unknown error'
                });
                throw new error_class_DoubleTieError('Failed to create or find subject with external ID', {
                    code: error_codes_ERROR_CODES.INTERNAL_SERVER_ERROR,
                    status: 500,
                    meta: {
                        error: error instanceof Error ? error.message : 'Unknown error'
                    }
                });
            }
            try {
                ctx.logger?.info('Creating new anonymous subject');
                return await this.createSubject({
                    externalId: null,
                    identityProvider: 'anonymous',
                    lastIpAddress: ipAddress,
                    isIdentified: false
                }, context);
            } catch (error) {
                ctx.logger?.error('Failed to create anonymous subject', {
                    ipAddress,
                    error: error instanceof Error ? error.message : 'Unknown error'
                });
                throw new error_class_DoubleTieError('Failed to create anonymous subject', {
                    code: error_codes_ERROR_CODES.INTERNAL_SERVER_ERROR,
                    status: 500,
                    meta: {
                        error: error instanceof Error ? error.message : 'Unknown error'
                    }
                });
            }
        },
        findSubjectById: async (subjectId)=>{
            const subject = await adapter.findOne({
                model: 'subject',
                where: [
                    {
                        field: 'id',
                        value: subjectId
                    }
                ]
            });
            return subject ? validateEntityOutput('subject', subject, ctx.options) : null;
        },
        findSubjectByExternalId: async (externalId)=>{
            const subject = await adapter.findOne({
                model: 'subject',
                where: [
                    {
                        field: 'externalId',
                        value: externalId
                    }
                ]
            });
            return subject ? validateEntityOutput('subject', subject, ctx.options) : null;
        }
    };
}
export { PolicyTypeSchema, auditLogRegistry, auditLogSchema, consentPolicySchema, consentPurposeRegistry, consentRecordSchema, consentRegistry, consentSchema, domainRegistry, domainSchema, getAuditLogTable, getConsentPolicyTable, getConsentRecordTable, getConsentTable, getDomainTable, getPurposeTable, getSubjectTable, policyRegistry, purposeSchema, subjectRegistry, subjectSchema };
