import "neverthrow";
import "@orpc/server";
import { trace } from "@opentelemetry/api";
import { createLogger as logger_createLogger } from "@c15t/logger";
import base_x from "base-x";
import { z } from "zod";
import { Kysely, MssqlDialect, MysqlDialect, PostgresDialect, SqliteDialect } from "kysely";
import "superjson";
import "drizzle-orm";
Object.freeze({
    NOT_FOUND: 'Resource not found',
    BAD_REQUEST: 'Bad request',
    CONFLICT: 'Conflict with current state',
    MISSING_REQUIRED_PARAMETER: 'Missing required parameter',
    UNAUTHORIZED: 'Unauthorized',
    FORBIDDEN: 'Forbidden',
    INTERNAL_SERVER_ERROR: 'Internal server error',
    INITIALIZATION_FAILED: 'Initialization failed',
    DATABASE_CONNECTION_ERROR: 'Database connection error',
    DATABASE_QUERY_ERROR: 'Database query error',
    INVALID_CONFIGURATION: 'Invalid configuration',
    REQUEST_HANDLER_ERROR: 'Request handler error',
    INVALID_REQUEST: 'Invalid request',
    UNKNOWN_ERROR: 'Unknown error',
    NETWORK_ERROR: 'Network error',
    PLUGIN_INITIALIZATION_FAILED: 'Plugin initialization failed',
    API_RETRIEVAL_ERROR: 'API retrieval error',
    VALIDATION_ERROR: 'Validation error',
    UNEXPECTED: 'Unexpected error'
});
Object.freeze({
    VALIDATION: 'validation',
    AUTHORIZATION: 'authorization',
    STORAGE: 'storage',
    NETWORK: 'network',
    PLUGIN: 'plugin',
    CONFIGURATION: 'configuration',
    UNEXPECTED: 'unexpected'
});
trace.getTracer('@doubletie/results');
let globalLogger;
function logger_getLogger(options) {
    if (!globalLogger) globalLogger = logger_createLogger({
        level: 'info',
        appName: 'c15t',
        ...options
    });
    return globalLogger;
}
const COMMON_TIMEZONES = {
    UTC: 'UTC',
    GMT: 'GMT',
    EASTERN: 'America/New_York',
    CENTRAL: 'America/Chicago',
    MOUNTAIN: 'America/Denver',
    PACIFIC: 'America/Los_Angeles',
    LONDON: 'Europe/London',
    PARIS: 'Europe/Paris',
    BERLIN: 'Europe/Berlin',
    TOKYO: 'Asia/Tokyo',
    SHANGHAI: 'Asia/Shanghai',
    SINGAPORE: 'Asia/Singapore',
    SYDNEY: 'Australia/Sydney',
    SAO_PAULO: 'America/Sao_Paulo'
};
base_x('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');
const fieldConfigSchema = z.object({
    required: z.boolean().prefault(true),
    returned: z.boolean().prefault(true),
    input: z.boolean().prefault(true),
    defaultValue: z.any().optional(),
    transform: z.object({
        input: z.any().optional(),
        output: z.any().optional()
    }).optional(),
    validator: z.any().optional(),
    unique: z.boolean().optional(),
    indexed: z.boolean().optional(),
    sortable: z.boolean().prefault(true),
    fieldName: z.string().optional(),
    bigint: z.boolean().prefault(false)
});
const stringFieldSchema = fieldConfigSchema.extend({
    type: z.literal('string'),
    minLength: z.number().optional(),
    maxLength: z.number().optional(),
    pattern: z.string().optional()
});
const numberFieldSchema = fieldConfigSchema.extend({
    type: z.literal('number'),
    min: z.number().optional(),
    max: z.number().optional()
});
const booleanFieldSchema = fieldConfigSchema.extend({
    type: z.literal('boolean')
});
const dateFieldSchema = fieldConfigSchema.extend({
    type: z.literal('date'),
    minDate: z.date().optional(),
    maxDate: z.date().optional(),
    dateOnly: z.boolean().prefault(false),
    format: z.record(z.string(), z.unknown()).optional()
});
const timezoneFieldSchema = fieldConfigSchema.extend({
    type: z.literal('timezone'),
    validateTimezone: z.boolean().prefault(true),
    suggestedValues: z.array(z.string()).optional(),
    restrictToSuggestedValues: z.boolean().prefault(false)
});
const jsonFieldSchema = fieldConfigSchema.extend({
    type: z.literal('json'),
    validateJson: z.boolean().prefault(true)
});
const stringArrayFieldSchema = fieldConfigSchema.extend({
    type: z.literal('string[]')
});
const numberArrayFieldSchema = fieldConfigSchema.extend({
    type: z.literal('number[]')
});
z.discriminatedUnion('type', [
    stringFieldSchema,
    numberFieldSchema,
    booleanFieldSchema,
    dateFieldSchema,
    timezoneFieldSchema,
    jsonFieldSchema,
    stringArrayFieldSchema,
    numberArrayFieldSchema
]);
const schema_auditLogSchema = z.object({
    id: z.string(),
    entityType: z.string(),
    entityId: z.string(),
    actionType: z.string(),
    subjectId: z.string().optional(),
    ipAddress: z.string().optional(),
    userAgent: z.string().optional(),
    changes: z.record(z.string(), z.unknown()).optional(),
    metadata: z.record(z.string(), z.unknown()).optional(),
    createdAt: z.date().prefault(()=>new Date())
});
function getAuditLogTable(options, auditLogFields) {
    const auditLogConfig = options.tables?.auditLog;
    const subjectConfig = options.tables?.subject;
    return {
        entityName: auditLogConfig?.entityName || 'auditLog',
        entityPrefix: auditLogConfig?.entityPrefix || 'log',
        schema: schema_auditLogSchema,
        fields: {
            entityType: {
                type: 'string',
                required: true,
                fieldName: auditLogConfig?.fields?.entityType || 'entityType'
            },
            entityId: {
                type: 'string',
                required: true,
                fieldName: auditLogConfig?.fields?.entityId || 'entityId'
            },
            actionType: {
                type: 'string',
                required: true,
                fieldName: auditLogConfig?.fields?.actionType || 'actionType'
            },
            subjectId: {
                type: 'string',
                required: false,
                fieldName: auditLogConfig?.fields?.subjectId || 'subjectId',
                references: {
                    model: subjectConfig?.entityName || 'subject',
                    field: 'id'
                }
            },
            ipAddress: {
                type: 'string',
                required: false,
                fieldName: auditLogConfig?.fields?.ipAddress || 'ipAddress'
            },
            userAgent: {
                type: 'string',
                required: false,
                fieldName: auditLogConfig?.fields?.userAgent || 'userAgent'
            },
            changes: {
                type: 'json',
                required: false,
                fieldName: auditLogConfig?.fields?.changes || 'changes'
            },
            metadata: {
                type: 'json',
                required: false,
                fieldName: auditLogConfig?.fields?.metadata || 'metadata'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: auditLogConfig?.fields?.createdAt || 'createdAt'
            },
            eventTimezone: {
                type: 'timezone',
                required: true,
                defaultValue: COMMON_TIMEZONES.UTC,
                fieldName: auditLogConfig?.fields?.eventTimezone || 'eventTimezone'
            },
            ...auditLogFields || {},
            ...auditLogConfig?.additionalFields || {}
        },
        indexes: [
            {
                name: 'entity_index',
                fields: [
                    'entityType',
                    'entityId'
                ]
            },
            {
                name: 'action_type_index',
                fields: [
                    'actionType'
                ]
            },
            {
                name: 'subject_id_index',
                fields: [
                    'subjectId'
                ]
            },
            {
                name: 'created_at_index',
                fields: [
                    'createdAt'
                ]
            }
        ],
        order: 5
    };
}
const schema_consentSchema = z.object({
    id: z.string(),
    subjectId: z.string(),
    domainId: z.string(),
    purposeIds: z.array(z.string()),
    metadata: z.record(z.string(), z.unknown()).nullable().optional(),
    policyId: z.string().optional(),
    ipAddress: z.string().nullable().optional(),
    userAgent: z.string().nullable().optional(),
    status: z["enum"]([
        'active',
        'withdrawn',
        'expired'
    ]).prefault('active'),
    withdrawalReason: z.string().nullable().optional(),
    givenAt: z.date().prefault(()=>new Date()),
    validUntil: z.date().nullable().optional(),
    isActive: z.boolean().prefault(true)
});
function getConsentTable(options, consentFields) {
    const consentConfig = options.tables?.consent;
    const subjectConfig = options.tables?.subject;
    const domainConfig = options.tables?.domain;
    const policyConfig = options.tables?.consentPolicy;
    return {
        entityName: consentConfig?.entityName || 'consent',
        entityPrefix: consentConfig?.entityPrefix || 'cns',
        schema: schema_consentSchema,
        fields: {
            subjectId: {
                type: 'string',
                required: true,
                fieldName: consentConfig?.fields?.subjectId || 'subjectId',
                references: {
                    model: subjectConfig?.entityName || 'subject',
                    field: 'id'
                }
            },
            domainId: {
                type: 'string',
                required: true,
                fieldName: consentConfig?.fields?.domainId || 'domainId',
                references: {
                    model: domainConfig?.entityName || 'domain',
                    field: 'id'
                }
            },
            purposeIds: {
                type: 'json',
                required: false,
                fieldName: consentConfig?.fields?.purposeIds || 'purposeIds'
            },
            metadata: {
                type: 'json',
                required: false,
                fieldName: consentConfig?.fields?.metadata || 'metadata'
            },
            policyId: {
                type: 'string',
                required: false,
                fieldName: consentConfig?.fields?.policyId || 'policyId',
                references: {
                    model: policyConfig?.entityName || 'consentPolicy',
                    field: 'id'
                }
            },
            ipAddress: {
                type: 'string',
                required: false,
                fieldName: consentConfig?.fields?.ipAddress || 'ipAddress'
            },
            userAgent: {
                type: 'string',
                required: false,
                fieldName: consentConfig?.fields?.userAgent || 'userAgent'
            },
            status: {
                type: 'string',
                defaultValue: ()=>'active',
                required: true,
                fieldName: consentConfig?.fields?.status || 'status'
            },
            withdrawalReason: {
                type: 'string',
                required: false,
                fieldName: consentConfig?.fields?.withdrawalReason || 'withdrawalReason'
            },
            givenAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: consentConfig?.fields?.givenAt || 'givenAt'
            },
            validUntil: {
                type: 'date',
                required: false,
                fieldName: consentConfig?.fields?.validUntil || 'validUntil',
                transform: {
                    input: (val, data)=>{
                        if (val) return val;
                        const expiresIn = consentConfig?.expiresIn || 31536000;
                        const givenAt = data.givenAt instanceof Date ? data.givenAt : new Date();
                        if (expiresIn > 0) {
                            const validUntil = new Date(givenAt);
                            validUntil.setSeconds(validUntil.getSeconds() + expiresIn);
                            return validUntil;
                        }
                    }
                }
            },
            isActive: {
                type: 'boolean',
                defaultValue: true,
                required: true,
                fieldName: consentConfig?.fields?.isActive || 'isActive'
            },
            ...consentFields || {},
            ...consentConfig?.additionalFields || {}
        },
        order: 3
    };
}
const PolicyTypeSchema = z["enum"]([
    'cookie_banner',
    'privacy_policy',
    'dpa',
    'terms_and_conditions',
    'marketing_communications',
    'age_verification',
    'other'
]);
const schema_consentPolicySchema = z.object({
    id: z.string(),
    version: z.string(),
    type: PolicyTypeSchema,
    name: z.string(),
    effectiveDate: z.date(),
    expirationDate: z.date().nullable().optional(),
    content: z.string(),
    contentHash: z.string(),
    isActive: z.boolean().prefault(true),
    createdAt: z.date().prefault(()=>new Date()),
    updatedAt: z.date().prefault(()=>new Date())
});
function getConsentPolicyTable(options, policyFields) {
    const consentPolicyConfig = options.tables?.consentPolicy;
    return {
        entityName: consentPolicyConfig?.entityName || 'consentPolicy',
        entityPrefix: consentPolicyConfig?.entityPrefix || 'pol',
        schema: schema_consentPolicySchema,
        fields: {
            version: {
                type: 'string',
                required: true,
                fieldName: consentPolicyConfig?.fields?.version || 'version'
            },
            type: {
                type: 'string',
                required: true,
                fieldName: consentPolicyConfig?.fields?.type || 'type'
            },
            name: {
                type: 'string',
                required: true,
                fieldName: consentPolicyConfig?.fields?.name || 'name'
            },
            effectiveDate: {
                type: 'date',
                required: true,
                fieldName: consentPolicyConfig?.fields?.effectiveDate || 'effectiveDate'
            },
            expirationDate: {
                type: 'date',
                required: false,
                fieldName: consentPolicyConfig?.fields?.expirationDate || 'expirationDate'
            },
            content: {
                type: 'string',
                required: true,
                fieldName: consentPolicyConfig?.fields?.content || 'content'
            },
            contentHash: {
                type: 'string',
                required: true,
                fieldName: consentPolicyConfig?.fields?.contentHash || 'contentHash'
            },
            isActive: {
                type: 'boolean',
                defaultValue: true,
                required: true,
                fieldName: consentPolicyConfig?.fields?.isActive || 'isActive'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: consentPolicyConfig?.fields?.createdAt || 'createdAt'
            },
            ...policyFields || {},
            ...consentPolicyConfig?.additionalFields || {}
        },
        order: 2
    };
}
const schema_purposeSchema = z.object({
    id: z.string(),
    code: z.string(),
    name: z.string(),
    description: z.string(),
    isEssential: z.boolean().prefault(false),
    dataCategory: z.string().nullish(),
    legalBasis: z.string().nullish(),
    isActive: z.boolean().prefault(true),
    createdAt: z.date().prefault(()=>new Date()),
    updatedAt: z.date().prefault(()=>new Date())
});
function getPurposeTable(options, purposeFields) {
    const purposeConfig = options.tables?.consentPurpose;
    return {
        entityName: purposeConfig?.entityName || 'consentPurpose',
        entityPrefix: purposeConfig?.entityPrefix || 'pur',
        schema: schema_purposeSchema,
        fields: {
            code: {
                type: 'string',
                required: true,
                fieldName: purposeConfig?.fields?.code || 'code'
            },
            name: {
                type: 'string',
                required: true,
                fieldName: purposeConfig?.fields?.name || 'name'
            },
            description: {
                type: 'string',
                required: true,
                fieldName: purposeConfig?.fields?.description || "description"
            },
            isEssential: {
                type: 'boolean',
                defaultValue: ()=>false,
                required: true,
                fieldName: purposeConfig?.fields?.isEssential || 'isEssential'
            },
            dataCategory: {
                type: 'string',
                required: false,
                fieldName: purposeConfig?.fields?.dataCategory || 'dataCategory'
            },
            legalBasis: {
                type: 'string',
                required: false,
                fieldName: purposeConfig?.fields?.legalBasis || 'legalBasis'
            },
            isActive: {
                type: 'boolean',
                defaultValue: true,
                required: true,
                fieldName: purposeConfig?.fields?.isActive || 'isActive'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: purposeConfig?.fields?.createdAt || 'createdAt'
            },
            updatedAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: purposeConfig?.fields?.updatedAt || 'updatedAt'
            },
            ...purposeFields || {},
            ...purposeConfig?.additionalFields || {}
        },
        order: 1
    };
}
const schema_consentRecordSchema = z.object({
    id: z.string(),
    subjectId: z.string(),
    consentId: z.string().optional(),
    actionType: z.string(),
    details: z.record(z.string(), z.unknown()).optional(),
    createdAt: z.date().prefault(()=>new Date()),
    updatedAt: z.date().prefault(()=>new Date())
});
function getConsentRecordTable(options, recordFields) {
    const recordConfig = options.tables?.record;
    const subjectConfig = options.tables?.subject;
    const consentConfig = options.tables?.consent;
    return {
        entityName: recordConfig?.entityName || 'consentRecord',
        entityPrefix: recordConfig?.entityPrefix || 'rec',
        schema: schema_consentRecordSchema,
        fields: {
            subjectId: {
                type: 'string',
                required: true,
                fieldName: recordConfig?.fields?.subjectId || 'subjectId',
                references: {
                    model: subjectConfig?.entityName || 'subject',
                    field: 'id'
                }
            },
            consentId: {
                type: 'string',
                required: false,
                fieldName: recordConfig?.fields?.consentId || 'consentId',
                references: {
                    model: consentConfig?.entityName || 'consent',
                    field: 'id'
                }
            },
            actionType: {
                type: 'string',
                required: true,
                fieldName: recordConfig?.fields?.actionType || 'actionType'
            },
            details: {
                type: 'json',
                required: false,
                fieldName: recordConfig?.fields?.details || 'details'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: recordConfig?.fields?.createdAt || 'createdAt'
            },
            ...recordFields || {},
            ...recordConfig?.additionalFields || {}
        },
        order: 4
    };
}
const schema_domainSchema = z.object({
    id: z.string(),
    name: z.string().min(1),
    description: z.string().optional(),
    allowedOrigins: z.array(z.string()).optional().prefault([]),
    isVerified: z.boolean().prefault(true),
    isActive: z.boolean().prefault(true),
    createdAt: z.date().prefault(()=>new Date()),
    updatedAt: z.date().prefault(()=>new Date())
});
function getDomainTable(options, domainFields) {
    const domainConfig = options.tables?.domain;
    return {
        entityName: domainConfig?.entityName || 'domain',
        entityPrefix: domainConfig?.entityPrefix || 'dom',
        schema: schema_domainSchema,
        fields: {
            name: {
                type: 'string',
                required: true,
                unique: true,
                fieldName: domainConfig?.fields?.name || 'name'
            },
            description: {
                type: 'string',
                required: false,
                fieldName: domainConfig?.fields?.description || "description"
            },
            allowedOrigins: {
                type: 'json',
                defaultValue: ()=>[],
                required: false,
                fieldName: domainConfig?.fields?.allowedOrigins || 'allowedOrigins'
            },
            isVerified: {
                type: 'boolean',
                defaultValue: true,
                required: true,
                fieldName: domainConfig?.fields?.isVerified || 'isVerified'
            },
            isActive: {
                type: 'boolean',
                defaultValue: true,
                required: true,
                fieldName: domainConfig?.fields?.isActive || 'isActive'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: domainConfig?.fields?.createdAt || 'createdAt'
            },
            updatedAt: {
                type: 'date',
                required: false,
                fieldName: domainConfig?.fields?.updatedAt || 'updatedAt'
            },
            ...domainFields || {},
            ...domainConfig?.additionalFields || {}
        },
        order: 1
    };
}
const schema_subjectSchema = z.object({
    id: z.string(),
    isIdentified: z.boolean().prefault(false),
    externalId: z.string().nullable().optional(),
    identityProvider: z.string().optional(),
    lastIpAddress: z.string().optional(),
    createdAt: z.date().prefault(()=>new Date()),
    updatedAt: z.date().prefault(()=>new Date())
});
function getSubjectTable(options, subjectFields) {
    const subjectConfig = options.tables?.subject;
    return {
        entityName: subjectConfig?.entityName || 'subject',
        entityPrefix: subjectConfig?.entityPrefix || 'sub',
        schema: schema_subjectSchema,
        fields: {
            isIdentified: {
                type: 'boolean',
                defaultValue: ()=>false,
                required: true,
                fieldName: subjectConfig?.fields?.isIdentified || 'isIdentified'
            },
            externalId: {
                type: 'string',
                required: false,
                fieldName: subjectConfig?.fields?.externalId || 'externalId'
            },
            identityProvider: {
                type: 'string',
                required: false,
                fieldName: subjectConfig?.fields?.identityProvider || 'identityProvider'
            },
            lastIpAddress: {
                type: 'string',
                required: false,
                fieldName: subjectConfig?.fields?.lastIpAddress || 'lastIpAddress'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: subjectConfig?.fields?.createdAt || 'createdAt'
            },
            updatedAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: subjectConfig?.fields?.updatedAt || 'updatedAt'
            },
            subjectTimezone: {
                type: 'timezone',
                required: false,
                defaultValue: COMMON_TIMEZONES.UTC,
                fieldName: subjectConfig?.fields?.subjectTimezone || 'subjectTimezone'
            },
            ...subjectFields || {},
            ...subjectConfig?.additionalFields || {}
        },
        order: 1
    };
}
const definition_getConsentTables = (options)=>{
    const pluginSchema = options.plugins?.reduce((acc, plugin)=>{
        const schema = plugin.schema;
        if (!schema) return acc;
        for (const [key, value] of Object.entries(schema))acc[key] = {
            fields: {
                ...acc[key]?.fields,
                ...value.fields
            },
            entityName: key
        };
        return acc;
    }, {});
    const { subject, consentPurpose, consentPolicy, domain, geoLocation, consent, consentPurposeJunction, record, consentGeoLocation, consentWithdrawal, auditLog, ...pluginTables } = pluginSchema || {};
    return {
        subject: getSubjectTable(options, subject?.fields),
        consentPurpose: getPurposeTable(options, consentPurpose?.fields),
        consentPolicy: getConsentPolicyTable(options, consentPolicy?.fields),
        domain: getDomainTable(options, domain?.fields),
        consent: getConsentTable(options, consent?.fields),
        consentRecord: getConsentRecordTable(options, record?.fields),
        auditLog: getAuditLogTable(options, auditLog?.fields),
        ...pluginTables
    };
};
function dialect_getDatabaseType(db) {
    if (!db) return null;
    if ('dialect' in db) return dialect_getDatabaseType(db.dialect);
    if (db && 'object' == typeof db && 'createDriver' in db) {
        if (db instanceof SqliteDialect) return 'sqlite';
        if (db instanceof MysqlDialect) return 'mysql';
        if (db instanceof PostgresDialect) return 'postgres';
        if (db instanceof MssqlDialect) return 'mssql';
    }
    if (db && 'object' == typeof db && 'aggregate' in db) return 'sqlite';
    if (db && 'object' == typeof db && 'getConnection' in db) return 'mysql';
    if (db && 'object' == typeof db && 'connect' in db) return 'postgres';
    return null;
}
const dialect_createKyselyAdapter = async (config)=>{
    const db = config.database;
    if (!db) return {
        kysely: null,
        databaseType: null
    };
    if (db && 'object' == typeof db && 'db' in db) {
        const kyselyConfig = db;
        return {
            kysely: kyselyConfig.db,
            databaseType: kyselyConfig.type
        };
    }
    if (db && 'object' == typeof db && 'dialect' in db) {
        const dialectConfig = db;
        return {
            kysely: new Kysely({
                dialect: dialectConfig.dialect
            }),
            databaseType: dialectConfig.type
        };
    }
    let dialect;
    const databaseType = dialect_getDatabaseType(db);
    if (db && 'object' == typeof db && 'createDriver' in db) dialect = db;
    if (db && 'object' == typeof db && 'aggregate' in db) dialect = new SqliteDialect({
        database: db
    });
    if (db && 'object' == typeof db && 'getConnection' in db) dialect = new MysqlDialect({
        pool: db
    });
    if (db && 'object' == typeof db && 'connect' in db) dialect = new PostgresDialect({
        pool: db
    });
    return {
        kysely: dialect ? new Kysely({
            dialect
        }) : null,
        databaseType
    };
};
const postgresMap = {
    string: [
        'character varying',
        'text'
    ],
    number: [
        'int4',
        'integer',
        'bigint',
        'smallint',
        'numeric',
        'real',
        'double precision'
    ],
    boolean: [
        'bool',
        'boolean'
    ],
    date: [
        'timestamp',
        'date'
    ],
    json: [
        'json',
        'jsonb'
    ],
    timezone: [
        'text',
        'character varying'
    ]
};
const mysqlMap = {
    string: [
        'varchar(255)',
        'varchar(36)',
        'text'
    ],
    number: [
        'integer',
        'int',
        'bigint',
        'smallint',
        'decimal',
        'float',
        'double'
    ],
    boolean: [
        'boolean',
        'tinyint'
    ],
    date: [
        'timestamp',
        'datetime',
        'date'
    ],
    json: [
        'json'
    ],
    timezone: [
        'varchar(50)'
    ]
};
const sqliteMap = {
    string: [
        'TEXT'
    ],
    number: [
        'INTEGER',
        'REAL'
    ],
    boolean: [
        'INTEGER',
        'BOOLEAN'
    ],
    date: [
        'DATE',
        'INTEGER'
    ],
    json: [
        'TEXT'
    ],
    timezone: [
        'TEXT'
    ]
};
const mssqlMap = {
    string: [
        'text',
        'varchar'
    ],
    number: [
        'int',
        'bigint',
        'smallint',
        'decimal',
        'float(53)',
        'float(24)'
    ],
    boolean: [
        'bit',
        'smallint'
    ],
    date: [
        'datetime',
        'date'
    ],
    json: [
        'nvarchar(max)'
    ],
    timezone: [
        'varchar',
        'text'
    ]
};
const map = {
    postgres: postgresMap,
    mysql: mysqlMap,
    sqlite: sqliteMap,
    mssql: mssqlMap
};
function getMySqlStringType(field) {
    if (field.unique) return 'varchar(255)';
    if (field.references) return 'varchar(36)';
    return 'text';
}
function matchType(columnDataType, fieldType, dbType) {
    if ('string[]' === fieldType || 'number[]' === fieldType) return columnDataType.toLowerCase().includes('json');
    const types = map[dbType];
    const type = Array.isArray(fieldType) ? types.string.map((t)=>t.toLowerCase()) : types[fieldType].map((t)=>t.toLowerCase());
    const matches = type.includes(columnDataType.toLowerCase());
    return matches;
}
function getType(field, dbType = 'sqlite') {
    const type = field.type;
    const typeMap = {
        string: {
            sqlite: 'text',
            postgres: 'text',
            mysql: getMySqlStringType(field),
            mssql: getMySqlStringType(field)
        },
        boolean: {
            sqlite: 'integer',
            postgres: 'boolean',
            mysql: 'boolean',
            mssql: 'smallint'
        },
        number: {
            sqlite: field.bigint ? 'bigint' : 'integer',
            postgres: field.bigint ? 'bigint' : 'integer',
            mysql: field.bigint ? 'bigint' : 'integer',
            mssql: field.bigint ? 'bigint' : 'integer'
        },
        date: {
            sqlite: 'date',
            postgres: 'timestamp',
            mysql: 'datetime',
            mssql: 'datetime'
        },
        timezone: {
            sqlite: 'text',
            postgres: 'text',
            mysql: 'varchar(50)',
            mssql: 'nvarchar(50)'
        },
        json: {
            sqlite: 'text',
            postgres: 'jsonb',
            mysql: 'json',
            mssql: 'nvarchar(max)'
        }
    };
    if ('sqlite' === dbType && ('string[]' === type || 'number[]' === type)) return 'text';
    if ('string[]' === type || 'number[]' === type) switch(dbType){
        case 'postgres':
            return 'jsonb';
        case 'mysql':
        case 'mssql':
            return 'json';
        default:
            return 'text';
    }
    if ('json' === type) return typeMap.json[dbType];
    return typeMap[type][dbType];
}
function buildColumnAddMigrations(db, toBeAdded, dbType) {
    const migrations = [];
    for (const table of toBeAdded)for (const [fieldName, field] of Object.entries(table.fields)){
        const type = getType(field, dbType);
        const exec = db.schema.alterTable(table.table).addColumn(fieldName, type, (col)=>{
            let column = false !== field.required ? col.notNull() : col;
            if (field.references) column = column.references(`${field.references.model}.${field.references.field}`);
            if (field.unique) column = column.unique();
            return column;
        });
        migrations.push(exec);
    }
    return migrations;
}
function buildTableCreateMigrations(db, toBeCreated, dbType) {
    const logger = logger_getLogger();
    const migrations = [];
    for (const table of toBeCreated){
        const fieldNames = Object.keys(table.fields);
        logger.info(`Creating table ${table.table} with fields: ${fieldNames.join(', ')}`);
        if (fieldNames.includes('id')) logger.warn(`⚠️ Table ${table.table} already has an explicit 'id' field, which may conflict with the auto-generated primary key`);
        for (const [fieldName, field] of Object.entries(table.fields))if ('id' === field.fieldName && 'id' !== fieldName) logger.error(`❌ ERROR: Table ${table.table} has field '${fieldName}' with fieldName 'id' - this will cause a duplicate column error`);
        let dbT = db.schema.createTable(table.table).addColumn('id', 'mysql' === dbType || 'mssql' === dbType ? 'varchar(36)' : 'text', (col)=>col.primaryKey().notNull());
        for (const [fieldName, field] of Object.entries(table.fields)){
            const type = getType(field, dbType);
            logger.info(`Adding column ${fieldName} (fieldName: ${field.fieldName || fieldName}) to table ${table.table}`);
            dbT = dbT.addColumn(fieldName, type, (col)=>{
                let column = false !== field.required ? col.notNull() : col;
                if (field.references) column = column.references(`${field.references.model}.${field.references.field}`);
                if (field.unique) column = column.unique();
                return column;
            });
        }
        const sqlDebug = dbT.compile().sql;
        logger.info(`SQL for table ${table.table}:\n${sqlDebug}`);
        migrations.push(dbT);
    }
    return migrations;
}
function createMigrationExecutors(migrations) {
    const logger = logger_getLogger();
    async function runMigrations() {
        for (const migration of migrations)try {
            await migration.execute();
        } catch (error) {
            const sql = migration.compile().sql;
            logger.error(`Migration failed! SQL:\n${sql}`);
            throw error;
        }
    }
    async function compileMigrations() {
        const compiled = migrations.map((m)=>m.compile().sql);
        return `${compiled.join(';\n\n')};`;
    }
    return {
        runMigrations,
        compileMigrations
    };
}
function processFields(fields, tables) {
    const actualFields = {};
    for (const [fieldKey, field] of Object.entries(fields)){
        if (!field) continue;
        const fieldName = field.fieldName || fieldKey;
        const typedField = field;
        actualFields[fieldName] = typedField;
        if (typedField && 'references' in typedField && typedField.references) {
            const EntityName = typedField.references.model;
            const refTable = tables[EntityName];
            if (refTable) actualFields[fieldName] = {
                ...typedField,
                references: {
                    model: refTable.entityName,
                    entity: refTable.entityName,
                    field: typedField.references.field,
                    onDelete: typedField.references.onDelete
                }
            };
            else {
                console.warn(`Warning: Referenced table '${EntityName}' not found for field '${fieldName}'. The reference will be removed to prevent inconsistent state.`);
                const { references, ...fieldWithoutRef } = typedField;
                actualFields[fieldName] = fieldWithoutRef;
            }
        }
    }
    return actualFields;
}
function processTablesIntoSchema(tables) {
    const schema = {};
    for (const [key, table] of Object.entries(tables)){
        if (!table) continue;
        let actualFields;
        try {
            const fields = table.fields;
            if ('object' != typeof fields || null === fields) {
                console.warn(`Invalid fields for table ${key}: Expected object, got ${typeof fields}`);
                continue;
            }
            actualFields = processFields(fields, tables);
        } catch (error) {
            console.error(`Error processing fields for table ${key}:`, error);
            continue;
        }
        const EntityName = table.entityName || key;
        if (schema[EntityName]) schema[EntityName] = {
            ...schema[EntityName],
            fields: {
                ...schema[EntityName]?.fields,
                ...actualFields
            }
        };
        else schema[EntityName] = {
            fields: actualFields,
            order: table.order || 1 / 0
        };
    }
    return schema;
}
function get_schema_getSchema(config) {
    try {
        const tables = definition_getConsentTables(config);
        return processTablesIntoSchema(tables);
    } catch (error) {
        console.error('Failed to generate schema:', error);
        throw new Error(`Schema generation failed: ${error instanceof Error ? error.message : String(error)}`);
    }
}
function analyzeSchemaChanges(config, tableMetadata, dbType) {
    const betterAuthSchema = get_schema_getSchema(config);
    const logger = logger_getLogger(config.logger);
    const toBeCreated = [];
    const toBeAdded = [];
    for (const [key, value] of Object.entries(betterAuthSchema)){
        const table = tableMetadata.find((t)=>t.name === key);
        if (!table) {
            handleNewTable(key, value, toBeCreated);
            continue;
        }
        handleExistingTable(key, value, table, toBeAdded, dbType, logger);
    }
    return {
        toBeCreated,
        toBeAdded
    };
}
function handleNewTable(tableName, value, toBeCreated) {
    const tIndex = toBeCreated.findIndex((t)=>t.table === tableName);
    const tableData = {
        table: tableName,
        fields: value.fields,
        order: value.order || 1 / 0
    };
    const insertIndex = toBeCreated.findIndex((t)=>(t.order || 1 / 0) > tableData.order);
    if (-1 === insertIndex) if (-1 === tIndex) toBeCreated.push(tableData);
    else {
        const existingTable = toBeCreated[tIndex];
        if (existingTable) existingTable.fields = {
            ...existingTable.fields,
            ...value.fields
        };
    }
    else toBeCreated.splice(insertIndex, 0, tableData);
}
function handleExistingTable(tableName, value, table, toBeAdded, dbType, logger) {
    const toBeAddedFields = {};
    for (const [fieldName, field] of Object.entries(value.fields)){
        const column = table.columns.find((c)=>c.name === fieldName);
        const typedField = field;
        if (!column) {
            toBeAddedFields[fieldName] = typedField;
            continue;
        }
        if (!matchType(column.dataType, typedField.type, dbType)) logger.warn(`Field ${fieldName} in table ${tableName} has a different type in the database. Expected ${typedField.type} but got ${column.dataType}.`);
    }
    if (Object.keys(toBeAddedFields).length > 0) toBeAdded.push({
        table: tableName,
        fields: toBeAddedFields,
        order: value.order || 1 / 0
    });
}
async function getMigrations(config) {
    const logger = logger_getLogger(config.logger);
    let { kysely: db, databaseType: dbType } = await dialect_createKyselyAdapter(config);
    if (!dbType) {
        logger.warn('Could not determine database type, defaulting to sqlite. Please provide a type in the database options to avoid this.');
        dbType = 'sqlite';
    }
    if (!db) {
        logger.error("Only kysely adapter is supported for migrations. You can use `generate` command to generate the schema, if you're using a different adapter.");
        process.exit(1);
    }
    const tableMetadata = await db.introspection.getTables();
    const { toBeCreated, toBeAdded } = analyzeSchemaChanges(config, tableMetadata, dbType);
    const columnMigrations = buildColumnAddMigrations(db, toBeAdded, dbType);
    const tableMigrations = buildTableCreateMigrations(db, toBeCreated, dbType);
    const migrations = [
        ...columnMigrations,
        ...tableMigrations
    ];
    const { runMigrations, compileMigrations } = createMigrationExecutors(migrations);
    return {
        toBeCreated,
        toBeAdded,
        runMigrations,
        compileMigrations
    };
}
export { analyzeSchemaChanges, buildColumnAddMigrations, buildTableCreateMigrations, createMigrationExecutors, getMigrations, get_schema_getSchema as getSchema, getType, matchType };
