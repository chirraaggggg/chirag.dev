import { Result, ResultAsync, err, errAsync, fromPromise, ok, okAsync } from "neverthrow";
import { ORPCError } from "@orpc/server";
import { SpanStatusCode, trace } from "@opentelemetry/api";
const ERROR_CODES = Object.freeze({
    NOT_FOUND: 'Resource not found',
    BAD_REQUEST: 'Bad request',
    CONFLICT: 'Conflict with current state',
    MISSING_REQUIRED_PARAMETER: 'Missing required parameter',
    UNAUTHORIZED: 'Unauthorized',
    FORBIDDEN: 'Forbidden',
    INTERNAL_SERVER_ERROR: 'Internal server error',
    INITIALIZATION_FAILED: 'Initialization failed',
    DATABASE_CONNECTION_ERROR: 'Database connection error',
    DATABASE_QUERY_ERROR: 'Database query error',
    INVALID_CONFIGURATION: 'Invalid configuration',
    REQUEST_HANDLER_ERROR: 'Request handler error',
    INVALID_REQUEST: 'Invalid request',
    UNKNOWN_ERROR: 'Unknown error',
    NETWORK_ERROR: 'Network error',
    PLUGIN_INITIALIZATION_FAILED: 'Plugin initialization failed',
    API_RETRIEVAL_ERROR: 'API retrieval error',
    VALIDATION_ERROR: 'Validation error',
    UNEXPECTED: 'Unexpected error'
});
const ERROR_CATEGORIES = Object.freeze({
    VALIDATION: 'validation',
    AUTHORIZATION: 'authorization',
    STORAGE: 'storage',
    NETWORK: 'network',
    PLUGIN: 'plugin',
    CONFIGURATION: 'configuration',
    UNEXPECTED: 'unexpected'
});
const tracer = trace.getTracer('@doubletie/results');
async function withSpan(name, fn, attributes = {}) {
    return await tracer.startActiveSpan(name, async (span)=>{
        try {
            span.setAttributes(attributes);
            const result = await fn(span);
            span.setStatus({
                code: SpanStatusCode.OK
            });
            span.end();
            return result;
        } catch (error) {
            if (error instanceof DoubleTieError) {
                span.setAttributes({
                    'error.type': 'DoubleTieError',
                    'error.code': error.code,
                    'error.statusCode': error.statusCode,
                    'error.message': error.message
                });
                if (error.meta) span.setAttributes({
                    'error.meta': JSON.stringify(error.meta)
                });
            } else span.setAttributes({
                'error.type': error instanceof Error ? error.constructor.name : 'Unknown',
                'error.message': error instanceof Error ? error.message : String(error)
            });
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: error instanceof Error ? error.message : String(error)
            });
            span.end();
            throw error;
        }
    });
}
class DoubleTieError extends ORPCError {
    category;
    meta;
    statusCode;
    constructor(message, options = {
        code: ERROR_CODES.UNKNOWN_ERROR,
        status: 500,
        category: ERROR_CATEGORIES.UNEXPECTED,
        cause: void 0,
        meta: {}
    }){
        super(options.code ?? ERROR_CODES.UNKNOWN_ERROR, {
            message,
            cause: options.cause,
            data: options.meta ?? {}
        });
        this.name = 'DoubleTieError';
        this.category = options.category ?? ERROR_CATEGORIES.UNEXPECTED;
        this.meta = options.meta ?? {};
        this.statusCode = options.status ?? 500;
        withSpan('create_doubletie_error', async (span)=>{
            span.setAttributes({
                'error.name': this.constructor.name,
                'error.message': message,
                'error.code': this.code,
                'error.status': this.statusCode,
                'error.category': this.category,
                'error.has_cause': !!this.cause,
                'error.cause_type': this.cause instanceof Error ? this.cause.constructor.name : typeof this.cause,
                'error.has_meta': !!this.meta
            });
            if (this.cause instanceof Error) span.recordException(this.cause);
        });
        if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
    }
    static isDoubleTieError(error) {
        return error instanceof DoubleTieError;
    }
    toJSON() {
        const validationErrorMessage = this.meta?.validationErrors ? String(this.meta.validationErrors) : void 0;
        const stackTrace = this.stack ? this.stack.split('\n').map((line)=>line.trim()).filter((line)=>line && !line.includes('Error: ')) : [];
        return {
            code: this.code,
            message: validationErrorMessage || this.message,
            status: this.statusCode,
            defined: true,
            data: {
                category: this.category,
                meta: this.meta,
                ...'production' === process.env.NODE_ENV ? {} : {
                    stack: stackTrace
                },
                ...validationErrorMessage && this.message ? {
                    originalMessage: this.message
                } : {},
                ...this.cause ? {
                    cause: this.cause instanceof Error ? {
                        name: this.cause.name,
                        message: this.cause.message,
                        stack: this.cause.stack ? this.cause.stack.split('\n').map((line)=>line.trim()) : void 0
                    } : this.cause
                } : {}
            }
        };
    }
    static fromResponse(response, data) {
        let message = `HTTP error ${response.status}`;
        let errorCode = `HTTP ${response.status}`;
        let errorMeta = {};
        if (data && 'object' == typeof data && null !== data) {
            const errorObj = data;
            if ('string' == typeof errorObj.message) message = errorObj.message;
            if ('string' == typeof errorObj.code) errorCode = errorObj.code;
            if ('object' == typeof errorObj.data && null !== errorObj.data) errorMeta = errorObj.data;
        }
        return new DoubleTieError(message, {
            code: errorCode,
            status: response.status,
            meta: errorMeta
        });
    }
    withMeta(additionalMeta) {
        return new DoubleTieError(this.message, {
            code: this.code,
            status: this.statusCode,
            category: this.category,
            cause: this.cause instanceof Error ? this.cause : void 0,
            meta: {
                ...this.meta,
                ...additionalMeta
            }
        });
    }
    static createSubclass(name) {
        const ErrorSubclass = class extends DoubleTieError {
            constructor(message, options){
                super(message, options);
                Object.defineProperty(this, 'name', {
                    value: name
                });
            }
        };
        Object.defineProperty(ErrorSubclass, 'name', {
            value: name
        });
        return ErrorSubclass;
    }
    static formatValidationError(error) {
        if (!error.meta) return error.message;
        let formattedMessage = `${error.message} (${error.code})`;
        if (error.meta.validationErrors) formattedMessage += `\nValidation Errors: ${JSON.stringify(error.meta.validationErrors, null, 2)}`;
        const otherMeta = Object.fromEntries(Object.entries(error.meta).filter(([key])=>'validationErrors' !== key));
        if (Object.keys(otherMeta).length > 0) formattedMessage += `\nAdditional Context: ${JSON.stringify(otherMeta, null, 2)}`;
        return formattedMessage;
    }
}
function createTelemetryOptions(appName = 'c15t', telemetryConfig) {
    const serviceVersion = process.env.npm_package_version || '1.0.0';
    const config = {
        disabled: telemetryConfig?.disabled ?? false,
        tracer: telemetryConfig?.tracer,
        defaultAttributes: {
            ...telemetryConfig?.defaultAttributes || {},
            'service.name': String(appName),
            'service.version': serviceVersion
        }
    };
    return config;
}
const withFallbackForCodes = (result, errorCodes, defaultValue)=>{
    withSpan('recovery_with_fallback_codes', async (span)=>{
        span.setAttributes({
            'recovery.type': 'error_codes',
            'recovery.codes': errorCodes.join(','),
            'result.is_error': result.isErr()
        });
    });
    return result.orElse((error)=>{
        if (error.code && errorCodes.includes(error.code)) {
            withSpan('recovery_with_fallback_codes', async (span)=>{
                span.setAttributes({
                    'recovery.matched': true,
                    'recovery.error_code': error.code
                });
            });
            return ok(defaultValue);
        }
        withSpan('recovery_with_fallback_codes', async (span)=>{
            span.setAttributes({
                'recovery.matched': false,
                'recovery.error_code': error.code
            });
        });
        return err(error);
    });
};
const withFallbackForCategory = (result, category, defaultValue)=>{
    withSpan('recovery_with_fallback_category', async (span)=>{
        span.setAttributes({
            'recovery.type': 'error_category',
            'recovery.category': category,
            'result.is_error': result.isErr()
        });
    });
    return result.orElse((error)=>{
        if (error.category === category) {
            withSpan('recovery_with_fallback_category', async (span)=>{
                span.setAttributes({
                    'recovery.matched': true,
                    'recovery.error_category': error.category
                });
            });
            return ok(defaultValue);
        }
        withSpan('recovery_with_fallback_category', async (span)=>{
            span.setAttributes({
                'recovery.matched': false,
                'recovery.error_category': error.category
            });
        });
        return err(error);
    });
};
function fail(message, options) {
    const error = new DoubleTieError(message, options);
    withSpan('create_error_result', async (span)=>{
        span.setAttributes({
            'error.message': message,
            'error.code': options?.code,
            'error.status': options?.status,
            'error.category': options?.category
        });
    });
    return err(error);
}
function failAsync(message, options) {
    const error = new DoubleTieError(message, options);
    withSpan('create_error_result_async', async (span)=>{
        span.setAttributes({
            'error.message': message,
            'error.code': options?.code,
            'error.status': options?.status,
            'error.category': options?.category
        });
    });
    return errAsync(error);
}
function tryCatch(fn, errorCode = ERROR_CODES.UNKNOWN_ERROR, errorMapper) {
    try {
        const result = fn();
        withSpan('try_catch', async (span)=>{
            span.setAttributes({
                'operation.success': true,
                'result.type': typeof result
            });
        });
        return ok(result);
    } catch (error) {
        withSpan('try_catch', async (span)=>{
            span.setAttributes({
                'operation.success': false,
                'error.type': error instanceof Error ? error.constructor.name : 'Unknown',
                'error.message': error instanceof Error ? error.message : String(error)
            });
        });
        if (errorMapper && error instanceof Error) {
            const mappedError = errorMapper(error);
            withSpan('try_catch', async (span)=>{
                span.setAttributes({
                    'error.mapped': true,
                    'error.mapped_code': mappedError.code
                });
            });
            return err(mappedError);
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        return err(new DoubleTieError(errorMessage, {
            code: errorCode,
            cause: error instanceof Error ? error : void 0
        }));
    }
}
function tryCatchAsync(fn, errorCode = ERROR_CODES.UNKNOWN_ERROR, errorMapper) {
    return ResultAsync.fromPromise((async ()=>{
        try {
            const result = await fn();
            withSpan('try_catch_async', async (span)=>{
                span.setAttributes({
                    'operation.success': true,
                    'result.type': typeof result
                });
            });
            return result;
        } catch (error) {
            withSpan('try_catch_async', async (span)=>{
                span.setAttributes({
                    'operation.success': false,
                    'error.type': error instanceof Error ? error.constructor.name : 'Unknown',
                    'error.message': error instanceof Error ? error.message : String(error)
                });
            });
            if (errorMapper && error instanceof Error) {
                const mappedError = errorMapper(error);
                withSpan('try_catch_async', async (span)=>{
                    span.setAttributes({
                        'error.mapped': true,
                        'error.mapped_code': mappedError.code
                    });
                });
                throw mappedError;
            }
            const errorMessage = error instanceof Error ? error.message : String(error);
            throw new DoubleTieError(errorMessage, {
                code: errorCode,
                cause: error instanceof Error ? error : void 0
            });
        }
    })(), (error)=>error instanceof DoubleTieError ? error : new DoubleTieError(String(error), {
            code: errorCode,
            cause: error instanceof Error ? error : void 0
        }));
}
function promiseToResult(promise, errorCode = ERROR_CODES.UNKNOWN_ERROR) {
    return ResultAsync.fromPromise(promise, (error)=>{
        withSpan('promise_to_result', async (span)=>{
            span.setAttributes({
                'operation.success': false,
                'error.type': error instanceof Error ? error.constructor.name : 'Unknown',
                'error.message': error instanceof Error ? error.message : String(error)
            });
        });
        return new DoubleTieError(error instanceof Error ? error.message : String(error), {
            code: errorCode,
            cause: error instanceof Error ? error : void 0,
            meta: {
                error
            }
        });
    }).map((result)=>{
        withSpan('promise_to_result', async (span)=>{
            span.setAttributes({
                'operation.success': true,
                'result.type': typeof result
            });
        });
        return result;
    });
}
export { DoubleTieError, ERROR_CATEGORIES, ERROR_CODES, Result, ResultAsync, createTelemetryOptions, err, errAsync, fail, failAsync, fromPromise, ok, okAsync, promiseToResult, tryCatch, tryCatchAsync, withFallbackForCategory, withFallbackForCodes };
