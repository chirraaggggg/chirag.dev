"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    ResultAsync: ()=>external_neverthrow_namespaceObject.ResultAsync,
    ERROR_CODES: ()=>ERROR_CODES,
    promiseToResult: ()=>promiseToResult,
    failAsync: ()=>failAsync,
    withFallbackForCodes: ()=>withFallbackForCodes,
    err: ()=>external_neverthrow_namespaceObject.err,
    tryCatchAsync: ()=>tryCatchAsync,
    tryCatch: ()=>tryCatch,
    okAsync: ()=>external_neverthrow_namespaceObject.okAsync,
    errAsync: ()=>external_neverthrow_namespaceObject.errAsync,
    fromPromise: ()=>external_neverthrow_namespaceObject.fromPromise,
    DoubleTieError: ()=>DoubleTieError,
    ERROR_CATEGORIES: ()=>ERROR_CATEGORIES,
    createTelemetryOptions: ()=>createTelemetryOptions,
    fail: ()=>fail,
    ok: ()=>external_neverthrow_namespaceObject.ok,
    withFallbackForCategory: ()=>withFallbackForCategory,
    Result: ()=>external_neverthrow_namespaceObject.Result
});
const external_neverthrow_namespaceObject = require("neverthrow");
const server_namespaceObject = require("@orpc/server");
const ERROR_CODES = Object.freeze({
    NOT_FOUND: 'Resource not found',
    BAD_REQUEST: 'Bad request',
    CONFLICT: 'Conflict with current state',
    MISSING_REQUIRED_PARAMETER: 'Missing required parameter',
    UNAUTHORIZED: 'Unauthorized',
    FORBIDDEN: 'Forbidden',
    INTERNAL_SERVER_ERROR: 'Internal server error',
    INITIALIZATION_FAILED: 'Initialization failed',
    DATABASE_CONNECTION_ERROR: 'Database connection error',
    DATABASE_QUERY_ERROR: 'Database query error',
    INVALID_CONFIGURATION: 'Invalid configuration',
    REQUEST_HANDLER_ERROR: 'Request handler error',
    INVALID_REQUEST: 'Invalid request',
    UNKNOWN_ERROR: 'Unknown error',
    NETWORK_ERROR: 'Network error',
    PLUGIN_INITIALIZATION_FAILED: 'Plugin initialization failed',
    API_RETRIEVAL_ERROR: 'API retrieval error',
    VALIDATION_ERROR: 'Validation error',
    UNEXPECTED: 'Unexpected error'
});
const ERROR_CATEGORIES = Object.freeze({
    VALIDATION: 'validation',
    AUTHORIZATION: 'authorization',
    STORAGE: 'storage',
    NETWORK: 'network',
    PLUGIN: 'plugin',
    CONFIGURATION: 'configuration',
    UNEXPECTED: 'unexpected'
});
const api_namespaceObject = require("@opentelemetry/api");
const tracer = api_namespaceObject.trace.getTracer('@doubletie/results');
async function withSpan(name, fn, attributes = {}) {
    return await tracer.startActiveSpan(name, async (span)=>{
        try {
            span.setAttributes(attributes);
            const result = await fn(span);
            span.setStatus({
                code: api_namespaceObject.SpanStatusCode.OK
            });
            span.end();
            return result;
        } catch (error) {
            if (error instanceof DoubleTieError) {
                span.setAttributes({
                    'error.type': 'DoubleTieError',
                    'error.code': error.code,
                    'error.statusCode': error.statusCode,
                    'error.message': error.message
                });
                if (error.meta) span.setAttributes({
                    'error.meta': JSON.stringify(error.meta)
                });
            } else span.setAttributes({
                'error.type': error instanceof Error ? error.constructor.name : 'Unknown',
                'error.message': error instanceof Error ? error.message : String(error)
            });
            span.setStatus({
                code: api_namespaceObject.SpanStatusCode.ERROR,
                message: error instanceof Error ? error.message : String(error)
            });
            span.end();
            throw error;
        }
    });
}
class DoubleTieError extends server_namespaceObject.ORPCError {
    category;
    meta;
    statusCode;
    constructor(message, options = {
        code: ERROR_CODES.UNKNOWN_ERROR,
        status: 500,
        category: ERROR_CATEGORIES.UNEXPECTED,
        cause: void 0,
        meta: {}
    }){
        super(options.code ?? ERROR_CODES.UNKNOWN_ERROR, {
            message,
            cause: options.cause,
            data: options.meta ?? {}
        });
        this.name = 'DoubleTieError';
        this.category = options.category ?? ERROR_CATEGORIES.UNEXPECTED;
        this.meta = options.meta ?? {};
        this.statusCode = options.status ?? 500;
        withSpan('create_doubletie_error', async (span)=>{
            span.setAttributes({
                'error.name': this.constructor.name,
                'error.message': message,
                'error.code': this.code,
                'error.status': this.statusCode,
                'error.category': this.category,
                'error.has_cause': !!this.cause,
                'error.cause_type': this.cause instanceof Error ? this.cause.constructor.name : typeof this.cause,
                'error.has_meta': !!this.meta
            });
            if (this.cause instanceof Error) span.recordException(this.cause);
        });
        if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
    }
    static isDoubleTieError(error) {
        return error instanceof DoubleTieError;
    }
    toJSON() {
        const validationErrorMessage = this.meta?.validationErrors ? String(this.meta.validationErrors) : void 0;
        const stackTrace = this.stack ? this.stack.split('\n').map((line)=>line.trim()).filter((line)=>line && !line.includes('Error: ')) : [];
        return {
            code: this.code,
            message: validationErrorMessage || this.message,
            status: this.statusCode,
            defined: true,
            data: {
                category: this.category,
                meta: this.meta,
                ...'production' === process.env.NODE_ENV ? {} : {
                    stack: stackTrace
                },
                ...validationErrorMessage && this.message ? {
                    originalMessage: this.message
                } : {},
                ...this.cause ? {
                    cause: this.cause instanceof Error ? {
                        name: this.cause.name,
                        message: this.cause.message,
                        stack: this.cause.stack ? this.cause.stack.split('\n').map((line)=>line.trim()) : void 0
                    } : this.cause
                } : {}
            }
        };
    }
    static fromResponse(response, data) {
        let message = `HTTP error ${response.status}`;
        let errorCode = `HTTP ${response.status}`;
        let errorMeta = {};
        if (data && 'object' == typeof data && null !== data) {
            const errorObj = data;
            if ('string' == typeof errorObj.message) message = errorObj.message;
            if ('string' == typeof errorObj.code) errorCode = errorObj.code;
            if ('object' == typeof errorObj.data && null !== errorObj.data) errorMeta = errorObj.data;
        }
        return new DoubleTieError(message, {
            code: errorCode,
            status: response.status,
            meta: errorMeta
        });
    }
    withMeta(additionalMeta) {
        return new DoubleTieError(this.message, {
            code: this.code,
            status: this.statusCode,
            category: this.category,
            cause: this.cause instanceof Error ? this.cause : void 0,
            meta: {
                ...this.meta,
                ...additionalMeta
            }
        });
    }
    static createSubclass(name) {
        const ErrorSubclass = class extends DoubleTieError {
            constructor(message, options){
                super(message, options);
                Object.defineProperty(this, 'name', {
                    value: name
                });
            }
        };
        Object.defineProperty(ErrorSubclass, 'name', {
            value: name
        });
        return ErrorSubclass;
    }
    static formatValidationError(error) {
        if (!error.meta) return error.message;
        let formattedMessage = `${error.message} (${error.code})`;
        if (error.meta.validationErrors) formattedMessage += `\nValidation Errors: ${JSON.stringify(error.meta.validationErrors, null, 2)}`;
        const otherMeta = Object.fromEntries(Object.entries(error.meta).filter(([key])=>'validationErrors' !== key));
        if (Object.keys(otherMeta).length > 0) formattedMessage += `\nAdditional Context: ${JSON.stringify(otherMeta, null, 2)}`;
        return formattedMessage;
    }
}
function createTelemetryOptions(appName = 'c15t', telemetryConfig) {
    const serviceVersion = process.env.npm_package_version || '1.0.0';
    const config = {
        disabled: telemetryConfig?.disabled ?? false,
        tracer: telemetryConfig?.tracer,
        defaultAttributes: {
            ...telemetryConfig?.defaultAttributes || {},
            'service.name': String(appName),
            'service.version': serviceVersion
        }
    };
    return config;
}
const withFallbackForCodes = (result, errorCodes, defaultValue)=>{
    withSpan('recovery_with_fallback_codes', async (span)=>{
        span.setAttributes({
            'recovery.type': 'error_codes',
            'recovery.codes': errorCodes.join(','),
            'result.is_error': result.isErr()
        });
    });
    return result.orElse((error)=>{
        if (error.code && errorCodes.includes(error.code)) {
            withSpan('recovery_with_fallback_codes', async (span)=>{
                span.setAttributes({
                    'recovery.matched': true,
                    'recovery.error_code': error.code
                });
            });
            return (0, external_neverthrow_namespaceObject.ok)(defaultValue);
        }
        withSpan('recovery_with_fallback_codes', async (span)=>{
            span.setAttributes({
                'recovery.matched': false,
                'recovery.error_code': error.code
            });
        });
        return (0, external_neverthrow_namespaceObject.err)(error);
    });
};
const withFallbackForCategory = (result, category, defaultValue)=>{
    withSpan('recovery_with_fallback_category', async (span)=>{
        span.setAttributes({
            'recovery.type': 'error_category',
            'recovery.category': category,
            'result.is_error': result.isErr()
        });
    });
    return result.orElse((error)=>{
        if (error.category === category) {
            withSpan('recovery_with_fallback_category', async (span)=>{
                span.setAttributes({
                    'recovery.matched': true,
                    'recovery.error_category': error.category
                });
            });
            return (0, external_neverthrow_namespaceObject.ok)(defaultValue);
        }
        withSpan('recovery_with_fallback_category', async (span)=>{
            span.setAttributes({
                'recovery.matched': false,
                'recovery.error_category': error.category
            });
        });
        return (0, external_neverthrow_namespaceObject.err)(error);
    });
};
function fail(message, options) {
    const error = new DoubleTieError(message, options);
    withSpan('create_error_result', async (span)=>{
        span.setAttributes({
            'error.message': message,
            'error.code': options?.code,
            'error.status': options?.status,
            'error.category': options?.category
        });
    });
    return (0, external_neverthrow_namespaceObject.err)(error);
}
function failAsync(message, options) {
    const error = new DoubleTieError(message, options);
    withSpan('create_error_result_async', async (span)=>{
        span.setAttributes({
            'error.message': message,
            'error.code': options?.code,
            'error.status': options?.status,
            'error.category': options?.category
        });
    });
    return (0, external_neverthrow_namespaceObject.errAsync)(error);
}
function tryCatch(fn, errorCode = ERROR_CODES.UNKNOWN_ERROR, errorMapper) {
    try {
        const result = fn();
        withSpan('try_catch', async (span)=>{
            span.setAttributes({
                'operation.success': true,
                'result.type': typeof result
            });
        });
        return (0, external_neverthrow_namespaceObject.ok)(result);
    } catch (error) {
        withSpan('try_catch', async (span)=>{
            span.setAttributes({
                'operation.success': false,
                'error.type': error instanceof Error ? error.constructor.name : 'Unknown',
                'error.message': error instanceof Error ? error.message : String(error)
            });
        });
        if (errorMapper && error instanceof Error) {
            const mappedError = errorMapper(error);
            withSpan('try_catch', async (span)=>{
                span.setAttributes({
                    'error.mapped': true,
                    'error.mapped_code': mappedError.code
                });
            });
            return (0, external_neverthrow_namespaceObject.err)(mappedError);
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        return (0, external_neverthrow_namespaceObject.err)(new DoubleTieError(errorMessage, {
            code: errorCode,
            cause: error instanceof Error ? error : void 0
        }));
    }
}
function tryCatchAsync(fn, errorCode = ERROR_CODES.UNKNOWN_ERROR, errorMapper) {
    return external_neverthrow_namespaceObject.ResultAsync.fromPromise((async ()=>{
        try {
            const result = await fn();
            withSpan('try_catch_async', async (span)=>{
                span.setAttributes({
                    'operation.success': true,
                    'result.type': typeof result
                });
            });
            return result;
        } catch (error) {
            withSpan('try_catch_async', async (span)=>{
                span.setAttributes({
                    'operation.success': false,
                    'error.type': error instanceof Error ? error.constructor.name : 'Unknown',
                    'error.message': error instanceof Error ? error.message : String(error)
                });
            });
            if (errorMapper && error instanceof Error) {
                const mappedError = errorMapper(error);
                withSpan('try_catch_async', async (span)=>{
                    span.setAttributes({
                        'error.mapped': true,
                        'error.mapped_code': mappedError.code
                    });
                });
                throw mappedError;
            }
            const errorMessage = error instanceof Error ? error.message : String(error);
            throw new DoubleTieError(errorMessage, {
                code: errorCode,
                cause: error instanceof Error ? error : void 0
            });
        }
    })(), (error)=>error instanceof DoubleTieError ? error : new DoubleTieError(String(error), {
            code: errorCode,
            cause: error instanceof Error ? error : void 0
        }));
}
function promiseToResult(promise, errorCode = ERROR_CODES.UNKNOWN_ERROR) {
    return external_neverthrow_namespaceObject.ResultAsync.fromPromise(promise, (error)=>{
        withSpan('promise_to_result', async (span)=>{
            span.setAttributes({
                'operation.success': false,
                'error.type': error instanceof Error ? error.constructor.name : 'Unknown',
                'error.message': error instanceof Error ? error.message : String(error)
            });
        });
        return new DoubleTieError(error instanceof Error ? error.message : String(error), {
            code: errorCode,
            cause: error instanceof Error ? error : void 0,
            meta: {
                error
            }
        });
    }).map((result)=>{
        withSpan('promise_to_result', async (span)=>{
            span.setAttributes({
                'operation.success': true,
                'result.type': typeof result
            });
        });
        return result;
    });
}
exports.DoubleTieError = __webpack_exports__.DoubleTieError;
exports.ERROR_CATEGORIES = __webpack_exports__.ERROR_CATEGORIES;
exports.ERROR_CODES = __webpack_exports__.ERROR_CODES;
exports.Result = __webpack_exports__.Result;
exports.ResultAsync = __webpack_exports__.ResultAsync;
exports.createTelemetryOptions = __webpack_exports__.createTelemetryOptions;
exports.err = __webpack_exports__.err;
exports.errAsync = __webpack_exports__.errAsync;
exports.fail = __webpack_exports__.fail;
exports.failAsync = __webpack_exports__.failAsync;
exports.fromPromise = __webpack_exports__.fromPromise;
exports.ok = __webpack_exports__.ok;
exports.okAsync = __webpack_exports__.okAsync;
exports.promiseToResult = __webpack_exports__.promiseToResult;
exports.tryCatch = __webpack_exports__.tryCatch;
exports.tryCatchAsync = __webpack_exports__.tryCatchAsync;
exports.withFallbackForCategory = __webpack_exports__.withFallbackForCategory;
exports.withFallbackForCodes = __webpack_exports__.withFallbackForCodes;
for(var __webpack_i__ in __webpack_exports__)if (-1 === [
    "DoubleTieError",
    "ERROR_CATEGORIES",
    "ERROR_CODES",
    "Result",
    "ResultAsync",
    "createTelemetryOptions",
    "err",
    "errAsync",
    "fail",
    "failAsync",
    "fromPromise",
    "ok",
    "okAsync",
    "promiseToResult",
    "tryCatch",
    "tryCatchAsync",
    "withFallbackForCategory",
    "withFallbackForCodes"
].indexOf(__webpack_i__)) exports[__webpack_i__] = __webpack_exports__[__webpack_i__];
Object.defineProperty(exports, '__esModule', {
    value: true
});
