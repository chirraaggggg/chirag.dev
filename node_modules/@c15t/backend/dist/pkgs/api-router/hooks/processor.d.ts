import type { HookEndpointContext } from '../../types';
import type { DoubleTieMiddleware } from '../../types/options';
/**
 * Executes before hooks on the request context
 *
 * Runs through all matching hooks in sequence, accumulating and applying
 * context modifications.
 *
 * @param context - The endpoint context to pass to hooks
 * @param hooks - Array of hook definitions with matchers and handlers
 * @returns Modified context or hook response
 * @throws Will propagate any errors thrown by hook handlers that aren't caught internally
 *
 * @example
 * ```typescript
 * // Process before hooks for a request
 * const beforeResult = await runBeforeHooks(context, [
 *   {
 *     matcher: ctx => ctx.path.startsWith('/users'),
 *     handler: authMiddleware
 *   },
 *   {
 *     matcher: ctx => ctx.method === 'GET',
 *     handler: cacheMiddleware
 *   }
 * ]);
 *
 * // Check if we should continue with normal processing
 * if ('context' in beforeResult) {
 *   // Apply context modifications and continue
 *   Object.assign(context, beforeResult.context);
 * } else {
 *   // Short-circuit with the hook response
 *   return beforeResult;
 * }
 * ```
 */
export declare function runBeforeHooks(context: HookEndpointContext, hooks: {
    matcher: (context: HookEndpointContext) => boolean;
    handler: DoubleTieMiddleware;
}[]): Promise<object>;
/**
 * Executes after hooks on the response context
 *
 * Runs through all matching hooks in sequence after the endpoint handler has completed,
 * allowing post-processing of responses.
 *
 * @param context - The endpoint context to pass to hooks
 * @param hooks - Array of hook definitions with matchers and handlers
 * @returns An object potentially containing a modified response
 * @throws Will propagate any errors thrown by hook handlers that aren't caught internally
 *
 * @example
 * ```typescript
 * // Process after hooks for a response
 * const afterResult = await runAfterHooks(context, [
 *   {
 *     matcher: ctx => true, // Run for all responses
 *     handler: loggingMiddleware
 *   },
 *   {
 *     matcher: ctx => ctx.method === 'GET',
 *     handler: cachingMiddleware
 *   }
 * ]);
 *
 * // Apply any response modifications from hooks
 * if (afterResult.response) {
 *   response = afterResult.response;
 * }
 *
 * // Apply any header modifications from hooks
 * if (afterResult.headers) {
 *   afterResult.headers.forEach((value, key) => {
 *     responseHeaders.set(key, value);
 *   });
 * }
 * ```
 */
export declare function runAfterHooks(context: HookEndpointContext, hooks: {
    matcher: (context: HookEndpointContext) => boolean;
    handler: DoubleTieMiddleware;
}[]): Promise<{
    response: unknown;
    headers: Headers | null;
}>;
//# sourceMappingURL=processor.d.ts.map