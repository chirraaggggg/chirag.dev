import { createLogger, logger as logger_logger } from "@c15t/logger";
import { OpenAPIHandler } from "@orpc/openapi/fetch";
import { CORSPlugin } from "@orpc/server/plugins";
import defu_0, { defu } from "defu";
import { ResultAsync as external_neverthrow_ResultAsync, err as external_neverthrow_err, errAsync, ok as external_neverthrow_ok } from "neverthrow";
import { ORPCError, implement } from "@orpc/server";
import { SpanStatusCode, trace } from "@opentelemetry/api";
import { resourceFromAttributes } from "@opentelemetry/resources";
import { NodeSDK } from "@opentelemetry/sdk-node";
import { ConsoleSpanExporter } from "@opentelemetry/sdk-trace-base";
import base_x from "base-x";
import { ZodError, z } from "zod";
import { Kysely, MssqlDialect, MysqlDialect, PostgresDialect, SqliteDialect } from "kysely";
import superjson from "superjson";
import "drizzle-orm";
import { OpenAPIGenerator } from "@orpc/openapi";
import { ZodToJsonSchemaConverter } from "@orpc/zod";
import { oc } from "@orpc/contract";
import { baseTranslations, deepMergeTranslations } from "@c15t/translations";
const error_codes_ERROR_CODES = Object.freeze({
    NOT_FOUND: 'Resource not found',
    BAD_REQUEST: 'Bad request',
    CONFLICT: 'Conflict with current state',
    MISSING_REQUIRED_PARAMETER: 'Missing required parameter',
    UNAUTHORIZED: 'Unauthorized',
    FORBIDDEN: 'Forbidden',
    INTERNAL_SERVER_ERROR: 'Internal server error',
    INITIALIZATION_FAILED: 'Initialization failed',
    DATABASE_CONNECTION_ERROR: 'Database connection error',
    DATABASE_QUERY_ERROR: 'Database query error',
    INVALID_CONFIGURATION: 'Invalid configuration',
    REQUEST_HANDLER_ERROR: 'Request handler error',
    INVALID_REQUEST: 'Invalid request',
    UNKNOWN_ERROR: 'Unknown error',
    NETWORK_ERROR: 'Network error',
    PLUGIN_INITIALIZATION_FAILED: 'Plugin initialization failed',
    API_RETRIEVAL_ERROR: 'API retrieval error',
    VALIDATION_ERROR: 'Validation error',
    UNEXPECTED: 'Unexpected error'
});
const ERROR_CATEGORIES = Object.freeze({
    VALIDATION: 'validation',
    AUTHORIZATION: 'authorization',
    STORAGE: 'storage',
    NETWORK: 'network',
    PLUGIN: 'plugin',
    CONFIGURATION: 'configuration',
    UNEXPECTED: 'unexpected'
});
const tracing_tracer = trace.getTracer('@doubletie/results');
async function tracing_withSpan(name, fn, attributes = {}) {
    return await tracing_tracer.startActiveSpan(name, async (span)=>{
        try {
            span.setAttributes(attributes);
            const result = await fn(span);
            span.setStatus({
                code: SpanStatusCode.OK
            });
            span.end();
            return result;
        } catch (error) {
            if (error instanceof error_class_DoubleTieError) {
                span.setAttributes({
                    'error.type': 'DoubleTieError',
                    'error.code': error.code,
                    'error.statusCode': error.statusCode,
                    'error.message': error.message
                });
                if (error.meta) span.setAttributes({
                    'error.meta': JSON.stringify(error.meta)
                });
            } else span.setAttributes({
                'error.type': error instanceof Error ? error.constructor.name : 'Unknown',
                'error.message': error instanceof Error ? error.message : String(error)
            });
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: error instanceof Error ? error.message : String(error)
            });
            span.end();
            throw error;
        }
    });
}
class error_class_DoubleTieError extends ORPCError {
    category;
    meta;
    statusCode;
    constructor(message, options = {
        code: error_codes_ERROR_CODES.UNKNOWN_ERROR,
        status: 500,
        category: ERROR_CATEGORIES.UNEXPECTED,
        cause: void 0,
        meta: {}
    }){
        super(options.code ?? error_codes_ERROR_CODES.UNKNOWN_ERROR, {
            message,
            cause: options.cause,
            data: options.meta ?? {}
        });
        this.name = 'DoubleTieError';
        this.category = options.category ?? ERROR_CATEGORIES.UNEXPECTED;
        this.meta = options.meta ?? {};
        this.statusCode = options.status ?? 500;
        tracing_withSpan('create_doubletie_error', async (span)=>{
            span.setAttributes({
                'error.name': this.constructor.name,
                'error.message': message,
                'error.code': this.code,
                'error.status': this.statusCode,
                'error.category': this.category,
                'error.has_cause': !!this.cause,
                'error.cause_type': this.cause instanceof Error ? this.cause.constructor.name : typeof this.cause,
                'error.has_meta': !!this.meta
            });
            if (this.cause instanceof Error) span.recordException(this.cause);
        });
        if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
    }
    static isDoubleTieError(error) {
        return error instanceof error_class_DoubleTieError;
    }
    toJSON() {
        const validationErrorMessage = this.meta?.validationErrors ? String(this.meta.validationErrors) : void 0;
        const stackTrace = this.stack ? this.stack.split('\n').map((line)=>line.trim()).filter((line)=>line && !line.includes('Error: ')) : [];
        return {
            code: this.code,
            message: validationErrorMessage || this.message,
            status: this.statusCode,
            defined: true,
            data: {
                category: this.category,
                meta: this.meta,
                ...'production' === process.env.NODE_ENV ? {} : {
                    stack: stackTrace
                },
                ...validationErrorMessage && this.message ? {
                    originalMessage: this.message
                } : {},
                ...this.cause ? {
                    cause: this.cause instanceof Error ? {
                        name: this.cause.name,
                        message: this.cause.message,
                        stack: this.cause.stack ? this.cause.stack.split('\n').map((line)=>line.trim()) : void 0
                    } : this.cause
                } : {}
            }
        };
    }
    static fromResponse(response, data) {
        let message = `HTTP error ${response.status}`;
        let errorCode = `HTTP ${response.status}`;
        let errorMeta = {};
        if (data && 'object' == typeof data && null !== data) {
            const errorObj = data;
            if ('string' == typeof errorObj.message) message = errorObj.message;
            if ('string' == typeof errorObj.code) errorCode = errorObj.code;
            if ('object' == typeof errorObj.data && null !== errorObj.data) errorMeta = errorObj.data;
        }
        return new error_class_DoubleTieError(message, {
            code: errorCode,
            status: response.status,
            meta: errorMeta
        });
    }
    withMeta(additionalMeta) {
        return new error_class_DoubleTieError(this.message, {
            code: this.code,
            status: this.statusCode,
            category: this.category,
            cause: this.cause instanceof Error ? this.cause : void 0,
            meta: {
                ...this.meta,
                ...additionalMeta
            }
        });
    }
    static createSubclass(name) {
        const ErrorSubclass = class extends error_class_DoubleTieError {
            constructor(message, options){
                super(message, options);
                Object.defineProperty(this, 'name', {
                    value: name
                });
            }
        };
        Object.defineProperty(ErrorSubclass, 'name', {
            value: name
        });
        return ErrorSubclass;
    }
    static formatValidationError(error) {
        if (!error.meta) return error.message;
        let formattedMessage = `${error.message} (${error.code})`;
        if (error.meta.validationErrors) formattedMessage += `\nValidation Errors: ${JSON.stringify(error.meta.validationErrors, null, 2)}`;
        const otherMeta = Object.fromEntries(Object.entries(error.meta).filter(([key])=>'validationErrors' !== key));
        if (Object.keys(otherMeta).length > 0) formattedMessage += `\nAdditional Context: ${JSON.stringify(otherMeta, null, 2)}`;
        return formattedMessage;
    }
}
function createTelemetryOptions(appName = 'c15t', telemetryConfig) {
    const serviceVersion = process.env.npm_package_version || '1.0.0';
    const config = {
        disabled: telemetryConfig?.disabled ?? false,
        tracer: telemetryConfig?.tracer,
        defaultAttributes: {
            ...telemetryConfig?.defaultAttributes || {},
            'service.name': String(appName),
            'service.version': serviceVersion
        }
    };
    return config;
}
function fail(message, options) {
    const error = new error_class_DoubleTieError(message, options);
    tracing_withSpan('create_error_result', async (span)=>{
        span.setAttributes({
            'error.message': message,
            'error.code': options?.code,
            'error.status': options?.status,
            'error.category': options?.category
        });
    });
    return external_neverthrow_err(error);
}
function failAsync(message, options) {
    const error = new error_class_DoubleTieError(message, options);
    tracing_withSpan('create_error_result_async', async (span)=>{
        span.setAttributes({
            'error.message': message,
            'error.code': options?.code,
            'error.status': options?.status,
            'error.category': options?.category
        });
    });
    return errAsync(error);
}
function promiseToResult(promise, errorCode = error_codes_ERROR_CODES.UNKNOWN_ERROR) {
    return external_neverthrow_ResultAsync.fromPromise(promise, (error)=>{
        tracing_withSpan('promise_to_result', async (span)=>{
            span.setAttributes({
                'operation.success': false,
                'error.type': error instanceof Error ? error.constructor.name : 'Unknown',
                'error.message': error instanceof Error ? error.message : String(error)
            });
        });
        return new error_class_DoubleTieError(error instanceof Error ? error.message : String(error), {
            code: errorCode,
            cause: error instanceof Error ? error : void 0,
            meta: {
                error
            }
        });
    }).map((result)=>{
        tracing_withSpan('promise_to_result', async (span)=>{
            span.setAttributes({
                'operation.success': true,
                'result.type': typeof result
            });
        });
        return result;
    });
}
let globalLogger;
function getLogger(options) {
    if (!globalLogger) globalLogger = createLogger({
        level: 'info',
        appName: 'c15t',
        ...options
    });
    return globalLogger;
}
function initLogger(options) {
    globalLogger = createLogger(options);
    return globalLogger;
}
const COMMON_TIMEZONES = {
    UTC: 'UTC',
    GMT: 'GMT',
    EASTERN: 'America/New_York',
    CENTRAL: 'America/Chicago',
    MOUNTAIN: 'America/Denver',
    PACIFIC: 'America/Los_Angeles',
    LONDON: 'Europe/London',
    PARIS: 'Europe/Paris',
    BERLIN: 'Europe/Berlin',
    TOKYO: 'Asia/Tokyo',
    SHANGHAI: 'Asia/Shanghai',
    SINGAPORE: 'Asia/Singapore',
    SYDNEY: 'Australia/Sydney',
    SAO_PAULO: 'America/Sao_Paulo'
};
const b58 = base_x('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');
function id_generator_generateId(prefix) {
    const buf = crypto.getRandomValues(new Uint8Array(20));
    const EPOCH_TIMESTAMP = 1700000000000;
    const t = Date.now() - EPOCH_TIMESTAMP;
    const high = Math.floor(t / 0x100000000);
    const low = t >>> 0;
    buf[0] = high >>> 24 & 255;
    buf[1] = high >>> 16 & 255;
    buf[2] = high >>> 8 & 255;
    buf[3] = 255 & high;
    buf[4] = low >>> 24 & 255;
    buf[5] = low >>> 16 & 255;
    buf[6] = low >>> 8 & 255;
    buf[7] = 255 & low;
    return `${prefix}_${b58.encode(buf)}`;
}
const fieldConfigSchema = z.object({
    required: z.boolean().prefault(true),
    returned: z.boolean().prefault(true),
    input: z.boolean().prefault(true),
    defaultValue: z.any().optional(),
    transform: z.object({
        input: z.any().optional(),
        output: z.any().optional()
    }).optional(),
    validator: z.any().optional(),
    unique: z.boolean().optional(),
    indexed: z.boolean().optional(),
    sortable: z.boolean().prefault(true),
    fieldName: z.string().optional(),
    bigint: z.boolean().prefault(false)
});
const stringFieldSchema = fieldConfigSchema.extend({
    type: z.literal('string'),
    minLength: z.number().optional(),
    maxLength: z.number().optional(),
    pattern: z.string().optional()
});
const numberFieldSchema = fieldConfigSchema.extend({
    type: z.literal('number'),
    min: z.number().optional(),
    max: z.number().optional()
});
const booleanFieldSchema = fieldConfigSchema.extend({
    type: z.literal('boolean')
});
const dateFieldSchema = fieldConfigSchema.extend({
    type: z.literal('date'),
    minDate: z.date().optional(),
    maxDate: z.date().optional(),
    dateOnly: z.boolean().prefault(false),
    format: z.record(z.string(), z.unknown()).optional()
});
const timezoneFieldSchema = fieldConfigSchema.extend({
    type: z.literal('timezone'),
    validateTimezone: z.boolean().prefault(true),
    suggestedValues: z.array(z.string()).optional(),
    restrictToSuggestedValues: z.boolean().prefault(false)
});
const jsonFieldSchema = fieldConfigSchema.extend({
    type: z.literal('json'),
    validateJson: z.boolean().prefault(true)
});
const stringArrayFieldSchema = fieldConfigSchema.extend({
    type: z.literal('string[]')
});
const numberArrayFieldSchema = fieldConfigSchema.extend({
    type: z.literal('number[]')
});
z.discriminatedUnion('type', [
    stringFieldSchema,
    numberFieldSchema,
    booleanFieldSchema,
    dateFieldSchema,
    timezoneFieldSchema,
    jsonFieldSchema,
    stringArrayFieldSchema,
    numberArrayFieldSchema
]);
async function processHooks(data, model, operation, phase, hooks, context) {
    let currentData = {
        ...data
    };
    for (const hookSet of hooks){
        const modelHooks = hookSet[model];
        if (!modelHooks) continue;
        const operationHooks = modelHooks[operation];
        if (!operationHooks) continue;
        const hookFn = operationHooks[phase];
        if (hookFn) if ('before' === phase) {
            const result = await hookFn(currentData, context);
            if (result && 'object' == typeof result && 'kind' in result) switch(result.kind){
                case 'abort':
                    return null;
                case 'transform':
                    {
                        const transformData = result.data;
                        currentData = {
                            ...currentData,
                            ...transformData
                        };
                        break;
                    }
                default:
                    break;
            }
        } else await hookFn(currentData, context);
    }
    return currentData;
}
async function processAfterHooksForMany(records, model, hooks, context) {
    if (!records.length) return;
    for (const record of records)await processHooks(record, model, 'update', 'after', hooks, context);
}
async function create_hooks_createWithHooks(adapter, ctx, props) {
    const { data, model, customFn, context } = props;
    const hooks = ctx.hooks || [];
    const transformedData = await processHooks(data, model, 'create', 'before', hooks, context);
    if (null === transformedData) return null;
    let created = null;
    if (customFn) {
        created = await customFn.fn(transformedData);
        if (!customFn.executeMainFn && created) return created;
    }
    if (!created) created = await adapter.create({
        model: model,
        data: transformedData
    });
    if (created) await processHooks(created, model, 'create', 'after', hooks, context);
    return created;
}
async function update_hooks_updateWithHooks(adapter, ctx, props) {
    const { data, where, model, customFn, context } = props;
    const hooks = ctx.hooks || [];
    const transformedData = await processHooks(data, model, 'update', 'before', hooks, context);
    if (null === transformedData) return null;
    let updated = null;
    if (customFn) {
        const result = await customFn.fn(transformedData);
        updated = result;
        if (!customFn.executeMainFn && updated) return updated;
    }
    if (!updated) updated = await adapter.update({
        model: model,
        update: transformedData,
        where
    });
    if (updated) await processHooks(updated, model, 'update', 'after', hooks, context);
    return updated;
}
async function executeCustomFunction(data, customFn) {
    if (!customFn) return {
        result: null,
        shouldContinue: true
    };
    const result = await customFn.fn(data);
    const shouldContinue = !result || !!customFn.executeMainFn;
    return {
        result,
        shouldContinue
    };
}
function processUpdateManyResult(result) {
    if (Array.isArray(result)) return result;
    if ('number' == typeof result && result > 0) return [];
    return null;
}
async function updateManyWithHooks(adapter, ctx, props) {
    const { data, where, model, customFn, context } = props;
    const hooks = ctx.hooks || [];
    const transformedData = await processHooks(data, model, 'update', 'before', hooks, context);
    if (null === transformedData) return null;
    const { result: customResult, shouldContinue } = await executeCustomFunction(transformedData, customFn);
    if (customResult && !shouldContinue) return customResult;
    let updated = customResult;
    if (!updated) {
        const adapterResult = await adapter.updateMany({
            model: model,
            update: transformedData,
            where
        });
        updated = processUpdateManyResult(adapterResult);
    }
    if (updated && updated.length > 0) await processAfterHooksForMany(updated, model, hooks, context);
    return updated;
}
function getWithHooks(adapter, ctx) {
    return {
        createWithHooks: ({ data, model, customFn, context })=>create_hooks_createWithHooks(adapter, ctx, {
                data,
                model,
                customFn,
                context
            }),
        updateWithHooks: (props)=>update_hooks_updateWithHooks(adapter, ctx, props),
        updateManyWithHooks: (props)=>updateManyWithHooks(adapter, ctx, props)
    };
}
const schema_auditLogSchema = z.object({
    id: z.string(),
    entityType: z.string(),
    entityId: z.string(),
    actionType: z.string(),
    subjectId: z.string().optional(),
    ipAddress: z.string().optional(),
    userAgent: z.string().optional(),
    changes: z.record(z.string(), z.unknown()).optional(),
    metadata: z.record(z.string(), z.unknown()).optional(),
    createdAt: z.date().prefault(()=>new Date())
});
function getAuditLogTable(options, auditLogFields) {
    const auditLogConfig = options.tables?.auditLog;
    const subjectConfig = options.tables?.subject;
    return {
        entityName: auditLogConfig?.entityName || 'auditLog',
        entityPrefix: auditLogConfig?.entityPrefix || 'log',
        schema: schema_auditLogSchema,
        fields: {
            entityType: {
                type: 'string',
                required: true,
                fieldName: auditLogConfig?.fields?.entityType || 'entityType'
            },
            entityId: {
                type: 'string',
                required: true,
                fieldName: auditLogConfig?.fields?.entityId || 'entityId'
            },
            actionType: {
                type: 'string',
                required: true,
                fieldName: auditLogConfig?.fields?.actionType || 'actionType'
            },
            subjectId: {
                type: 'string',
                required: false,
                fieldName: auditLogConfig?.fields?.subjectId || 'subjectId',
                references: {
                    model: subjectConfig?.entityName || 'subject',
                    field: 'id'
                }
            },
            ipAddress: {
                type: 'string',
                required: false,
                fieldName: auditLogConfig?.fields?.ipAddress || 'ipAddress'
            },
            userAgent: {
                type: 'string',
                required: false,
                fieldName: auditLogConfig?.fields?.userAgent || 'userAgent'
            },
            changes: {
                type: 'json',
                required: false,
                fieldName: auditLogConfig?.fields?.changes || 'changes'
            },
            metadata: {
                type: 'json',
                required: false,
                fieldName: auditLogConfig?.fields?.metadata || 'metadata'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: auditLogConfig?.fields?.createdAt || 'createdAt'
            },
            eventTimezone: {
                type: 'timezone',
                required: true,
                defaultValue: COMMON_TIMEZONES.UTC,
                fieldName: auditLogConfig?.fields?.eventTimezone || 'eventTimezone'
            },
            ...auditLogFields || {},
            ...auditLogConfig?.additionalFields || {}
        },
        indexes: [
            {
                name: 'entity_index',
                fields: [
                    'entityType',
                    'entityId'
                ]
            },
            {
                name: 'action_type_index',
                fields: [
                    'actionType'
                ]
            },
            {
                name: 'subject_id_index',
                fields: [
                    'subjectId'
                ]
            },
            {
                name: 'created_at_index',
                fields: [
                    'createdAt'
                ]
            }
        ],
        order: 5
    };
}
const schema_consentSchema = z.object({
    id: z.string(),
    subjectId: z.string(),
    domainId: z.string(),
    purposeIds: z.array(z.string()),
    metadata: z.record(z.string(), z.unknown()).nullable().optional(),
    policyId: z.string().optional(),
    ipAddress: z.string().nullable().optional(),
    userAgent: z.string().nullable().optional(),
    status: z["enum"]([
        'active',
        'withdrawn',
        'expired'
    ]).prefault('active'),
    withdrawalReason: z.string().nullable().optional(),
    givenAt: z.date().prefault(()=>new Date()),
    validUntil: z.date().nullable().optional(),
    isActive: z.boolean().prefault(true)
});
function getConsentTable(options, consentFields) {
    const consentConfig = options.tables?.consent;
    const subjectConfig = options.tables?.subject;
    const domainConfig = options.tables?.domain;
    const policyConfig = options.tables?.consentPolicy;
    return {
        entityName: consentConfig?.entityName || 'consent',
        entityPrefix: consentConfig?.entityPrefix || 'cns',
        schema: schema_consentSchema,
        fields: {
            subjectId: {
                type: 'string',
                required: true,
                fieldName: consentConfig?.fields?.subjectId || 'subjectId',
                references: {
                    model: subjectConfig?.entityName || 'subject',
                    field: 'id'
                }
            },
            domainId: {
                type: 'string',
                required: true,
                fieldName: consentConfig?.fields?.domainId || 'domainId',
                references: {
                    model: domainConfig?.entityName || 'domain',
                    field: 'id'
                }
            },
            purposeIds: {
                type: 'json',
                required: false,
                fieldName: consentConfig?.fields?.purposeIds || 'purposeIds'
            },
            metadata: {
                type: 'json',
                required: false,
                fieldName: consentConfig?.fields?.metadata || 'metadata'
            },
            policyId: {
                type: 'string',
                required: false,
                fieldName: consentConfig?.fields?.policyId || 'policyId',
                references: {
                    model: policyConfig?.entityName || 'consentPolicy',
                    field: 'id'
                }
            },
            ipAddress: {
                type: 'string',
                required: false,
                fieldName: consentConfig?.fields?.ipAddress || 'ipAddress'
            },
            userAgent: {
                type: 'string',
                required: false,
                fieldName: consentConfig?.fields?.userAgent || 'userAgent'
            },
            status: {
                type: 'string',
                defaultValue: ()=>'active',
                required: true,
                fieldName: consentConfig?.fields?.status || 'status'
            },
            withdrawalReason: {
                type: 'string',
                required: false,
                fieldName: consentConfig?.fields?.withdrawalReason || 'withdrawalReason'
            },
            givenAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: consentConfig?.fields?.givenAt || 'givenAt'
            },
            validUntil: {
                type: 'date',
                required: false,
                fieldName: consentConfig?.fields?.validUntil || 'validUntil',
                transform: {
                    input: (val, data)=>{
                        if (val) return val;
                        const expiresIn = consentConfig?.expiresIn || 31536000;
                        const givenAt = data.givenAt instanceof Date ? data.givenAt : new Date();
                        if (expiresIn > 0) {
                            const validUntil = new Date(givenAt);
                            validUntil.setSeconds(validUntil.getSeconds() + expiresIn);
                            return validUntil;
                        }
                    }
                }
            },
            isActive: {
                type: 'boolean',
                defaultValue: true,
                required: true,
                fieldName: consentConfig?.fields?.isActive || 'isActive'
            },
            ...consentFields || {},
            ...consentConfig?.additionalFields || {}
        },
        order: 3
    };
}
const PolicyTypeSchema = z["enum"]([
    'cookie_banner',
    'privacy_policy',
    'dpa',
    'terms_and_conditions',
    'marketing_communications',
    'age_verification',
    'other'
]);
const schema_consentPolicySchema = z.object({
    id: z.string(),
    version: z.string(),
    type: PolicyTypeSchema,
    name: z.string(),
    effectiveDate: z.date(),
    expirationDate: z.date().nullable().optional(),
    content: z.string(),
    contentHash: z.string(),
    isActive: z.boolean().prefault(true),
    createdAt: z.date().prefault(()=>new Date()),
    updatedAt: z.date().prefault(()=>new Date())
});
function getConsentPolicyTable(options, policyFields) {
    const consentPolicyConfig = options.tables?.consentPolicy;
    return {
        entityName: consentPolicyConfig?.entityName || 'consentPolicy',
        entityPrefix: consentPolicyConfig?.entityPrefix || 'pol',
        schema: schema_consentPolicySchema,
        fields: {
            version: {
                type: 'string',
                required: true,
                fieldName: consentPolicyConfig?.fields?.version || 'version'
            },
            type: {
                type: 'string',
                required: true,
                fieldName: consentPolicyConfig?.fields?.type || 'type'
            },
            name: {
                type: 'string',
                required: true,
                fieldName: consentPolicyConfig?.fields?.name || 'name'
            },
            effectiveDate: {
                type: 'date',
                required: true,
                fieldName: consentPolicyConfig?.fields?.effectiveDate || 'effectiveDate'
            },
            expirationDate: {
                type: 'date',
                required: false,
                fieldName: consentPolicyConfig?.fields?.expirationDate || 'expirationDate'
            },
            content: {
                type: 'string',
                required: true,
                fieldName: consentPolicyConfig?.fields?.content || 'content'
            },
            contentHash: {
                type: 'string',
                required: true,
                fieldName: consentPolicyConfig?.fields?.contentHash || 'contentHash'
            },
            isActive: {
                type: 'boolean',
                defaultValue: true,
                required: true,
                fieldName: consentPolicyConfig?.fields?.isActive || 'isActive'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: consentPolicyConfig?.fields?.createdAt || 'createdAt'
            },
            ...policyFields || {},
            ...consentPolicyConfig?.additionalFields || {}
        },
        order: 2
    };
}
const schema_purposeSchema = z.object({
    id: z.string(),
    code: z.string(),
    name: z.string(),
    description: z.string(),
    isEssential: z.boolean().prefault(false),
    dataCategory: z.string().nullish(),
    legalBasis: z.string().nullish(),
    isActive: z.boolean().prefault(true),
    createdAt: z.date().prefault(()=>new Date()),
    updatedAt: z.date().prefault(()=>new Date())
});
function getPurposeTable(options, purposeFields) {
    const purposeConfig = options.tables?.consentPurpose;
    return {
        entityName: purposeConfig?.entityName || 'consentPurpose',
        entityPrefix: purposeConfig?.entityPrefix || 'pur',
        schema: schema_purposeSchema,
        fields: {
            code: {
                type: 'string',
                required: true,
                fieldName: purposeConfig?.fields?.code || 'code'
            },
            name: {
                type: 'string',
                required: true,
                fieldName: purposeConfig?.fields?.name || 'name'
            },
            description: {
                type: 'string',
                required: true,
                fieldName: purposeConfig?.fields?.description || "description"
            },
            isEssential: {
                type: 'boolean',
                defaultValue: ()=>false,
                required: true,
                fieldName: purposeConfig?.fields?.isEssential || 'isEssential'
            },
            dataCategory: {
                type: 'string',
                required: false,
                fieldName: purposeConfig?.fields?.dataCategory || 'dataCategory'
            },
            legalBasis: {
                type: 'string',
                required: false,
                fieldName: purposeConfig?.fields?.legalBasis || 'legalBasis'
            },
            isActive: {
                type: 'boolean',
                defaultValue: true,
                required: true,
                fieldName: purposeConfig?.fields?.isActive || 'isActive'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: purposeConfig?.fields?.createdAt || 'createdAt'
            },
            updatedAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: purposeConfig?.fields?.updatedAt || 'updatedAt'
            },
            ...purposeFields || {},
            ...purposeConfig?.additionalFields || {}
        },
        order: 1
    };
}
const schema_consentRecordSchema = z.object({
    id: z.string(),
    subjectId: z.string(),
    consentId: z.string().optional(),
    actionType: z.string(),
    details: z.record(z.string(), z.unknown()).optional(),
    createdAt: z.date().prefault(()=>new Date()),
    updatedAt: z.date().prefault(()=>new Date())
});
function getConsentRecordTable(options, recordFields) {
    const recordConfig = options.tables?.record;
    const subjectConfig = options.tables?.subject;
    const consentConfig = options.tables?.consent;
    return {
        entityName: recordConfig?.entityName || 'consentRecord',
        entityPrefix: recordConfig?.entityPrefix || 'rec',
        schema: schema_consentRecordSchema,
        fields: {
            subjectId: {
                type: 'string',
                required: true,
                fieldName: recordConfig?.fields?.subjectId || 'subjectId',
                references: {
                    model: subjectConfig?.entityName || 'subject',
                    field: 'id'
                }
            },
            consentId: {
                type: 'string',
                required: false,
                fieldName: recordConfig?.fields?.consentId || 'consentId',
                references: {
                    model: consentConfig?.entityName || 'consent',
                    field: 'id'
                }
            },
            actionType: {
                type: 'string',
                required: true,
                fieldName: recordConfig?.fields?.actionType || 'actionType'
            },
            details: {
                type: 'json',
                required: false,
                fieldName: recordConfig?.fields?.details || 'details'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: recordConfig?.fields?.createdAt || 'createdAt'
            },
            ...recordFields || {},
            ...recordConfig?.additionalFields || {}
        },
        order: 4
    };
}
const schema_domainSchema = z.object({
    id: z.string(),
    name: z.string().min(1),
    description: z.string().optional(),
    allowedOrigins: z.array(z.string()).optional().prefault([]),
    isVerified: z.boolean().prefault(true),
    isActive: z.boolean().prefault(true),
    createdAt: z.date().prefault(()=>new Date()),
    updatedAt: z.date().prefault(()=>new Date())
});
function getDomainTable(options, domainFields) {
    const domainConfig = options.tables?.domain;
    return {
        entityName: domainConfig?.entityName || 'domain',
        entityPrefix: domainConfig?.entityPrefix || 'dom',
        schema: schema_domainSchema,
        fields: {
            name: {
                type: 'string',
                required: true,
                unique: true,
                fieldName: domainConfig?.fields?.name || 'name'
            },
            description: {
                type: 'string',
                required: false,
                fieldName: domainConfig?.fields?.description || "description"
            },
            allowedOrigins: {
                type: 'json',
                defaultValue: ()=>[],
                required: false,
                fieldName: domainConfig?.fields?.allowedOrigins || 'allowedOrigins'
            },
            isVerified: {
                type: 'boolean',
                defaultValue: true,
                required: true,
                fieldName: domainConfig?.fields?.isVerified || 'isVerified'
            },
            isActive: {
                type: 'boolean',
                defaultValue: true,
                required: true,
                fieldName: domainConfig?.fields?.isActive || 'isActive'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: domainConfig?.fields?.createdAt || 'createdAt'
            },
            updatedAt: {
                type: 'date',
                required: false,
                fieldName: domainConfig?.fields?.updatedAt || 'updatedAt'
            },
            ...domainFields || {},
            ...domainConfig?.additionalFields || {}
        },
        order: 1
    };
}
const schema_subjectSchema = z.object({
    id: z.string(),
    isIdentified: z.boolean().prefault(false),
    externalId: z.string().nullable().optional(),
    identityProvider: z.string().optional(),
    lastIpAddress: z.string().optional(),
    createdAt: z.date().prefault(()=>new Date()),
    updatedAt: z.date().prefault(()=>new Date())
});
function getSubjectTable(options, subjectFields) {
    const subjectConfig = options.tables?.subject;
    return {
        entityName: subjectConfig?.entityName || 'subject',
        entityPrefix: subjectConfig?.entityPrefix || 'sub',
        schema: schema_subjectSchema,
        fields: {
            isIdentified: {
                type: 'boolean',
                defaultValue: ()=>false,
                required: true,
                fieldName: subjectConfig?.fields?.isIdentified || 'isIdentified'
            },
            externalId: {
                type: 'string',
                required: false,
                fieldName: subjectConfig?.fields?.externalId || 'externalId'
            },
            identityProvider: {
                type: 'string',
                required: false,
                fieldName: subjectConfig?.fields?.identityProvider || 'identityProvider'
            },
            lastIpAddress: {
                type: 'string',
                required: false,
                fieldName: subjectConfig?.fields?.lastIpAddress || 'lastIpAddress'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: subjectConfig?.fields?.createdAt || 'createdAt'
            },
            updatedAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: subjectConfig?.fields?.updatedAt || 'updatedAt'
            },
            subjectTimezone: {
                type: 'timezone',
                required: false,
                defaultValue: COMMON_TIMEZONES.UTC,
                fieldName: subjectConfig?.fields?.subjectTimezone || 'subjectTimezone'
            },
            ...subjectFields || {},
            ...subjectConfig?.additionalFields || {}
        },
        order: 1
    };
}
const definition_getConsentTables = (options)=>{
    const pluginSchema = options.plugins?.reduce((acc, plugin)=>{
        const schema = plugin.schema;
        if (!schema) return acc;
        for (const [key, value] of Object.entries(schema))acc[key] = {
            fields: {
                ...acc[key]?.fields,
                ...value.fields
            },
            entityName: key
        };
        return acc;
    }, {});
    const { subject, consentPurpose, consentPolicy, domain, geoLocation, consent, consentPurposeJunction, record, consentGeoLocation, consentWithdrawal, auditLog, ...pluginTables } = pluginSchema || {};
    return {
        subject: getSubjectTable(options, subject?.fields),
        consentPurpose: getPurposeTable(options, consentPurpose?.fields),
        consentPolicy: getConsentPolicyTable(options, consentPolicy?.fields),
        domain: getDomainTable(options, domain?.fields),
        consent: getConsentTable(options, consent?.fields),
        consentRecord: getConsentRecordTable(options, record?.fields),
        auditLog: getAuditLogTable(options, auditLog?.fields),
        ...pluginTables
    };
};
function validateEntityOutput(tableName, data, options) {
    const tables = definition_getConsentTables(options);
    const table = tables[tableName];
    if (!table) throw new Error(`Table ${tableName} not found`);
    const processedData = {
        ...data
    };
    for (const [field, def] of Object.entries(table.fields))if ('date' === def.type && 'string' == typeof processedData[field]) processedData[field] = new Date(processedData[field]);
    try {
        return table.schema.parse(processedData);
    } catch (error) {
        if (error instanceof ZodError) logger_logger.error(`[validateEntityOutput] Validation failed for table ${String(tableName)}`, {
            table,
            issues: error.issues
        });
        throw error;
    }
}
function consentRegistry({ adapter, ...ctx }) {
    const { createWithHooks, updateWithHooks } = getWithHooks(adapter, ctx);
    const registry = {
        createConsent: async (consent, context)=>{
            const createdConsent = await createWithHooks({
                data: {
                    createdAt: new Date(),
                    ...consent
                },
                model: 'consent',
                context
            });
            if (!createdConsent) throw new error_class_DoubleTieError('Failed to create consent - operation returned null', {
                code: error_codes_ERROR_CODES.INTERNAL_SERVER_ERROR,
                status: 500
            });
            return createdConsent;
        },
        updateConsent: async (consentId, data, context)=>{
            const consent = await updateWithHooks({
                data: {
                    ...data
                },
                where: [
                    {
                        field: 'id',
                        value: consentId
                    }
                ],
                model: 'consent',
                context
            });
            return consent ? validateEntityOutput('consent', consent, ctx.options) : null;
        }
    };
    return registry;
}
async function generatePolicyPlaceholder(name, date) {
    const content = `[PLACEHOLDER] This is an automatically generated version of the ${name} policy.\n\nThis placeholder content should be replaced with actual policy terms before being presented to users.\n\nGenerated on: ${date.toISOString()}`;
    let contentHash;
    try {
        const encoder = new TextEncoder();
        const data = encoder.encode(content);
        const hashBuffer = await crypto.subtle.digest('SHA-256', data);
        contentHash = Array.from(new Uint8Array(hashBuffer)).map((b)=>b.toString(16).padStart(2, '0')).join('');
    } catch (error) {
        throw new error_class_DoubleTieError('Failed to generate policy content hash', {
            code: error_codes_ERROR_CODES.INTERNAL_SERVER_ERROR,
            status: 500,
            cause: error instanceof Error ? error : new Error(String(error))
        });
    }
    return {
        content,
        contentHash
    };
}
function policyRegistry({ adapter, ...ctx }) {
    const { createWithHooks } = getWithHooks(adapter, ctx);
    const registry = {
        createConsentPolicy: async (policy, context)=>{
            const createdPolicy = await createWithHooks({
                data: {
                    createdAt: new Date(),
                    ...policy
                },
                model: 'consentPolicy',
                context
            });
            if (!createdPolicy) throw new error_class_DoubleTieError('Failed to create consent policy - operation returned null', {
                code: error_codes_ERROR_CODES.INTERNAL_SERVER_ERROR,
                status: 500
            });
            return createdPolicy;
        },
        findPolicies: async (params = {})=>{
            const whereConditions = [];
            if (!params.includeInactive) whereConditions.push({
                field: 'isActive',
                value: true
            });
            if (params.domainId) whereConditions.push({
                field: 'id',
                value: params.domainId
            });
            if (params.version) whereConditions.push({
                field: 'version',
                value: params.version
            });
            const policies = await adapter.findMany({
                model: 'consentPolicy',
                where: whereConditions,
                sortBy: {
                    field: 'effectiveDate',
                    direction: 'desc'
                }
            });
            return policies.map((policy)=>validateEntityOutput('consentPolicy', policy, ctx.options));
        },
        findConsentPolicyById: async (policyId)=>{
            const policy = await adapter.findOne({
                model: 'consentPolicy',
                where: [
                    {
                        field: 'id',
                        value: policyId
                    }
                ]
            });
            return policy ? validateEntityOutput('consentPolicy', policy, ctx.options) : null;
        },
        findOrCreatePolicy: async (type)=>await adapter.transaction({
                callback: async (txAdapter)=>{
                    try {
                        const now = new Date();
                        const txRegistry = policyRegistry({
                            adapter: txAdapter,
                            ...ctx
                        });
                        const rawLatestPolicy = await txAdapter.findOne({
                            model: 'consentPolicy',
                            where: [
                                {
                                    field: 'isActive',
                                    value: true
                                },
                                {
                                    field: 'type',
                                    value: type
                                }
                            ],
                            sortBy: {
                                field: 'effectiveDate',
                                direction: 'desc'
                            }
                        });
                        const latestPolicy = rawLatestPolicy ? validateEntityOutput('consentPolicy', rawLatestPolicy, ctx.options) : null;
                        if (latestPolicy) return latestPolicy;
                        const { content: defaultContent, contentHash } = await generatePolicyPlaceholder(type, now);
                        return txRegistry.createConsentPolicy({
                            version: '1.0.0',
                            type,
                            name: type,
                            effectiveDate: now,
                            content: defaultContent,
                            contentHash,
                            isActive: true,
                            updatedAt: now,
                            expirationDate: null
                        });
                    } catch (error) {
                        ctx.logger.error('Error in findOrCreatePolicy transaction:', error);
                        throw new error_class_DoubleTieError('Failed to find or create policy', {
                            code: error_codes_ERROR_CODES.INTERNAL_SERVER_ERROR,
                            status: 500,
                            cause: error instanceof Error ? error : new Error(String(error))
                        });
                    }
                }
            })
    };
    return registry;
}
function consentPurposeRegistry({ adapter, ...ctx }) {
    const { createWithHooks } = getWithHooks(adapter, ctx);
    return {
        createConsentPurpose: async (consentPurpose, context)=>{
            const createdPurpose = await createWithHooks({
                data: {
                    id: consentPurpose.id || '',
                    createdAt: new Date(),
                    updatedAt: new Date(),
                    ...consentPurpose
                },
                model: 'consentPurpose',
                context
            });
            if (!createdPurpose) throw new error_class_DoubleTieError('Failed to create consent purpose - operation returned null', {
                code: error_codes_ERROR_CODES.INTERNAL_SERVER_ERROR,
                status: 500
            });
            return validateEntityOutput('consentPurpose', createdPurpose, ctx.options);
        },
        findConsentPurposeByCode: async (code)=>{
            const consentPurpose = await adapter.findOne({
                model: 'consentPurpose',
                where: [
                    {
                        field: 'code',
                        value: code
                    }
                ]
            });
            return consentPurpose ? validateEntityOutput('consentPurpose', consentPurpose, ctx.options) : null;
        }
    };
}
function domainRegistry({ adapter, ...ctx }) {
    const { createWithHooks } = getWithHooks(adapter, ctx);
    const registry = {
        createDomain: async (domain, context)=>{
            const createdDomain = await createWithHooks({
                data: {
                    ...domain,
                    createdAt: new Date(),
                    updatedAt: new Date()
                },
                model: 'domain',
                customFn: void 0,
                context
            });
            if (!createdDomain) throw new error_class_DoubleTieError('Failed to create domain - operation returned null', {
                code: error_codes_ERROR_CODES.INTERNAL_SERVER_ERROR,
                status: 500
            });
            return createdDomain;
        },
        findOrCreateDomain: async function(name, context) {
            const existingDomain = await this.findDomainByName(name);
            if (existingDomain) return existingDomain;
            const domain = await this.createDomain({
                name,
                description: `Auto-created domain for ${name}`,
                isActive: true,
                isVerified: true,
                allowedOrigins: []
            }, context);
            if (!domain) throw new error_class_DoubleTieError('Failed to create domain', {
                code: error_codes_ERROR_CODES.INTERNAL_SERVER_ERROR,
                status: 503
            });
            return domain;
        },
        findDomains: async (params = {})=>{
            const whereConditions = [];
            if (!params.includeInactive) whereConditions.push({
                field: 'isActive',
                value: true
            });
            if (params.name) whereConditions.push({
                field: 'name',
                value: params.name
            });
            const domains = await adapter.findMany({
                model: 'domain',
                where: whereConditions,
                sortBy: {
                    field: 'name',
                    direction: 'asc'
                }
            });
            return domains.map((domain)=>validateEntityOutput('domain', domain, ctx.options));
        },
        findDomain: async (name)=>{
            const domains = await registry.findDomains({
                name,
                includeInactive: false
            });
            return domains[0] || null;
        },
        findDomainByName: async (name)=>{
            const domain = await adapter.findOne({
                model: 'domain',
                where: [
                    {
                        field: 'name',
                        value: name
                    }
                ]
            });
            return domain ? validateEntityOutput('domain', domain, ctx.options) : null;
        }
    };
    return registry;
}
function subjectRegistry({ adapter, ...ctx }) {
    const { createWithHooks } = getWithHooks(adapter, ctx);
    return {
        createSubject: async (subject, context)=>{
            const createdSubject = await createWithHooks({
                data: {
                    createdAt: new Date(),
                    updatedAt: new Date(),
                    ...subject
                },
                model: 'subject',
                customFn: void 0,
                context
            });
            return createdSubject ? validateEntityOutput('subject', createdSubject, ctx.options) : null;
        },
        findOrCreateSubject: async function({ subjectId, externalSubjectId, identityProvider, ipAddress = 'unknown', context }) {
            if (subjectId && externalSubjectId) {
                const [subjectById, subjectByExternalId] = await Promise.all([
                    this.findSubjectById(subjectId),
                    this.findSubjectByExternalId(externalSubjectId)
                ]);
                if (!subjectById || !subjectByExternalId) {
                    ctx.logger?.error('Subject validation failed: One or both subjects not found', {
                        providedSubjectId: subjectId,
                        providedExternalId: externalSubjectId,
                        subjectByIdFound: !!subjectById,
                        subjectByExternalIdFound: !!subjectByExternalId
                    });
                    throw new error_class_DoubleTieError('The specified subject could not be found. Please verify the subject identifiers and try again.', {
                        code: error_codes_ERROR_CODES.NOT_FOUND,
                        status: 404,
                        meta: {
                            providedSubjectId: subjectId,
                            providedExternalId: externalSubjectId
                        }
                    });
                }
                if (subjectById.id !== subjectByExternalId.id) {
                    ctx.logger?.warn('Subject validation failed: IDs do not match the same subject', {
                        providedSubjectId: subjectId,
                        providedExternalId: externalSubjectId,
                        subjectByIdId: subjectById.id,
                        subjectByExternalIdId: subjectByExternalId.id
                    });
                    throw new error_class_DoubleTieError('The provided subjectId and externalSubjectId do not match the same subject. Please ensure both identifiers refer to the same subject.', {
                        code: error_codes_ERROR_CODES.CONFLICT,
                        status: 409,
                        meta: {
                            providedSubjectId: subjectId,
                            providedExternalId: externalSubjectId,
                            subjectByIdId: subjectById.id,
                            subjectByExternalIdId: subjectByExternalId.id
                        }
                    });
                }
                return subjectById;
            }
            if (subjectId) {
                const subject = await this.findSubjectById(subjectId);
                if (subject) return subject;
                throw new error_class_DoubleTieError('Subject not found by subjectId', {
                    code: error_codes_ERROR_CODES.NOT_FOUND,
                    status: 404
                });
            }
            if (externalSubjectId) try {
                const subject = await this.findSubjectByExternalId(externalSubjectId);
                if (subject) {
                    ctx.logger?.debug('Found existing subject by external ID', {
                        externalSubjectId
                    });
                    return subject;
                }
                ctx.logger?.info('Creating new subject with external ID', {
                    externalSubjectId
                });
                return await this.createSubject({
                    externalId: externalSubjectId,
                    identityProvider: identityProvider ?? 'external',
                    lastIpAddress: ipAddress,
                    isIdentified: true
                }, context);
            } catch (error) {
                if (error instanceof Error && error.message.includes('unique constraint')) {
                    ctx.logger?.info('Handling duplicate key violation for external ID', {
                        externalSubjectId
                    });
                    const subject = await this.findSubjectByExternalId(externalSubjectId);
                    if (subject) return subject;
                }
                ctx.logger?.error('Failed to create or find subject with external ID', {
                    externalSubjectId,
                    error: error instanceof Error ? error.message : 'Unknown error'
                });
                throw new error_class_DoubleTieError('Failed to create or find subject with external ID', {
                    code: error_codes_ERROR_CODES.INTERNAL_SERVER_ERROR,
                    status: 500,
                    meta: {
                        error: error instanceof Error ? error.message : 'Unknown error'
                    }
                });
            }
            try {
                ctx.logger?.info('Creating new anonymous subject');
                return await this.createSubject({
                    externalId: null,
                    identityProvider: 'anonymous',
                    lastIpAddress: ipAddress,
                    isIdentified: false
                }, context);
            } catch (error) {
                ctx.logger?.error('Failed to create anonymous subject', {
                    ipAddress,
                    error: error instanceof Error ? error.message : 'Unknown error'
                });
                throw new error_class_DoubleTieError('Failed to create anonymous subject', {
                    code: error_codes_ERROR_CODES.INTERNAL_SERVER_ERROR,
                    status: 500,
                    meta: {
                        error: error instanceof Error ? error.message : 'Unknown error'
                    }
                });
            }
        },
        findSubjectById: async (subjectId)=>{
            const subject = await adapter.findOne({
                model: 'subject',
                where: [
                    {
                        field: 'id',
                        value: subjectId
                    }
                ]
            });
            return subject ? validateEntityOutput('subject', subject, ctx.options) : null;
        },
        findSubjectByExternalId: async (externalId)=>{
            const subject = await adapter.findOne({
                model: 'subject',
                where: [
                    {
                        field: 'externalId',
                        value: externalId
                    }
                ]
            });
            return subject ? validateEntityOutput('subject', subject, ctx.options) : null;
        }
    };
}
function auditLogRegistry({ adapter, ...ctx }) {
    const { createWithHooks } = getWithHooks(adapter, ctx);
    return {
        createAuditLog: async (auditLog, context)=>{
            const createdLog = await createWithHooks({
                data: {
                    createdAt: new Date(),
                    ...auditLog
                },
                model: 'auditLog',
                customFn: void 0,
                context
            });
            if (!createdLog) throw new error_class_DoubleTieError('Failed to create audit log - operation returned null', {
                code: error_codes_ERROR_CODES.INTERNAL_SERVER_ERROR,
                status: 500
            });
            return createdLog;
        }
    };
}
function dialect_getDatabaseType(db) {
    if (!db) return null;
    if ('dialect' in db) return dialect_getDatabaseType(db.dialect);
    if (db && 'object' == typeof db && 'createDriver' in db) {
        if (db instanceof SqliteDialect) return 'sqlite';
        if (db instanceof MysqlDialect) return 'mysql';
        if (db instanceof PostgresDialect) return 'postgres';
        if (db instanceof MssqlDialect) return 'mssql';
    }
    if (db && 'object' == typeof db && 'aggregate' in db) return 'sqlite';
    if (db && 'object' == typeof db && 'getConnection' in db) return 'mysql';
    if (db && 'object' == typeof db && 'connect' in db) return 'postgres';
    return null;
}
const createKyselyAdapter = async (config)=>{
    const db = config.database;
    if (!db) return {
        kysely: null,
        databaseType: null
    };
    if (db && 'object' == typeof db && 'db' in db) {
        const kyselyConfig = db;
        return {
            kysely: kyselyConfig.db,
            databaseType: kyselyConfig.type
        };
    }
    if (db && 'object' == typeof db && 'dialect' in db) {
        const dialectConfig = db;
        return {
            kysely: new Kysely({
                dialect: dialectConfig.dialect
            }),
            databaseType: dialectConfig.type
        };
    }
    let dialect;
    const databaseType = dialect_getDatabaseType(db);
    if (db && 'object' == typeof db && 'createDriver' in db) dialect = db;
    if (db && 'object' == typeof db && 'aggregate' in db) dialect = new SqliteDialect({
        database: db
    });
    if (db && 'object' == typeof db && 'getConnection' in db) dialect = new MysqlDialect({
        pool: db
    });
    if (db && 'object' == typeof db && 'connect' in db) dialect = new PostgresDialect({
        pool: db
    });
    return {
        kysely: dialect ? new Kysely({
            dialect
        }) : null,
        databaseType
    };
};
const createEntityTransformer = (db, options, config)=>{
    const schema = definition_getConsentTables(options);
    function getField(model, field) {
        if ('id' === field) return field;
        const modelFields = schema[model]?.fields;
        const f = modelFields ? modelFields[field] : void 0;
        if (!f) console.log('Field not found', model, field);
        return f?.fieldName || field;
    }
    function transformValueToDB(value, model, field) {
        if ('id' === field) return value;
        const { type = 'sqlite' } = config || {};
        const modelFields = schema[model]?.fields;
        const f = modelFields ? modelFields[field] : void 0;
        if (f?.type === 'boolean' && ('sqlite' === type || 'mssql' === type) && null != value) return value ? 1 : 0;
        if (f?.type === 'date' && value && value instanceof Date) return 'sqlite' === type ? value.toISOString() : value;
        if (f?.type === 'json' && null != value) {
            if ('postgres' === type || 'mysql' === type) return value;
            return superjson.stringify(value);
        }
        return value;
    }
    function transformValueFromDB(value, model, field) {
        const { type = 'sqlite' } = config || {};
        const modelFields = schema[model]?.fields;
        const f = modelFields ? modelFields[field] : void 0;
        if (f?.type === 'boolean' && ('sqlite' === type || 'mssql' === type) && null !== value) return 1 === value;
        if (f?.type === 'date' && value) return new Date(value);
        if (f?.type === 'json' && null != value) {
            if (('postgres' === type || 'mysql' === type) && 'object' == typeof value) return value;
            if ('string' == typeof value) try {
                return superjson.parse(value);
            } catch  {
                try {
                    return JSON.parse(value);
                } catch  {}
            }
        }
        return value;
    }
    function getEntityName(model) {
        return schema[model].entityName;
    }
    return {
        transformInput (data, model, action) {
            const transformedData = {};
            if ('create' === action) {
                const advancedOptions = options.advanced || {};
                transformedData.id = data.id || (advancedOptions.generateId ? advancedOptions.generateId({
                    model
                }) : id_generator_generateId(schema[model].entityPrefix));
            }
            const fields = schema[model].fields;
            for(const field in fields)if (Object.hasOwn(fields, field)) {
                const value = data[field];
                const fieldInfo = fields[field];
                const fieldName = fieldInfo?.fieldName || field;
                if (fieldInfo) transformedData[fieldName] = utils_applyDefaultValue(transformValueToDB(value, model, field), fieldInfo, action);
            }
            return transformedData;
        },
        transformOutput (data, model, select = []) {
            if (!data) return null;
            const transformedData = {};
            if (data.id && (0 === select.length || select.includes('id'))) transformedData.id = data.id;
            const tableSchema = schema[model]?.fields;
            for(const key in tableSchema){
                if (select.length && !select.includes(key)) continue;
                const field = tableSchema[key];
                if (field) transformedData[key] = transformValueFromDB(data[field.fieldName || key], model, key);
            }
            return transformedData;
        },
        convertWhereClause (model, whereConditions) {
            if (!whereConditions || 0 === whereConditions.length) return {
                and: null,
                or: null
            };
            const conditions = {
                and: [],
                or: []
            };
            for (const condition of whereConditions){
                let { field: _field, value, operator = '=', connector = 'AND' } = condition;
                const fieldString = getField(model, _field);
                value = transformValueToDB(value, model, _field);
                const expr = (eb)=>{
                    const dbField = fieldString;
                    if ('in' === operator.toLowerCase()) return eb(dbField, 'in', Array.isArray(value) ? value : [
                        value
                    ]);
                    if ('contains' === operator) return eb(dbField, 'like', `%${value}%`);
                    if ('starts_with' === operator) return eb(dbField, 'like', `${value}%`);
                    if ('ends_with' === operator) return eb(dbField, 'like', `%${value}`);
                    if ('ilike' === operator) {
                        const lowerField = eb.fn('lower', [
                            dbField
                        ]);
                        const lowerValue = eb.fn('lower', [
                            eb.val(value?.toString())
                        ]);
                        return eb(lowerField, 'like', lowerValue);
                    }
                    if ('eq' === operator) return eb(dbField, '=', value);
                    if ('ne' === operator) return eb(dbField, '<>', value);
                    if ('gt' === operator) return eb(dbField, '>', value);
                    if ('gte' === operator) return eb(dbField, '>=', value);
                    if ('lt' === operator) return eb(dbField, '<', value);
                    if ('lte' === operator) return eb(dbField, '<=', value);
                    return eb(dbField, operator, value);
                };
                if ('OR' === connector) conditions.or.push(expr);
                else conditions.and.push(expr);
            }
            return {
                and: conditions.and.length ? conditions.and : null,
                or: conditions.or.length ? conditions.or : null
            };
        },
        async withReturning (values, builder, model, where) {
            let res = null;
            if (config?.type === 'mysql') {
                await builder.execute();
                const whereCondition = where[0];
                const field = values.id ? 'id' : whereCondition?.field ?? 'id';
                const value = values[field] ?? whereCondition?.value;
                const fieldString = getField(model, field);
                res = await db.selectFrom(getEntityName(model)).selectAll().where((eb)=>eb(fieldString, '=', value)).executeTakeFirst();
                return res;
            }
            if (config?.type === 'mssql') {
                res = await builder.outputAll('inserted').executeTakeFirst();
                return res;
            }
            res = await builder.returningAll().executeTakeFirst();
            return res;
        },
        getEntityName,
        getField
    };
};
const kyselyAdapter = (db, config)=>(opts)=>{
        const { transformInput, withReturning, transformOutput, convertWhereClause, getEntityName, getField } = createEntityTransformer(db, opts, config);
        return {
            id: 'kysely',
            async create (data) {
                const { model, data: values, select } = data;
                const transformed = transformInput(values, model, 'create');
                const tableName = getEntityName(model);
                const builder = db.insertInto(tableName).values(transformed);
                const result = await withReturning(transformed, builder, model, []);
                const output = transformOutput(result, model, select);
                return output;
            },
            async findOne (data) {
                const { model, where, select } = data;
                const whereArray = Array.isArray(where) ? where : [
                    where
                ];
                const { and, or } = convertWhereClause(model, whereArray);
                const tableName = getEntityName(model);
                let query = db.selectFrom(tableName).selectAll();
                if (and) query = query.where((eb)=>{
                    const conditions = and.map((expr)=>expr(eb));
                    return eb.and(conditions);
                });
                if (or) query = query.where((eb)=>{
                    const conditions = or.map((expr)=>expr(eb));
                    return eb.or(conditions);
                });
                const res = await query.executeTakeFirst();
                if (!res) return null;
                return transformOutput(res, model, select);
            },
            async findMany (data) {
                const { model, where, limit, offset, sortBy } = data;
                const whereArray = where ? Array.isArray(where) ? where : [
                    where
                ] : void 0;
                const { and, or } = convertWhereClause(model, whereArray);
                const tableName = getEntityName(model);
                let query = db.selectFrom(tableName);
                if (and) query = query.where((eb)=>{
                    const conditions = and.map((expr)=>expr(eb));
                    return eb.and(conditions);
                });
                if (or) query = query.where((eb)=>{
                    const conditions = or.map((expr)=>expr(eb));
                    return eb.or(conditions);
                });
                if (config?.type === 'mssql') {
                    if (!offset) query = query.top(limit || 100);
                } else query = query.limit(limit || 100);
                if (sortBy) {
                    const sortFieldString = getField(model, sortBy.field);
                    query = query.orderBy(sortFieldString, sortBy.direction);
                }
                if (offset) if (config?.type === 'mssql') {
                    if (!sortBy) query = query.orderBy('id');
                    query = query.offset(offset).fetch(limit || 100);
                } else query = query.offset(offset);
                const res = await query.selectAll().execute();
                if (!res) return [];
                return res.map((r)=>transformOutput(r, model));
            },
            async update (data) {
                const { model, where, update: values } = data;
                const whereArray = Array.isArray(where) ? where : [
                    where
                ];
                const { and, or } = convertWhereClause(model, whereArray);
                const transformedData = transformInput(values, model, 'update');
                const tableName = getEntityName(model);
                let query = db.updateTable(tableName).set(transformedData);
                if (and) query = query.where((eb)=>{
                    const conditions = and.map((expr)=>expr(eb));
                    return eb.and(conditions);
                });
                if (or) query = query.where((eb)=>{
                    const conditions = or.map((expr)=>expr(eb));
                    return eb.or(conditions);
                });
                const result = await withReturning(transformedData, query, model, whereArray);
                return transformOutput(result, model);
            },
            async updateMany (data) {
                const { model, where, update: values } = data;
                const whereArray = Array.isArray(where) ? where : [
                    where
                ];
                const { and, or } = convertWhereClause(model, whereArray);
                const transformedData = transformInput(values, model, 'update');
                const tableName = getEntityName(model);
                let query = db.updateTable(tableName).set(transformedData);
                if (and) query = query.where((eb)=>{
                    const conditions = and.map((expr)=>expr(eb));
                    return eb.and(conditions);
                });
                if (or) query = query.where((eb)=>{
                    const conditions = or.map((expr)=>expr(eb));
                    return eb.or(conditions);
                });
                await query.execute();
                let selectQuery = db.selectFrom(tableName).selectAll();
                if (and) selectQuery = selectQuery.where((eb)=>{
                    const conditions = and.map((expr)=>expr(eb));
                    return eb.and(conditions);
                });
                if (or) selectQuery = selectQuery.where((eb)=>{
                    const conditions = or.map((expr)=>expr(eb));
                    return eb.or(conditions);
                });
                const fetchedResults = await selectQuery.execute();
                if (!fetchedResults || 0 === fetchedResults.length) return [];
                return fetchedResults.map((record)=>transformOutput(record, model));
            },
            async count (data) {
                const { model, where } = data;
                const whereArray = where ? Array.isArray(where) ? where : [
                    where
                ] : void 0;
                const { and, or } = convertWhereClause(model, whereArray);
                const tableName = getEntityName(model);
                let query = db.selectFrom(tableName).select((eb)=>eb.fn.count('id').as('count'));
                if (and) query = query.where((eb)=>{
                    const conditions = and.map((expr)=>expr(eb));
                    return eb.and(conditions);
                });
                if (or) query = query.where((eb)=>{
                    const conditions = or.map((expr)=>expr(eb));
                    return eb.or(conditions);
                });
                const res = await query.execute();
                const count = res[0]?.count;
                return 'number' == typeof count ? count : 0;
            },
            async delete (data) {
                const { model, where } = data;
                const whereArray = Array.isArray(where) ? where : [
                    where
                ];
                const { and, or } = convertWhereClause(model, whereArray);
                const tableName = getEntityName(model);
                let query = db.deleteFrom(tableName);
                if (and) query = query.where((eb)=>{
                    const conditions = and.map((expr)=>expr(eb));
                    return eb.and(conditions);
                });
                if (or) query = query.where((eb)=>{
                    const conditions = or.map((expr)=>expr(eb));
                    return eb.or(conditions);
                });
                await query.execute();
            },
            async deleteMany (data) {
                const { model, where } = data;
                const whereArray = Array.isArray(where) ? where : [
                    where
                ];
                const { and, or } = convertWhereClause(model, whereArray);
                const tableName = getEntityName(model);
                let query = db.deleteFrom(tableName);
                if (and) query = query.where((eb)=>{
                    const conditions = and.map((expr)=>expr(eb));
                    return eb.and(conditions);
                });
                if (or) query = query.where((eb)=>{
                    const conditions = or.map((expr)=>expr(eb));
                    return eb.or(conditions);
                });
                const result = await query.execute();
                const count = result.length;
                return count;
            },
            async transaction (data) {
                const { callback } = data;
                const advancedOptions = opts.advanced || {};
                if (advancedOptions.disableTransactions) {
                    const regularAdapter = kyselyAdapter(db, config)(opts);
                    return await callback(regularAdapter);
                }
                try {
                    return await db.transaction().execute(async (trx)=>{
                        const transactionAdapter = kyselyAdapter(trx, config)(opts);
                        return await callback(transactionAdapter);
                    });
                } catch (error) {
                    if (error instanceof Error && (error.message.includes('transactions are not supported') || error.message.toLowerCase().includes('no transaction support'))) {
                        console.warn("Warning: Database transaction failed. If your database does not support transactions, you can disable this warning by setting opts.advanced.disableTransactions to true.");
                        const regularAdapter = kyselyAdapter(db, config)(opts);
                        return await callback(regularAdapter);
                    }
                    throw error;
                }
            },
            options: config
        };
    };
function utils_applyDefaultValue(inputValue, field, operation) {
    if ('update' === operation) return inputValue;
    if (null == inputValue && field.defaultValue) {
        if ('function' == typeof field.defaultValue) return field.defaultValue();
        return field.defaultValue;
    }
    return inputValue;
}
const memory_adapter_createEntityTransformer = (options)=>{
    const schema = definition_getConsentTables(options);
    function getField(model, field) {
        if ('id' === field) return field;
        const modelFields = schema[model]?.fields;
        const f = modelFields ? modelFields[field] : void 0;
        return f?.fieldName || field;
    }
    return {
        transformInput (data, model, action) {
            const advancedOptions = options.advanced || {};
            const transformedData = 'update' === action ? {} : {
                id: advancedOptions.generateId ? advancedOptions.generateId({
                    model
                }) : data.id || id_generator_generateId(schema[model].entityPrefix)
            };
            const fields = schema[model].fields;
            for(const field in fields)if (Object.hasOwn(fields, field)) {
                const value = data[field];
                const fieldInfo = fields[field];
                if (void 0 === value && !fieldInfo?.defaultValue) continue;
                const fieldName = fieldInfo?.fieldName || field;
                transformedData[fieldName] = utils_applyDefaultValue(value, fieldInfo, action);
            }
            return transformedData;
        },
        transformOutput (data, model, select = []) {
            if (!data) return null;
            const transformedData = {};
            const hasId = data.id || data._id;
            if (hasId && (0 === select.length || select.includes('id'))) transformedData.id = data.id;
            const tableSchema = schema[model].fields;
            for(const key in tableSchema){
                if (select.length && !select.includes(key)) continue;
                const field = tableSchema[key];
                if (field) transformedData[key] = data[field.fieldName || key];
            }
            return transformedData;
        },
        convertWhereClause (where, table, model) {
            return table.filter((record)=>where.every((clause)=>{
                    const { field: _field, value, operator = '=' } = clause;
                    const field = getField(model, _field);
                    if ('in' === operator) {
                        if (!Array.isArray(value)) throw new Error('Value must be an array');
                        return value.includes(record[field]);
                    }
                    if ('contains' === operator) {
                        const fieldValue = record[field];
                        return 'string' == typeof fieldValue && fieldValue.includes(value);
                    }
                    if ('starts_with' === operator) {
                        const fieldValue = record[field];
                        return 'string' == typeof fieldValue && fieldValue.startsWith(value);
                    }
                    if ('ends_with' === operator) {
                        const fieldValue = record[field];
                        return 'string' == typeof fieldValue && fieldValue.endsWith(value);
                    }
                    if ('eq' === operator) return record[field] === value;
                    if ('ne' === operator) return record[field] !== value;
                    return record[field] === value;
                }));
        },
        getField
    };
};
const memoryAdapter = (db)=>(options)=>{
        const { transformInput, transformOutput, convertWhereClause, getField } = memory_adapter_createEntityTransformer(options);
        const schema = definition_getConsentTables(options);
        for(const model in schema)if (!db[model]) db[model] = [];
        return {
            id: 'memory',
            async create (data) {
                const { model, data: values, select } = data;
                const transformed = transformInput(values, model, 'create');
                if (!db[model]) db[model] = [];
                db[model].push(transformed);
                return transformOutput(transformed, model, select);
            },
            async findOne (data) {
                const { model, where, select } = data;
                const table = db[model] || [];
                const whereArray = Array.isArray(where) ? where : [
                    where
                ];
                const res = convertWhereClause(whereArray, table, model);
                const record = res[0] || null;
                return transformOutput(record, model, select);
            },
            async findMany (data) {
                const { model, where, sortBy, limit, offset } = data;
                let table = db[model] || [];
                if (where) {
                    const whereArray = Array.isArray(where) ? where : [
                        where
                    ];
                    table = convertWhereClause(whereArray, table, model);
                }
                if (sortBy) {
                    const field = getField(model, sortBy.field);
                    table = [
                        ...table
                    ].sort((a, b)=>{
                        if ('asc' === sortBy.direction) return a[field] > b[field] ? 1 : -1;
                        return a[field] < b[field] ? 1 : -1;
                    });
                }
                let result = table;
                if (void 0 !== offset) result = result.slice(offset);
                if (void 0 !== limit) result = result.slice(0, limit);
                return result.map((record)=>transformOutput(record, model));
            },
            async count (data) {
                const { model, where } = data;
                const table = db[model] || [];
                if (!where) return table.length;
                const whereArray = Array.isArray(where) ? where : [
                    where
                ];
                const filtered = convertWhereClause(whereArray, table, model);
                return filtered.length;
            },
            async update (data) {
                const { model, where, update: values } = data;
                const table = db[model] || [];
                const whereArray = Array.isArray(where) ? where : [
                    where
                ];
                const res = convertWhereClause(whereArray, table, model);
                for (const record of res)Object.assign(record, transformInput(values, model, 'update'));
                return transformOutput(res[0] || null, model);
            },
            async updateMany (data) {
                const { model, where, update: values } = data;
                const table = db[model] || [];
                const whereArray = Array.isArray(where) ? where : [
                    where
                ];
                const res = convertWhereClause(whereArray, table, model);
                for (const record of res)Object.assign(record, transformInput(values, model, 'update'));
                return res.map((record)=>transformOutput(record, model));
            },
            async delete (data) {
                const { model, where } = data;
                const table = db[model] || [];
                const whereArray = Array.isArray(where) ? where : [
                    where
                ];
                const res = convertWhereClause(whereArray, table, model);
                db[model] = table.filter((record)=>!res.includes(record));
            },
            async deleteMany (data) {
                const { model, where } = data;
                const table = db[model] || [];
                const whereArray = Array.isArray(where) ? where : [
                    where
                ];
                const res = convertWhereClause(whereArray, table, model);
                let count = 0;
                db[model] = table.filter((record)=>{
                    if (res.includes(record)) {
                        count++;
                        return false;
                    }
                    return true;
                });
                return count;
            },
            async transaction (data) {
                const { callback } = data;
                const tempDb = {};
                for(const key in db)if (Object.hasOwn(db, key)) tempDb[key] = JSON.parse(JSON.stringify(db[key]));
                const transactionAdapter = memoryAdapter(tempDb)(options);
                const result = await callback(transactionAdapter);
                for(const key in tempDb)if (Object.hasOwn(tempDb, key)) db[key] = tempDb[key];
                return result;
            }
        };
    };
async function getAdapter(options) {
    const logger = getLogger({
        appName: options.appName ?? 'c15t',
        ...options.logger
    });
    if (!options.database) {
        const tables = definition_getConsentTables(options);
        const memoryDB = Object.keys(tables).reduce((acc, key)=>{
            acc[key] = [];
            return acc;
        }, {});
        logger.warn('No database configuration provided. Using memory adapter in development');
        return memoryAdapter(memoryDB)(options);
    }
    if ('function' == typeof options.database) return options.database(options);
    const { kysely, databaseType } = await createKyselyAdapter(options);
    if (!kysely) throw new error_class_DoubleTieError('Failed to initialize database adapter', {
        code: error_codes_ERROR_CODES.INTERNAL_SERVER_ERROR,
        status: 500
    });
    return kyselyAdapter(kysely, {
        type: databaseType || 'sqlite'
    })(options);
}
const env = 'undefined' != typeof process ? process.env : {};
'undefined' != typeof process && process.env.NODE_ENV;
function toBoolean(val) {
    return val ? 'false' !== val : false;
}
const nodeENV = 'undefined' != typeof process && process.env && process.env.NODE_ENV || '';
const isTest = 'test' === nodeENV || toBoolean(env.TEST);
const TRAILING_SLASHES_REGEX = /\/+$/;
function checkHasPath(url) {
    try {
        const parsedUrl = new URL(url);
        return '/' !== parsedUrl.pathname;
    } catch  {
        throw new error_class_DoubleTieError(`Invalid base URL: ${url}. Please provide a valid base URL.`, {
            code: error_codes_ERROR_CODES.BAD_REQUEST,
            status: 400,
            meta: {
                url
            }
        });
    }
}
function withPath(url, path = '/api/auth') {
    const hasPath = checkHasPath(url);
    if (hasPath) return url;
    const pathWithSlash = path.startsWith('/') ? path : `/${path}`;
    return `${url.replace(TRAILING_SLASHES_REGEX, '')}${pathWithSlash}`;
}
function getBaseURL(url, path) {
    if (url) return withPath(url, path);
    const fromEnv = env.C15T_URL || env.NEXT_PUBLIC_C15T_URL || env.PUBLIC_C15T_URL || env.NUXT_PUBLIC_C15T_URL || env.NUXT_PUBLIC_AUTH_URL || ('/' !== env.BASE_URL ? env.BASE_URL : void 0);
    if (fromEnv) return withPath(fromEnv, path);
}
var package_namespaceObject = {
    rE: "1.8.0"
};
const createRegistry = (ctx)=>({
        ...auditLogRegistry(ctx),
        ...consentRegistry(ctx),
        ...domainRegistry(ctx),
        ...consentPurposeRegistry(ctx),
        ...policyRegistry(ctx),
        ...subjectRegistry(ctx)
    });
let telemetrySdk;
const init = async (options)=>{
    try {
        const loggerOptions = options.logger;
        const baseUrlStr = options.baseURL;
        const basePathStr = options.basePath;
        const databaseHooks = options.databaseHooks || [];
        const appName = options.appName || 'c15t';
        const logger = initLogger({
            ...loggerOptions,
            appName: String(appName)
        });
        const telemetryOptions = createTelemetryOptions(String(appName), options.telemetry);
        let telemetryInitialized = false;
        try {
            if (telemetrySdk) {
                logger.debug('Telemetry SDK already initialized, skipping');
                telemetryInitialized = true;
            } else if (telemetryOptions?.disabled) {
                logger.info('Telemetry is disabled by configuration');
                telemetryInitialized = false;
            } else {
                const resource = resourceFromAttributes({
                    'service.name': String(appName),
                    'service.version': String(package_namespaceObject.rE || '1.0.0'),
                    ...telemetryOptions?.defaultAttributes || {}
                });
                logger.debug('Initializing telemetry with resource attributes', {
                    attributes: resource.attributes
                });
                const traceExporter = telemetryOptions?.tracer ? void 0 : new ConsoleSpanExporter();
                telemetrySdk = new NodeSDK({
                    resource,
                    traceExporter
                });
                telemetrySdk.start();
                logger.info('Telemetry successfully initialized');
                telemetryInitialized = true;
            }
        } catch (error) {
            logger.error('Telemetry initialization failed', {
                error: error instanceof Error ? error.message : String(error),
                stack: error instanceof Error ? error.stack : void 0
            });
            logger.warn('Continuing without telemetry');
            telemetryInitialized = false;
        }
        if (telemetryOptions?.disabled) logger.info('Telemetry is disabled by configuration');
        else if (telemetryInitialized) logger.info('Telemetry initialized successfully');
        else logger.warn('Telemetry initialization failed, continuing without telemetry');
        logger.info('Initializing adapter', {
            storage: options.storage && 'object' == typeof options.storage ? options.storage.type || 'unknown' : 'unknown',
            clientVersion: options.clientVersion || 'not provided',
            appName,
            baseURL: baseUrlStr
        });
        const adapterResult = await promiseToResult(getAdapter(options), error_codes_ERROR_CODES.INITIALIZATION_FAILED);
        logger.debug('Adapter initialization result', {
            success: adapterResult.isOk()
        });
        return adapterResult.andThen((adapter)=>{
            const resolvedBaseURL = getBaseURL(baseUrlStr, basePathStr);
            const finalOptions = {
                ...options,
                baseURL: resolvedBaseURL ? new URL(resolvedBaseURL).origin : '',
                basePath: basePathStr || '/api/c15t',
                plugins: [
                    ...options.plugins || [],
                    ...getInternalPlugins(options)
                ],
                telemetry: telemetryOptions
            };
            const generateIdFunc = ({ model, size = 16 })=>finalOptions?.advanced?.generateId?.({
                    model,
                    size
                }) || id_generator_generateId(definition_getConsentTables(finalOptions)[model].entityPrefix);
            const registryContext = {
                adapter,
                options: finalOptions,
                logger,
                hooks: databaseHooks,
                generateId: generateIdFunc
            };
            const ctx = {
                appName: String(appName),
                options: finalOptions,
                trustedOrigins: options.trustedOrigins || [],
                baseURL: resolvedBaseURL || '',
                logger,
                generateId: generateIdFunc,
                adapter,
                registry: createRegistry(registryContext),
                tables: definition_getConsentTables(options)
            };
            return runPluginInit(ctx);
        });
    } catch (error) {
        const errorLogger = getLogger(options.logger);
        errorLogger.error('Initialization failed', {
            error: error instanceof Error ? error.message : String(error),
            stack: error instanceof Error ? error.stack : void 0
        });
        return failAsync(`Failed to initialize consent system: ${error instanceof Error ? error.message : String(error)}`, {
            code: error_codes_ERROR_CODES.INITIALIZATION_FAILED,
            meta: {
                error
            }
        });
    }
};
function runPluginInit(ctx) {
    try {
        let options = ctx.options;
        const plugins = options.plugins || [];
        let context = ctx;
        for (const plugin of plugins){
            const typedPlugin = plugin;
            if (typedPlugin.init) {
                const result = typedPlugin.init(ctx);
                if ('object' == typeof result) {
                    if (result.options) options = defu(result.options, options);
                    if (result.context) context = {
                        ...context,
                        ...result.context
                    };
                }
            }
        }
        context.options = options;
        return external_neverthrow_ok(context);
    } catch (error) {
        return fail(`Plugin initialization failed: ${error instanceof Error ? error.message : String(error)}`, {
            code: error_codes_ERROR_CODES.PLUGIN_INITIALIZATION_FAILED,
            meta: {
                error
            }
        });
    }
}
function getInternalPlugins(_options) {
    const plugins = [];
    return plugins;
}
const WWW_REGEX = /^www\./;
const PROTOCOL_WWW_REGEX = /^https?:\/\/(www\.)?/;
const SUPPORTED_METHODS = [
    'GET',
    'POST',
    'PUT',
    'DELETE',
    'PATCH',
    'OPTIONS'
];
const SUPPORTED_HEADERS = [
    'Content-Type',
    'Authorization',
    'x-request-id',
    'x-c15t-country',
    'x-c15t-region',
    'accept-language'
];
const DEFAULT_CORS_CONFIG = {
    origin: async (origin)=>await Promise.resolve(origin || '*'),
    credentials: true,
    allowHeaders: SUPPORTED_HEADERS,
    maxAge: 600,
    methods: SUPPORTED_METHODS
};
function createCORSOptions(trustedOrigins) {
    if (!trustedOrigins) return DEFAULT_CORS_CONFIG;
    const origins = Array.isArray(trustedOrigins) ? trustedOrigins : [
        trustedOrigins
    ];
    if (0 === origins.length) return DEFAULT_CORS_CONFIG;
    function normalizeOrigin(origin) {
        try {
            if (!origin.includes('://') && !origin.includes(':') && !origin.includes('/')) return origin.toLowerCase();
            const originWithProtocol = origin.startsWith('http://') || origin.startsWith('https://') || origin.startsWith('ws://') || origin.startsWith('wss://') ? origin : `http://${origin}`;
            const url = new URL(originWithProtocol);
            const hostname = url.hostname.replace(WWW_REGEX, '');
            return `${hostname}${url.port ? `:${url.port}` : ''}`;
        } catch  {
            return origin.replace(PROTOCOL_WWW_REGEX, '').replace(WWW_REGEX, '');
        }
    }
    function expandWithWWW(origins) {
        const expanded = new Set();
        for (const origin of origins){
            if ('*' === origin) {
                expanded.add('*');
                continue;
            }
            const normalized = normalizeOrigin(origin);
            expanded.add(normalized);
            if (!normalized.includes('www.')) expanded.add(`www.${normalized}`);
        }
        return Array.from(expanded);
    }
    const expandedTrusted = expandWithWWW(origins);
    const returnConfig = {
        origin: async (origin)=>{
            if (!origin) return '*';
            const normalizedOrigin = normalizeOrigin(origin);
            if (expandedTrusted.includes('*')) return origin;
            const isTrusted = expandedTrusted.some((trusted)=>{
                const normalizedTrusted = normalizeOrigin(trusted);
                if ('localhost' === normalizedTrusted) return 'localhost' === normalizedOrigin || normalizedOrigin.startsWith('localhost:') || '127.0.0.1' === normalizedOrigin || normalizedOrigin.startsWith('127.0.0.1:') || '[::1]' === normalizedOrigin || normalizedOrigin.startsWith('[::1]:');
                return normalizedTrusted === normalizedOrigin;
            });
            return isTrusted ? origin : null;
        },
        credentials: true,
        allowHeaders: SUPPORTED_HEADERS,
        maxAge: 600,
        methods: SUPPORTED_METHODS
    };
    return returnConfig;
}
const STRIP_REGEX = /^(https?:\/\/)|(wss?:\/\/)|(\/+$)|:\d+/g;
function matchesWildcard(hostname, wildcardPattern, logger) {
    const wildcardDomain = wildcardPattern.slice(2);
    const isValid = hostname !== wildcardDomain && hostname.endsWith(`.${wildcardDomain}`);
    logger?.debug(`Wildcard match result: ${isValid} ${hostname} ends with .${wildcardDomain}`);
    return isValid;
}
function isOriginTrusted(origin, trustedDomains, logger) {
    try {
        if (0 === trustedDomains.length) throw new Error('No trusted domains');
        logger?.debug(`Checking if origin ${origin} is trusted in ${trustedDomains}`);
        if (trustedDomains.includes('*')) {
            logger?.debug('Allowing all origins');
            return true;
        }
        const url = new URL(origin);
        const originHostname = url.hostname.toLowerCase();
        logger?.debug(`Parsed origin hostname: ${originHostname}`);
        return trustedDomains.some((domain)=>{
            if (!domain || '' === domain.trim()) {
                logger?.debug('Skipping empty domain');
                return false;
            }
            const strippedDomain = domain.replace(STRIP_REGEX, '').toLowerCase();
            logger?.debug(`Checking against stripped domain: ${strippedDomain}`);
            if (strippedDomain.startsWith('*.')) return matchesWildcard(originHostname, strippedDomain, logger);
            const isMatch = originHostname === strippedDomain;
            logger?.debug(`Exact match result: ${isMatch} ${originHostname} === ${strippedDomain}`);
            return isMatch;
        });
    } catch (error) {
        logger?.error('Error validating origin:', error);
        return false;
    }
}
function extractCORSInfo(request, trustedOrigins, logger) {
    const origin = request.headers.get('origin');
    if (!origin || !trustedOrigins) return {
        origin: origin,
        isTrusted: false
    };
    return {
        origin,
        isTrusted: isOriginTrusted(origin, trustedOrigins, logger)
    };
}
const processCors = (request, context, trustedOrigins)=>{
    const { origin, isTrusted } = extractCORSInfo(request, trustedOrigins, context.logger);
    if (origin) {
        context.origin = origin;
        context.trustedOrigin = isTrusted;
    }
    return context;
};
const createOpenAPIConfig = (options)=>{
    const basePath = options.basePath || '';
    return {
        enabled: true,
        specPath: `${basePath}/spec.json`,
        docsPath: `${basePath}/docs`,
        ...options.openapi || {}
    };
};
const createDefaultOpenAPIOptions = (options)=>({
        info: {
            title: options.appName || 'c15t API',
            version: "1.8.0",
            description: 'API for consent management'
        },
        servers: [
            {
                url: options.basePath || '/'
            }
        ],
        security: [
            {
                bearerAuth: []
            }
        ]
    });
const identifyUserSchema = z.object({
    consentId: z.string(),
    externalId: z.string(),
    identityProvider: z.string().optional()
});
const identifyUserContract = oc.route({
    method: 'PATCH',
    path: '/consent/identify',
    description: "Links a subject's external ID to a consent record by consent ID. This is used to identify a user across multiple devices and sessions.",
    tags: [
        'consent',
        'cookie-banner'
    ]
}).errors({
    CONSENT_NOT_FOUND: {
        status: 404,
        data: z.object({
            consentId: z.string()
        }),
        error: 'Consent not found'
    },
    IDENTIFICATION_FAILED: {
        status: 500,
        data: z.object({
            consentId: z.string()
        }),
        error: 'Failed to identify user'
    }
}).input(identifyUserSchema).output(z.object({
    success: z.boolean()
}));
const baseConsentSchema = z.object({
    subjectId: z.string().optional(),
    externalSubjectId: z.string().optional(),
    identityProvider: z.string().optional(),
    domain: z.string(),
    type: PolicyTypeSchema,
    metadata: z.record(z.string(), z.unknown()).optional()
});
const cookieBannerSchema = baseConsentSchema.extend({
    type: z.literal('cookie_banner'),
    preferences: z.record(z.string(), z.boolean())
});
const policyBasedSchema = baseConsentSchema.extend({
    type: z["enum"]([
        'privacy_policy',
        'dpa',
        'terms_and_conditions'
    ]),
    policyId: z.string().optional(),
    preferences: z.record(z.string(), z.boolean()).optional()
});
const otherConsentSchema = baseConsentSchema.extend({
    type: z["enum"]([
        'marketing_communications',
        'age_verification',
        'other'
    ]),
    preferences: z.record(z.string(), z.boolean()).optional()
});
const postConsentContract = oc.route({
    method: 'POST',
    path: '/consent/set',
    description: `Records a user's consent preferences and creates necessary consent records.
This endpoint handles various types of consent submissions:

1. Cookie Banner Consent:
   - Records granular cookie preferences
   - Supports multiple consent purposes
   - Creates audit trail for compliance

2. Policy-Based Consent:
   - Privacy Policy acceptance
   - Data Processing Agreement (DPA) consent
   - Terms and Conditions acceptance
   - Links consent to specific policy versions

3. Other Consent Types:
   - Marketing communications preferences
   - Age verification consent
   - Custom consent types

The endpoint performs the following operations:
- Creates or retrieves subject records
- Validates domain and policy information
- Creates consent records with audit trails
- Records consent purposes and preferences
- Generates audit logs for compliance

Use this endpoint to record user consent and maintain a compliant consent management system.`,
    tags: [
        'consent',
        'cookie-banner'
    ]
}).errors({
    INPUT_VALIDATION_FAILED: {
        status: 422,
        data: z.object({
            formErrors: z.array(z.string()),
            fieldErrors: z.record(z.string(), z.array(z.string()))
        }),
        error: 'Invalid input parameters'
    },
    SUBJECT_CREATION_FAILED: {
        status: 400,
        data: z.object({
            subjectId: z.string().optional(),
            externalSubjectId: z.string().optional()
        }),
        error: 'Failed to create or find subject'
    },
    DOMAIN_CREATION_FAILED: {
        status: 500,
        data: z.object({
            domain: z.string()
        }),
        error: 'Failed to create or find domain'
    },
    POLICY_NOT_FOUND: {
        status: 404,
        data: z.object({
            policyId: z.string(),
            type: z.string()
        }),
        error: 'Policy not found'
    },
    POLICY_INACTIVE: {
        status: 409,
        data: z.object({
            policyId: z.string(),
            type: z.string()
        }),
        error: 'Policy is not active'
    },
    POLICY_CREATION_FAILED: {
        status: 500,
        data: z.object({
            type: z.string()
        }),
        error: 'Failed to create or find policy'
    },
    PURPOSE_CREATION_FAILED: {
        status: 500,
        data: z.object({
            purposeCode: z.string()
        }),
        error: 'Failed to create consent purpose'
    },
    CONSENT_CREATION_FAILED: {
        status: 500,
        data: z.object({
            subjectId: z.string(),
            domain: z.string()
        }),
        error: 'Failed to create consent record'
    }
}).input(z.discriminatedUnion('type', [
    cookieBannerSchema,
    policyBasedSchema,
    otherConsentSchema
])).output(z.object({
    id: z.string(),
    subjectId: z.string().optional(),
    externalSubjectId: z.string().optional(),
    domainId: z.string(),
    domain: z.string(),
    type: PolicyTypeSchema,
    status: z.string(),
    recordId: z.string(),
    metadata: z.record(z.string(), z.unknown()).optional(),
    givenAt: z.date()
}));
const types_branding = [
    'c15t',
    'consent',
    'none'
];
const JurisdictionMessages = {
    GDPR: 'GDPR or equivalent regulations require a cookie banner.',
    CH: 'Switzerland requires similar data protection measures.',
    BR: "Brazil's LGPD requires consent for cookies.",
    PIPEDA: 'PIPEDA requires consent for data collection.',
    AU: "Australia's Privacy Act mandates transparency about data collection.",
    APPI: "Japan's APPI requires consent for data collection.",
    PIPA: "South Korea's PIPA requires consent for data collection.",
    NONE: 'No specific requirements'
};
const JurisdictionCodeSchema = z["enum"]([
    'GDPR',
    'CH',
    'BR',
    'PIPEDA',
    'AU',
    'APPI',
    'PIPA',
    'NONE'
]);
const JurisdictionInfoSchema = z.object({
    code: JurisdictionCodeSchema,
    message: z.string()
});
const TitleDescriptionSchema = z.object({
    title: z.string(),
    description: z.string()
});
const CompleteTranslationsSchema = z.object({
    common: z.object({
        acceptAll: z.string(),
        rejectAll: z.string(),
        customize: z.string(),
        save: z.string()
    }),
    cookieBanner: TitleDescriptionSchema,
    consentManagerDialog: TitleDescriptionSchema,
    consentTypes: z.object({
        experience: TitleDescriptionSchema,
        functionality: TitleDescriptionSchema,
        marketing: TitleDescriptionSchema,
        measurement: TitleDescriptionSchema,
        necessary: TitleDescriptionSchema
    }),
    frame: z.object({
        title: z.string(),
        actionButton: z.string()
    }),
    legalLinks: z.object({
        privacyPolicy: z.string(),
        termsOfService: z.string(),
        cookiePolicy: z.string()
    })
});
const PartialTranslationsSchema = z.object({
    common: z.object({
        acceptAll: z.string().optional(),
        rejectAll: z.string().optional(),
        customize: z.string().optional(),
        save: z.string().optional()
    }).partial(),
    cookieBanner: TitleDescriptionSchema.partial(),
    consentManagerDialog: TitleDescriptionSchema.partial(),
    consentTypes: z.object({
        experience: TitleDescriptionSchema.partial(),
        functionality: TitleDescriptionSchema.partial(),
        marketing: TitleDescriptionSchema.partial(),
        measurement: TitleDescriptionSchema.partial(),
        necessary: TitleDescriptionSchema.partial()
    }).partial(),
    frame: z.object({
        title: z.string().optional(),
        actionButton: z.string().optional()
    }).partial().optional(),
    legalLinks: z.object({
        privacyPolicy: z.string().optional(),
        termsOfService: z.string().optional(),
        cookiePolicy: z.string().optional()
    }).partial().optional()
});
const TranslationsSchema = z.union([
    CompleteTranslationsSchema,
    PartialTranslationsSchema
]);
const showConsentBannerContract = oc.route({
    method: 'GET',
    path: '/show-consent-banner',
    description: `Determines if a user should see a consent banner based on their location and applicable privacy regulations.
This endpoint performs the following checks:

1. Detects the user's location using various header information:
   - Cloudflare country headers
   - Vercel IP country headers
   - AWS CloudFront headers
   - Custom country code headers

2. Determines the applicable jurisdiction based on the location:
   - GDPR (EU/EEA/UK)
   - Swiss Data Protection Act
   - LGPD (Brazil)
   - PIPEDA (Canada)
   - Australian Privacy Principles
   - APPI (Japan)
   - PIPA (South Korea)

3. Returns detailed information about:
   - Whether to show the consent banner
   - The applicable jurisdiction and its requirements
   - The user's detected location (country and region)

Use this endpoint to implement geo-targeted consent banners and ensure compliance with regional privacy regulations.`,
    tags: [
        'cookie-banner'
    ]
}).output(z.object({
    showConsentBanner: z.boolean(),
    jurisdiction: JurisdictionInfoSchema,
    location: z.object({
        countryCode: z.string().nullable(),
        regionCode: z.string().nullable()
    }),
    translations: z.object({
        language: z.string(),
        translations: TranslationsSchema
    }),
    branding: z["enum"](types_branding)
}));
const verifyConsentInputSchema = z.strictObject({
    subjectId: z.string().optional(),
    externalSubjectId: z.string().optional(),
    domain: z.string(),
    type: PolicyTypeSchema,
    policyId: z.string().optional(),
    preferences: z.array(z.string()).optional()
});
const verify_contract_consentSchema = z.looseObject({
    id: z.string(),
    purposeIds: z.array(z.string())
});
const verifyConsentContract = oc.route({
    method: 'POST',
    path: '/consent/verify',
    description: `Verifies if a user has given valid consent for a specific policy and domain.
This endpoint performs comprehensive consent verification by:

1. Validating the subject's identity (using subjectId or externalSubjectId)
2. Verifying the domain's existence and validity
3. Checking if the specified policy exists and is active
4. Validating that all required purposes have been consented to
5. Ensuring the consent record is current and valid

The endpoint supports different types of consent verification:
- Cookie banner consent verification
- Privacy policy consent verification
- Terms and conditions verification
- Marketing communications consent verification
- Age verification
- Custom consent types

Use this endpoint to ensure compliance with privacy regulations and to verify user consent before processing personal data.`,
    tags: [
        'consent'
    ]
}).errors({
    INPUT_VALIDATION_FAILED: {
        status: 422,
        data: z.object({
            formErrors: z.array(z.string()),
            fieldErrors: z.record(z.string(), z.array(z.string()).optional())
        }),
        error: 'Invalid input parameters'
    },
    SUBJECT_NOT_FOUND: {
        status: 404,
        data: z.object({
            subjectId: z.string().optional(),
            externalSubjectId: z.string().optional()
        }),
        error: 'Subject not found'
    },
    DOMAIN_NOT_FOUND: {
        status: 404,
        data: z.object({
            domain: z.string()
        }),
        error: 'Domain not found'
    },
    POLICY_NOT_FOUND: {
        status: 404,
        data: z.object({
            policyId: z.string(),
            type: z.string()
        }),
        error: 'Policy not found or invalid'
    },
    PURPOSES_NOT_FOUND: {
        status: 404,
        data: z.object({
            preferences: z.array(z.string()),
            foundPurposes: z.array(z.string())
        }),
        error: 'Could not find all specified purposes'
    },
    COOKIE_BANNER_PREFERENCES_REQUIRED: {
        status: 400,
        data: z.object({
            type: z.literal('cookie_banner')
        }),
        error: 'Preferences are required for cookie banner consent'
    },
    NO_CONSENT_FOUND: {
        status: 404,
        data: z.object({
            policyId: z.string(),
            subjectId: z.string(),
            domainId: z.string()
        }),
        error: 'No consent found for the given policy'
    }
}).input(verifyConsentInputSchema).output(z.object({
    isValid: z.boolean(),
    reasons: z.array(z.string()).optional(),
    consent: verify_contract_consentSchema.optional()
}));
const consentContracts = {
    post: postConsentContract,
    showBanner: showConsentBannerContract,
    verify: verifyConsentContract,
    identify: identifyUserContract
};
const statusContract = oc.route({
    method: 'GET',
    path: '/status',
    description: `Returns the current operational status and health metrics of the service.
This endpoint provides real-time information about:
- Overall service status (ok/error)
- Current API version
- Server timestamp
- Storage system status and availability
- Client information (IP, User Agent, Region)

Use this endpoint for health checks, monitoring, and service status verification.`,
    tags: [
        'meta'
    ]
}).output(z.object({
    status: z["enum"]([
        'ok',
        'error'
    ]),
    version: z.string(),
    timestamp: z.date(),
    storage: z.object({
        type: z.string(),
        available: z.boolean()
    }),
    client: z.object({
        ip: z.string().nullable(),
        userAgent: z.string().nullable(),
        region: z.object({
            countryCode: z.string().nullable(),
            regionCode: z.string().nullable()
        })
    })
}));
const metaContracts = {
    status: statusContract
};
const contracts_config = {
    consent: consentContracts,
    meta: metaContracts
};
const os = implement(contracts_config);
const identifyUser = os.consent.identify.handler(async ({ input, context })=>{
    const typedContext = context;
    const { adapter, logger } = typedContext;
    logger.info('Handling identify-user request');
    const rawConsent = await adapter.findOne({
        model: 'consent',
        where: [
            {
                field: 'id',
                value: input.consentId
            }
        ]
    });
    const consent = rawConsent ? validateEntityOutput('consent', rawConsent, typedContext.options) : null;
    if (!consent) throw new ORPCError('CONSENT_NOT_FOUND', {
        data: {
            consentId: input.consentId
        }
    });
    await typedContext.adapter.transaction({
        callback: async (tx)=>{
            const existingSubject = await tx.findOne({
                model: 'subject',
                where: [
                    {
                        field: 'externalId',
                        value: input.externalId
                    },
                    {
                        field: 'id',
                        value: consent.subjectId,
                        connector: 'AND',
                        operator: 'ne'
                    }
                ]
            });
            if (existingSubject && 'id' in existingSubject) {
                const currentSubjectId = consent.subjectId;
                const oldSubjectId = existingSubject.id;
                logger.info('Merging subjects', {
                    currentSubjectId,
                    oldSubjectId,
                    externalId: input.externalId
                });
                await tx.updateMany({
                    model: 'consent',
                    where: [
                        {
                            field: 'subjectId',
                            value: currentSubjectId
                        }
                    ],
                    update: {
                        subjectId: oldSubjectId
                    }
                });
                await tx.updateMany({
                    model: 'consentRecord',
                    where: [
                        {
                            field: 'subjectId',
                            value: currentSubjectId
                        }
                    ],
                    update: {
                        subjectId: oldSubjectId
                    }
                });
                await tx.updateMany({
                    model: 'auditLog',
                    where: [
                        {
                            field: 'subjectId',
                            value: currentSubjectId
                        }
                    ],
                    update: {
                        subjectId: oldSubjectId
                    }
                });
                await tx.deleteMany({
                    model: 'subject',
                    where: [
                        {
                            field: 'id',
                            value: currentSubjectId
                        }
                    ]
                });
                await tx.create({
                    model: 'auditLog',
                    data: {
                        subjectId: oldSubjectId,
                        entityType: 'consent',
                        entityId: consent.id,
                        actionType: 'identify_user',
                        ipAddress: typedContext.ipAddress || null,
                        userAgent: typedContext.userAgent || null,
                        eventTimezone: 'UTC',
                        metadata: {
                            externalId: input.externalId,
                            mergedFrom: currentSubjectId
                        }
                    }
                });
            } else {
                await tx.update({
                    model: 'subject',
                    where: [
                        {
                            field: 'id',
                            value: consent.subjectId
                        }
                    ],
                    update: {
                        externalId: input.externalId,
                        identityProvider: input.identityProvider || 'external',
                        isIdentified: true,
                        updatedAt: new Date()
                    }
                });
                await tx.create({
                    model: 'auditLog',
                    data: {
                        subjectId: consent.subjectId,
                        entityType: 'consent',
                        entityId: consent.id,
                        actionType: 'identify_user',
                        ipAddress: typedContext.ipAddress || null,
                        userAgent: typedContext.userAgent || null,
                        eventTimezone: 'UTC',
                        metadata: {
                            externalId: input.externalId,
                            identityProvider: input.identityProvider || 'external'
                        }
                    }
                });
            }
        }
    });
    return {
        success: true
    };
});
const postConsent = os.consent.post.handler(async ({ input, context })=>{
    const typedContext = context;
    const logger = typedContext.logger;
    logger.info('Handling post-consent request');
    const { type, subjectId, externalSubjectId, identityProvider, domain, metadata, preferences } = input;
    logger.debug('Request parameters', {
        type,
        subjectId,
        externalSubjectId,
        identityProvider,
        domain
    });
    try {
        const subject = await typedContext.registry.findOrCreateSubject({
            subjectId,
            externalSubjectId,
            identityProvider,
            ipAddress: typedContext.ipAddress || 'unknown'
        });
        if (!subject) throw new ORPCError('SUBJECT_CREATION_FAILED', {
            data: {
                subjectId,
                externalSubjectId
            }
        });
        logger.debug('Subject found/created', {
            subjectId: subject.id
        });
        const domainRecord = await typedContext.registry.findOrCreateDomain(domain);
        if (!domainRecord) throw new ORPCError('DOMAIN_CREATION_FAILED', {
            data: {
                domain
            }
        });
        const now = new Date();
        let policyId;
        let purposeIds = [];
        if ('policyId' in input && input.policyId) {
            policyId = input.policyId;
            const policy = await typedContext.registry.findConsentPolicyById(policyId);
            if (!policy) throw new ORPCError('POLICY_NOT_FOUND', {
                data: {
                    policyId,
                    type
                }
            });
            if (!policy.isActive) throw new ORPCError('POLICY_INACTIVE', {
                data: {
                    policyId,
                    type
                }
            });
        } else {
            const policy = await typedContext.registry.findOrCreatePolicy(type);
            if (!policy) throw new ORPCError('POLICY_CREATION_FAILED', {
                data: {
                    type
                }
            });
            policyId = policy.id;
        }
        if (preferences) {
            const consentedPurposes = Object.entries(preferences).filter(([_, isConsented])=>isConsented).map(([purposeCode])=>purposeCode);
            const existingPurposes = await Promise.all(consentedPurposes.map((purposeCode)=>typedContext.registry.findConsentPurposeByCode(purposeCode)));
            const purposesToCreate = consentedPurposes.filter((_purposeCode, index)=>!existingPurposes[index]);
            const createdPurposes = await Promise.all(purposesToCreate.map((purposeCode)=>typedContext.registry.createConsentPurpose({
                    code: purposeCode,
                    name: purposeCode,
                    description: `Auto-created consentPurpose for ${purposeCode}`,
                    isActive: true,
                    isEssential: false,
                    legalBasis: 'consent',
                    createdAt: now,
                    updatedAt: now
                })));
            purposeIds = [
                ...existingPurposes.filter((p)=>null !== p).map((p)=>p.id),
                ...createdPurposes.filter((p)=>null !== p).map((p)=>p.id)
            ];
            if (purposeIds.length !== consentedPurposes.length) throw new ORPCError('PURPOSE_CREATION_FAILED', {
                data: {
                    purposeCode: purposesToCreate[purposeIds.length - consentedPurposes.length]
                }
            });
        }
        const result = await typedContext.adapter.transaction({
            callback: async (tx)=>{
                const consentRecord = await tx.create({
                    model: 'consent',
                    data: {
                        subjectId: subject.id,
                        domainId: domainRecord.id,
                        policyId,
                        purposeIds,
                        status: 'active',
                        isActive: true,
                        givenAt: now,
                        ipAddress: typedContext.ipAddress || null,
                        userAgent: typedContext.userAgent || null,
                        history: []
                    }
                });
                const record = await tx.create({
                    model: 'consentRecord',
                    data: {
                        subjectId: subject.id,
                        consentId: consentRecord.id,
                        actionType: 'consent_given',
                        details: metadata,
                        createdAt: now
                    }
                });
                await tx.create({
                    model: 'auditLog',
                    data: {
                        subjectId: subject.id,
                        entityType: 'consent',
                        entityId: consentRecord.id,
                        actionType: 'consent_given',
                        details: {
                            consentId: consentRecord.id,
                            type
                        },
                        timestamp: now,
                        ipAddress: typedContext.ipAddress || null,
                        userAgent: typedContext.userAgent || null
                    }
                });
                return {
                    consent: consentRecord,
                    record
                };
            }
        });
        if (!result || !result.consent || !result.record) throw new ORPCError('CONSENT_CREATION_FAILED', {
            data: {
                subjectId: subject.id,
                domain
            }
        });
        return {
            id: result.consent.id,
            subjectId: subject.id,
            externalSubjectId: subject.externalId ?? void 0,
            identityProvider: subject.identityProvider ?? void 0,
            domainId: domainRecord.id,
            domain: domainRecord.name,
            type,
            status: result.consent.status,
            recordId: result.record.id,
            metadata,
            givenAt: result.consent.givenAt
        };
    } catch (error) {
        logger.error('Error in post-consent handler', {
            error: error instanceof Error ? error.message : String(error),
            errorType: error instanceof Error ? error.constructor.name : typeof error
        });
        if (error instanceof ORPCError) throw error;
        throw new ORPCError('INTERNAL_SERVER_ERROR', {
            message: error instanceof Error ? error.message : String(error)
        });
    }
});
function checkJurisdiction(countryCode) {
    const jurisdictions = {
        EU: new Set([
            'AT',
            'BE',
            'BG',
            'HR',
            'CY',
            'CZ',
            'DK',
            'EE',
            'FI',
            'FR',
            'DE',
            'GR',
            'HU',
            'IE',
            'IT',
            'LV',
            'LT',
            'LU',
            'MT',
            'NL',
            'PL',
            'PT',
            'RO',
            'SK',
            'SI',
            'ES',
            'SE'
        ]),
        EEA: new Set([
            'IS',
            'NO',
            'LI'
        ]),
        UK: new Set([
            'GB'
        ]),
        CH: new Set([
            'CH'
        ]),
        BR: new Set([
            'BR'
        ]),
        CA: new Set([
            'CA'
        ]),
        AU: new Set([
            'AU'
        ]),
        JP: new Set([
            'JP'
        ]),
        KR: new Set([
            'KR'
        ])
    };
    let showConsentBanner = true;
    let jurisdictionCode = 'NONE';
    if (countryCode) {
        const normalizedCountryCode = countryCode.toUpperCase();
        showConsentBanner = false;
        const jurisdictionMap = [
            {
                sets: [
                    jurisdictions.EU,
                    jurisdictions.EEA,
                    jurisdictions.UK
                ],
                code: 'GDPR'
            },
            {
                sets: [
                    jurisdictions.CH
                ],
                code: 'CH'
            },
            {
                sets: [
                    jurisdictions.BR
                ],
                code: 'BR'
            },
            {
                sets: [
                    jurisdictions.CA
                ],
                code: 'PIPEDA'
            },
            {
                sets: [
                    jurisdictions.AU
                ],
                code: 'AU'
            },
            {
                sets: [
                    jurisdictions.JP
                ],
                code: 'APPI'
            },
            {
                sets: [
                    jurisdictions.KR
                ],
                code: 'PIPA'
            }
        ];
        for (const { sets, code } of jurisdictionMap)if (sets.some((set)=>set.has(normalizedCountryCode))) {
            jurisdictionCode = code;
            showConsentBanner = true;
            break;
        }
    }
    const message = JurisdictionMessages[jurisdictionCode];
    return {
        showConsentBanner,
        jurisdictionCode,
        message
    };
}
function isSupportedBaseLanguage(lang) {
    return lang in baseTranslations;
}
function getPreferredLanguage(acceptLanguage, supportedLanguages) {
    if (!acceptLanguage) return 'en';
    const primaryLang = acceptLanguage.split(',')[0]?.split(';')[0]?.split('-')[0]?.toLowerCase();
    if (primaryLang && supportedLanguages.includes(primaryLang)) return primaryLang;
    return 'en';
}
function getTranslations(acceptLanguage, customTranslations) {
    const supportedDefaultLanguages = Object.keys(baseTranslations);
    const supportedCustomLanguages = Object.keys(customTranslations || {});
    const supportedLanguages = [
        ...supportedDefaultLanguages,
        ...supportedCustomLanguages
    ];
    const preferredLanguage = getPreferredLanguage(acceptLanguage, supportedLanguages);
    const base = isSupportedBaseLanguage(preferredLanguage) ? baseTranslations[preferredLanguage] : baseTranslations.en;
    const custom = supportedCustomLanguages.includes(preferredLanguage) ? customTranslations?.[preferredLanguage] : {};
    const translations = custom ? deepMergeTranslations(base, custom) : base;
    return {
        translations: translations,
        language: preferredLanguage
    };
}
function getHeaders(headers) {
    if (!headers) return {
        countryCode: null,
        regionCode: null,
        acceptLanguage: null
    };
    const normalizeHeader = (value)=>{
        if (!value) return null;
        return Array.isArray(value) ? value[0] ?? null : value;
    };
    const countryCode = normalizeHeader(headers.get('x-c15t-country')) ?? normalizeHeader(headers.get('cf-ipcountry')) ?? normalizeHeader(headers.get('x-vercel-ip-country')) ?? normalizeHeader(headers.get('x-amz-cf-ipcountry')) ?? normalizeHeader(headers.get('x-country-code'));
    const regionCode = normalizeHeader(headers.get('x-c15t-region')) ?? normalizeHeader(headers.get('x-vercel-ip-country-region')) ?? normalizeHeader(headers.get('x-region-code'));
    const acceptLanguage = normalizeHeader(headers.get('accept-language'));
    return {
        countryCode,
        regionCode,
        acceptLanguage
    };
}
function buildResponse({ shouldShowBanner, jurisdiction, location, acceptLanguage, customTranslations, branding = 'c15t' }) {
    return {
        showConsentBanner: shouldShowBanner,
        jurisdiction,
        location,
        translations: getTranslations(acceptLanguage, customTranslations),
        branding
    };
}
const handler_showConsentBanner = os.consent.showBanner.handler(({ context })=>{
    const typedContext = context;
    const { customTranslations, disableGeoLocation, branding } = typedContext.options.advanced ?? {};
    const { countryCode, regionCode, acceptLanguage } = getHeaders(typedContext.headers);
    if (disableGeoLocation) return buildResponse({
        shouldShowBanner: true,
        jurisdiction: {
            code: 'NONE',
            message: JurisdictionMessages.NONE
        },
        location: {
            countryCode: null,
            regionCode: null
        },
        acceptLanguage,
        customTranslations,
        branding
    });
    const { showConsentBanner, jurisdictionCode, message } = checkJurisdiction(countryCode);
    return buildResponse({
        shouldShowBanner: showConsentBanner,
        jurisdiction: {
            code: jurisdictionCode,
            message
        },
        location: {
            countryCode,
            regionCode
        },
        acceptLanguage,
        customTranslations,
        branding
    });
});
const verifyConsent = os.consent.verify.handler(async ({ input, context })=>{
    const typedContext = context;
    const logger = typedContext.logger;
    logger.info('Handling verify-consent request');
    const { type, subjectId, externalSubjectId, domain, policyId, preferences } = input;
    logger.debug('Request parameters', {
        type,
        subjectId,
        externalSubjectId,
        domain,
        policyId,
        preferences
    });
    try {
        const subject = await typedContext.registry.findOrCreateSubject({
            subjectId,
            externalSubjectId,
            ipAddress: typedContext.ipAddress || 'unknown'
        });
        if (!subject) throw new ORPCError('SUBJECT_NOT_FOUND', {
            data: {
                subjectId,
                externalSubjectId
            }
        });
        const domainRecord = await typedContext.registry.findDomain(domain);
        if (!domainRecord) throw new ORPCError('DOMAIN_NOT_FOUND', {
            data: {
                domain
            }
        });
        if ('cookie_banner' === type && (!preferences || 0 === preferences.length)) throw new ORPCError('COOKIE_BANNER_PREFERENCES_REQUIRED', {
            data: {
                type: 'cookie_banner'
            }
        });
        const purposePromises = preferences?.map((purpose)=>typedContext.registry.findConsentPurposeByCode(purpose));
        const rawPurposes = await Promise.all(purposePromises ?? []);
        const purposeIds = rawPurposes.filter((purpose)=>null !== purpose).map((purpose)=>purpose.id);
        if (purposeIds.length !== (preferences?.length ?? 0)) throw new ORPCError('PURPOSES_NOT_FOUND', {
            data: {
                preferences: preferences ?? [],
                foundPurposes: rawPurposes.filter((p)=>null !== p).map((p)=>p.code)
            }
        });
        if (policyId) {
            const policy = await typedContext.registry.findConsentPolicyById(policyId);
            if (!policy || policy.type !== type) throw new ORPCError('POLICY_NOT_FOUND', {
                data: {
                    policyId,
                    type
                }
            });
            return await checkPolicyConsent({
                policyId: policy.id,
                subjectId: subject.id,
                domainId: domainRecord.id,
                purposeIds,
                type,
                context: typedContext
            });
        }
        const latestPolicy = await typedContext.registry.findOrCreatePolicy(type);
        if (!latestPolicy) throw new ORPCError('POLICY_NOT_FOUND', {
            data: {
                policyId: 'latest',
                type
            }
        });
        return await checkPolicyConsent({
            policyId: latestPolicy.id,
            subjectId: subject.id,
            domainId: domainRecord.id,
            purposeIds,
            type,
            context: typedContext
        });
    } catch (error) {
        logger.error('Error in verify-consent handler', {
            error: error instanceof Error ? error.message : String(error),
            errorType: error instanceof Error ? error.constructor.name : typeof error
        });
        if (error instanceof ORPCError) throw error;
        throw new ORPCError('INTERNAL_SERVER_ERROR', {
            message: error instanceof Error ? error.message : String(error)
        });
    }
});
async function checkPolicyConsent({ policyId, subjectId, domainId, purposeIds, type, context }) {
    const { registry, adapter } = context;
    const rawConsents = await adapter.findMany({
        model: 'consent',
        where: [
            {
                field: 'subjectId',
                value: subjectId
            },
            {
                field: 'policyId',
                value: policyId
            },
            {
                field: 'domainId',
                value: domainId
            }
        ],
        sortBy: {
            field: 'givenAt',
            direction: 'desc'
        }
    });
    const filteredConsents = rawConsents.filter((consent)=>{
        if (!purposeIds) return true;
        return purposeIds.every((id)=>consent.purposeIds.some((purposeId)=>purposeId === id));
    });
    await registry.createAuditLog({
        subjectId,
        entityType: 'consent_policy',
        entityId: policyId,
        actionType: 'verify_consent',
        metadata: {
            type,
            policyId,
            purposeIds,
            success: 0 !== filteredConsents.length,
            ...filteredConsents.length > 0 ? {
                consentId: filteredConsents[0]?.id
            } : {}
        }
    });
    if (0 === rawConsents.length) throw new ORPCError('NO_CONSENT_FOUND', {
        data: {
            policyId,
            subjectId,
            domainId
        }
    });
    if (0 === filteredConsents.length) throw new ORPCError('NO_CONSENT_FOUND', {
        data: {
            policyId,
            subjectId,
            domainId
        }
    });
    return {
        isValid: true,
        consent: filteredConsents[0]
    };
}
const consentHandlers = {
    post: postConsent,
    showBanner: handler_showConsentBanner,
    verify: verifyConsent,
    identify: identifyUser
};
const statusHandler = os.meta.status.handler(({ context })=>{
    const typedContext = context;
    const headers = typedContext.headers;
    const normalizeHeader = (value)=>{
        if (!value) return null;
        return Array.isArray(value) ? value[0] ?? null : value;
    };
    const countryCode = normalizeHeader(headers?.get('cf-ipcountry')) ?? normalizeHeader(headers?.get('x-vercel-ip-country')) ?? normalizeHeader(headers?.get('x-amz-cf-ipcountry')) ?? normalizeHeader(headers?.get('x-country-code'));
    const regionCode = normalizeHeader(headers?.get('x-vercel-ip-country-region')) ?? normalizeHeader(headers?.get('x-region-code'));
    return {
        status: 'ok',
        version: "1.8.0",
        timestamp: new Date(),
        storage: {
            type: typedContext.adapter?.id ?? 'MemoryAdapter',
            available: !!typedContext.adapter
        },
        client: {
            ip: typedContext.ipAddress ?? null,
            userAgent: typedContext.userAgent ?? null,
            region: {
                countryCode,
                regionCode
            }
        }
    };
});
const metaHandlers = {
    status: statusHandler
};
const router = os.router({
    consent: consentHandlers,
    meta: metaHandlers
});
const mergeOpenAPIOptions = (defaultOptions, userOptions)=>{
    const merged = {
        ...defaultOptions
    };
    if (userOptions.info && 'object' == typeof userOptions.info) merged.info = {
        ...merged.info,
        ...userOptions.info
    };
    for (const [key, value] of Object.entries(userOptions))if ('info' !== key) merged[key] = value;
    return merged;
};
const createOpenAPISpec = (context, options)=>{
    const openAPIGenerator = new OpenAPIGenerator({
        schemaConverters: [
            new ZodToJsonSchemaConverter()
        ]
    });
    const getOpenAPISpec = async ()=>{
        if (getOpenAPISpec.cached) return getOpenAPISpec.cached;
        const defaultOptions = createDefaultOpenAPIOptions(options);
        const mergedOptions = options.openapi?.options ? mergeOpenAPIOptions(defaultOptions, options.openapi.options) : defaultOptions;
        try {
            const spec = await openAPIGenerator.generate(router, mergedOptions);
            getOpenAPISpec.cached = spec;
            return spec;
        } catch (error) {
            context.logger?.error('Failed to generate OpenAPI spec:', error);
            return {
                openapi: '3.0.0',
                info: {
                    title: options.appName || 'c15t API',
                    version: '0.0.0'
                },
                paths: {}
            };
        }
    };
    return getOpenAPISpec;
};
const createDocsUI = (options)=>{
    const config = createOpenAPIConfig(options);
    if (config.customUiTemplate) return config.customUiTemplate;
    return `
    <!doctype html>
    <html>
      <head>
        <title>${options.appName || 'c15t API'} Documentation</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" type="image/svg+xml" href="https://c15t.com/icon.svg" />
      </head>
      <body>
        <script
          id="api-reference"
          data-url="${encodeURI(config.specPath)}">
        </script>
        <script src="https://cdn.jsdelivr.net/npm/@scalar/api-reference"></script>
      </body>
    </html>
  `;
};
const API_ROUTER_TRACER_NAME = '@doubletie/api-router';
const getTracer = (options)=>{
    if (options?.telemetry?.tracer) return options.telemetry.tracer;
    return trace.getTracer(API_ROUTER_TRACER_NAME);
};
const createRequestSpan = (method, path, options)=>{
    if (options?.telemetry?.disabled) return null;
    const tracer = getTracer(options);
    const span = tracer.startSpan(`${method} ${path}`, {
        attributes: {
            'http.method': method,
            'http.path': path,
            ...options?.telemetry?.defaultAttributes || {}
        }
    });
    return span;
};
const withRequestSpan = async (method, path, operation, options)=>{
    const span = createRequestSpan(method, path, options);
    if (!span) return operation();
    try {
        const result = await operation();
        span.setStatus({
            code: SpanStatusCode.OK
        });
        return result;
    } catch (error) {
        handleSpanError(span, error);
        throw error;
    } finally{
        span.end();
    }
};
const handleSpanError = (span, error)=>{
    span.setStatus({
        code: SpanStatusCode.ERROR,
        message: error instanceof Error ? error.message : String(error)
    });
    if (error instanceof Error) {
        span.setAttribute('error.type', error.name);
        span.setAttribute('error.message', error.message);
        if (error.stack) span.setAttribute('error.stack', error.stack);
    }
};
const DEFAULT_IP_HEADERS = [
    'x-client-ip',
    'x-forwarded-for',
    'cf-connecting-ip',
    'fastly-client-ip',
    'x-real-ip',
    'x-cluster-client-ip',
    'x-forwarded',
    'forwarded-for',
    'forwarded'
];
function getIp(req, options) {
    const advanced = options.advanced || {};
    if (advanced?.ipAddress?.disableIpTracking) return null;
    const testIP = '127.0.0.1';
    if (isTest) return testIP;
    const ipHeaders = advanced?.ipAddress?.ipAddressHeaders || DEFAULT_IP_HEADERS;
    const headers = req instanceof Request ? req.headers : req;
    for (const key of ipHeaders){
        const value = headers.get(key);
        if (value) {
            const ip = value.split(',')[0]?.trim();
            if (ip) return ip;
        }
    }
    return null;
}
const c15tInstance = (options)=>{
    const contextPromise = init(options);
    const corsOptions = createCORSOptions(options.trustedOrigins);
    const rpcHandler = new OpenAPIHandler(router, {
        plugins: [
            new CORSPlugin(corsOptions)
        ]
    });
    const openApiConfig = createOpenAPIConfig(options);
    const getDocsUI = ()=>createDocsUI(options);
    const processIp = (request, context)=>{
        const ip = getIp(request, options);
        if (ip) context.ipAddress = ip;
        return context;
    };
    const processTelemetry = (request, context)=>{
        const url = new URL(request.url);
        const path = url.pathname;
        const method = request.method;
        withRequestSpan(method, path, async ()=>{}, options);
        context.path = path;
        context.method = method;
        context.headers = request.headers;
        context.userAgent = request.headers.get('user-agent') || void 0;
        return context;
    };
    const handleOpenApiSpecRequest = async (url)=>{
        if (openApiConfig.enabled && url.pathname === openApiConfig.specPath) {
            const ctxResult = await contextPromise;
            if (!ctxResult.isOk()) throw ctxResult.error;
            const ctx = ctxResult.value;
            const orpcContext = {
                adapter: ctx.adapter,
                registry: ctx.registry,
                logger: ctx.logger,
                generateId: ctx.generateId,
                headers: new Headers(),
                appName: options.appName || 'c15t',
                options,
                trustedOrigins: options.trustedOrigins || [],
                baseURL: options.baseURL || '/',
                tables: ctx.tables
            };
            const getOpenAPISpec = createOpenAPISpec(orpcContext, options);
            const spec = await getOpenAPISpec();
            return new Response(JSON.stringify(spec), {
                status: 200,
                headers: {
                    'Content-Type': 'application/json'
                }
            });
        }
        return null;
    };
    const handleDocsUiRequest = (url)=>{
        if (openApiConfig.enabled && url.pathname === openApiConfig.docsPath) {
            const html = getDocsUI();
            return new Response(html, {
                status: 200,
                headers: {
                    'Content-Type': 'text/html',
                    'Content-Security-Policy': "default-src 'self'; script-src 'self' https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net;"
                }
            });
        }
        return null;
    };
    const createDoubleTieErrorResponse = (error)=>{
        const sanitizedMessage = error.message.replace(/[^\w\s.,;:!?()[\]{}'"+-]/g, '');
        return new Response(JSON.stringify({
            code: error.code,
            message: sanitizedMessage,
            data: error.meta,
            status: error.statusCode,
            defined: true
        }), {
            status: error.statusCode,
            headers: {
                'Content-Type': 'application/json'
            }
        });
    };
    const createUnknownErrorResponse = (error)=>{
        const message = error instanceof Error ? error.message : String(error);
        let status = 500;
        if (error instanceof Error && 'status' in error) {
            const statusValue = error.status;
            if ('number' == typeof statusValue && statusValue >= 100 && statusValue < 600) status = statusValue;
        }
        return new Response(JSON.stringify({
            code: error_codes_ERROR_CODES.INTERNAL_SERVER_ERROR,
            message,
            status,
            defined: true,
            data: {}
        }), {
            status,
            headers: {
                'Content-Type': 'application/json'
            }
        });
    };
    const handleApiRequest = async (request, ctx)=>{
        const orpcContext = {
            adapter: ctx.adapter,
            registry: ctx.registry,
            logger: ctx.logger,
            generateId: ctx.generateId,
            headers: request.headers,
            userAgent: request.headers.get('user-agent') || void 0,
            appName: options.appName || 'c15t',
            options: ctx.options,
            trustedOrigins: options.trustedOrigins || [],
            baseURL: options.baseURL || '/',
            tables: ctx.tables
        };
        processIp(request, orpcContext);
        processCors(request, orpcContext, options.trustedOrigins);
        processTelemetry(request, orpcContext);
        const handlerContext = orpcContext;
        orpcContext.logger.debug?.('Handling prefix', {
            prefix: options.basePath || '/'
        });
        const { matched, response } = await rpcHandler.handle(request, {
            prefix: options.basePath || '/',
            context: handlerContext
        });
        if (matched && response) {
            orpcContext.logger.debug('Handler matched', {
                request,
                matched,
                response
            });
            return response;
        }
        orpcContext.logger.debug('No handler matched', {
            request,
            matched,
            response
        });
        return new Response('Not Found', {
            status: 404
        });
    };
    const handler = async (request, ctxOverride)=>{
        try {
            const url = new URL(request.url);
            createLogger(options.logger)?.debug?.('Incoming request', {
                method: request.method,
                pathname: url.pathname
            });
            const openApiResponse = await handleOpenApiSpecRequest(url);
            if (openApiResponse) return openApiResponse;
            const docsResponse = handleDocsUiRequest(url);
            if (docsResponse) return docsResponse;
            const ctxResult = await contextPromise;
            if (!ctxResult.isOk()) throw ctxResult.error;
            const ctx = defu_0(ctxOverride || {}, ctxResult.value);
            const basePath = options.basePath || options.baseURL || '/';
            createLogger(options.logger)?.debug?.('[c15t] Using basePath/baseURL', {
                basePath
            });
            createLogger(options.logger)?.debug?.('[c15t] Routing request', {
                method: request.method,
                url: request.url,
                prefix: basePath
            });
            return await handleApiRequest(request, ctx);
        } catch (error) {
            const logger = options.logger ? createLogger(options.logger) : console;
            logger.error('Request handling error:', error);
            if (error instanceof error_class_DoubleTieError) return createDoubleTieErrorResponse(error);
            return createUnknownErrorResponse(error);
        }
    };
    const createNextHandlers = ()=>{
        const nextHandler = async (request)=>await handler(request);
        return {
            GET: nextHandler,
            POST: nextHandler,
            PUT: nextHandler,
            PATCH: nextHandler,
            DELETE: nextHandler,
            OPTIONS: nextHandler,
            HEAD: nextHandler
        };
    };
    return {
        options,
        $context: contextPromise.then((result)=>{
            if (!result.isOk()) throw result.error;
            return result.value;
        }),
        router: router,
        handler,
        ...createNextHandlers(),
        getOpenAPISpec: async ()=>{
            const ctxResult = await contextPromise;
            if (!ctxResult.isOk()) throw ctxResult.error;
            const ctx = ctxResult.value;
            const orpcContext = {
                adapter: ctx.adapter,
                registry: ctx.registry,
                logger: ctx.logger,
                generateId: ctx.generateId,
                headers: new Headers(),
                appName: options.appName || 'c15t',
                options,
                trustedOrigins: options.trustedOrigins || [],
                baseURL: options.baseURL || '/',
                tables: ctx.tables
            };
            const getOpenAPISpec = createOpenAPISpec(orpcContext, options);
            return getOpenAPISpec();
        },
        getDocsUI
    };
};
var __webpack_exports__version = "1.8.0";
export { c15tInstance, __webpack_exports__version as version };
