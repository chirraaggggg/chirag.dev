import { implement } from "@orpc/server";
import { oc } from "@orpc/contract";
import { z } from "zod";
import { fumadb } from "fumadb";
import { column, idColumn, schema, table } from "fumadb/schema";
const identifyUserSchema = z.object({
    consentId: z.string(),
    externalId: z.string(),
    identityProvider: z.string().optional()
});
const identifyUserContract = oc.route({
    method: 'PATCH',
    path: '/consent/identify',
    description: "Links a subject's external ID to a consent record by consent ID. This is used to identify a user across multiple devices and sessions.",
    tags: [
        'consent',
        'cookie-banner'
    ]
}).errors({
    CONSENT_NOT_FOUND: {
        status: 404,
        data: z.object({
            consentId: z.string()
        }),
        error: 'Consent not found'
    },
    IDENTIFICATION_FAILED: {
        status: 500,
        data: z.object({
            consentId: z.string()
        }),
        error: 'Failed to identify user'
    }
}).input(identifyUserSchema).output(z.object({
    success: z.boolean()
}));
const auditLogTable = table('auditLog', {
    id: idColumn('id', 'varchar(255)'),
    entityType: column('entityType', 'string'),
    entityId: column('entityId', 'string'),
    actionType: column('actionType', 'string'),
    subjectId: column('subjectId', 'string').nullable(),
    ipAddress: column('ipAddress', 'string').nullable(),
    userAgent: column('userAgent', 'string').nullable(),
    changes: column('changes', 'json').nullable(),
    metadata: column('metadata', 'json').nullable(),
    createdAt: column('createdAt', 'timestamp').defaultTo$('now'),
    eventTimezone: column('eventTimezone', 'string').defaultTo$(()=>'UTC')
});
z.object({
    id: z.string(),
    entityType: z.string(),
    entityId: z.string(),
    actionType: z.string(),
    subjectId: z.string().optional(),
    ipAddress: z.string().optional(),
    userAgent: z.string().optional(),
    changes: z.record(z.string(), z.unknown()).optional(),
    metadata: z.record(z.string(), z.unknown()).optional(),
    createdAt: z.date().prefault(()=>new Date()),
    eventTimezone: z.string().prefault('UTC')
});
const consentTable = table('consent', {
    id: idColumn('id', 'varchar(255)'),
    subjectId: column('subjectId', 'string'),
    domainId: column('domainId', 'string'),
    policyId: column('policyId', 'string').nullable(),
    purposeIds: column('purposeIds', 'json'),
    metadata: column('metadata', 'json').nullable(),
    ipAddress: column('ipAddress', 'string').nullable(),
    userAgent: column('userAgent', 'string').nullable(),
    status: column('status', 'string').defaultTo$(()=>'active'),
    withdrawalReason: column('withdrawalReason', 'string').nullable(),
    givenAt: column('givenAt', 'timestamp').defaultTo$('now'),
    validUntil: column('validUntil', 'timestamp').nullable(),
    isActive: column('isActive', 'bool').defaultTo$(()=>true)
});
const consentStatusSchema = z["enum"]([
    'active',
    'withdrawn',
    'expired'
]);
z.object({
    id: z.string(),
    subjectId: z.string(),
    domainId: z.string(),
    purposeIds: z.array(z.string()),
    metadata: z.record(z.string(), z.unknown()).nullish(),
    policyId: z.string().optional(),
    ipAddress: z.string().nullish(),
    userAgent: z.string().nullish(),
    status: consentStatusSchema.prefault('active'),
    withdrawalReason: z.string().nullish(),
    givenAt: z.date().prefault(()=>new Date()),
    validUntil: z.date().nullish(),
    isActive: z.boolean().prefault(true)
});
const consentPolicyTable = table('consentPolicy', {
    id: idColumn('id', 'varchar(255)'),
    version: column('version', 'string'),
    type: column('type', 'string'),
    name: column('name', 'string'),
    effectiveDate: column('effectiveDate', 'timestamp'),
    expirationDate: column('expirationDate', 'timestamp').nullable(),
    content: column('content', 'string'),
    contentHash: column('contentHash', 'string'),
    isActive: column('isActive', 'bool').defaultTo$(()=>true),
    createdAt: column('createdAt', 'timestamp').defaultTo$('now')
});
const PolicyTypeSchema = z["enum"]([
    'cookie_banner',
    'privacy_policy',
    'dpa',
    'terms_and_conditions',
    'marketing_communications',
    'age_verification',
    'other'
]);
z.object({
    id: z.string(),
    version: z.string(),
    type: PolicyTypeSchema,
    name: z.string(),
    effectiveDate: z.date(),
    expirationDate: z.date().nullish(),
    content: z.string(),
    contentHash: z.string(),
    isActive: z.boolean().prefault(true),
    createdAt: z.date().prefault(()=>new Date())
});
const consentPurposeTable = table('consentPurpose', {
    id: idColumn('id', 'varchar(255)'),
    code: column('code', 'string'),
    name: column('name', 'string'),
    description: column("description", 'string'),
    isEssential: column('isEssential', 'bool'),
    dataCategory: column('dataCategory', 'string').nullable(),
    legalBasis: column('legalBasis', 'string').nullable(),
    isActive: column('isActive', 'bool').defaultTo$(()=>true),
    createdAt: column('createdAt', 'timestamp').defaultTo$('now'),
    updatedAt: column('updatedAt', 'timestamp').defaultTo$('now')
});
z.object({
    id: z.string(),
    code: z.string(),
    name: z.string(),
    description: z.string(),
    isEssential: z.boolean(),
    dataCategory: z.string().nullish(),
    legalBasis: z.string().nullish(),
    isActive: z.boolean().prefault(true),
    createdAt: z.date().prefault(()=>new Date()),
    updatedAt: z.date().prefault(()=>new Date())
});
const consentRecordTable = table('consentRecord', {
    id: idColumn('id', 'varchar(255)'),
    subjectId: column('subjectId', 'string'),
    consentId: column('consentId', 'string').nullable(),
    actionType: column('actionType', 'string'),
    details: column('details', 'json').nullable(),
    createdAt: column('createdAt', 'timestamp').defaultTo$('now')
});
z.object({
    id: z.string(),
    subjectId: z.string(),
    consentId: z.string().nullish(),
    actionType: z.string(),
    details: z.record(z.string(), z.unknown()).nullish(),
    createdAt: z.date().prefault(()=>new Date())
});
const domainTable = table('domain', {
    id: idColumn('id', 'varchar(255)'),
    name: column('name', 'string').unique(),
    description: column("description", 'string').nullable(),
    allowedOrigins: column('allowedOrigins', 'json').nullable(),
    isVerified: column('isVerified', 'bool').defaultTo$(()=>true),
    isActive: column('isActive', 'bool').defaultTo$(()=>true),
    createdAt: column('createdAt', 'timestamp').defaultTo$('now'),
    updatedAt: column('updatedAt', 'timestamp').defaultTo$('now')
});
z.object({
    id: z.string(),
    name: z.string(),
    description: z.string().nullish(),
    allowedOrigins: z.array(z.string()).nullish(),
    isVerified: z.boolean().prefault(true),
    isActive: z.boolean().prefault(true),
    createdAt: z.date().prefault(()=>new Date()),
    updatedAt: z.date().prefault(()=>new Date())
});
const subjectTable = table('subject', {
    id: idColumn('id', 'varchar(255)'),
    isIdentified: column('isIdentified', 'bool').defaultTo$(()=>false),
    externalId: column('externalId', 'string').nullable(),
    identityProvider: column('identityProvider', 'string').nullable(),
    lastIpAddress: column('lastIpAddress', 'string').nullable(),
    subjectTimezone: column('subjectTimezone', 'string').nullable(),
    createdAt: column('createdAt', 'timestamp').defaultTo$('now'),
    updatedAt: column('updatedAt', 'timestamp').defaultTo$('now')
});
z.object({
    id: z.string(),
    isIdentified: z.boolean().prefault(false),
    externalId: z.string().nullish(),
    identityProvider: z.string().nullish(),
    lastIpAddress: z.string().optional(),
    subjectTimezone: z.string().nullish(),
    createdAt: z.date().prefault(()=>new Date()),
    updatedAt: z.date().prefault(()=>new Date())
});
const v1 = schema({
    version: '1.0.0',
    tables: {
        subject: subjectTable,
        domain: domainTable,
        consentPolicy: consentPolicyTable,
        consentPurpose: consentPurposeTable,
        consent: consentTable,
        auditLog: auditLogTable,
        consentRecord: consentRecordTable
    },
    relations: {
        subject: ({ many })=>({
                consents: many('consent'),
                consentRecords: many('consentRecord'),
                auditLogs: many('auditLog')
            }),
        domain: ({ many })=>({
                consents: many('consent')
            }),
        consentPolicy: ({ many })=>({
                consents: many('consent')
            }),
        consentPurpose: ()=>({}),
        consent: ({ one, many })=>({
                subject: one('subject', [
                    'subjectId',
                    'id'
                ]).foreignKey(),
                domain: one('domain', [
                    'domainId',
                    'id'
                ]).foreignKey(),
                policy: one('consentPolicy', [
                    'policyId',
                    'id'
                ]).foreignKey(),
                consentRecords: many('consentRecord')
            }),
        consentRecord: ({ one })=>({
                subject: one('subject', [
                    'subjectId',
                    'id'
                ]).foreignKey(),
                consent: one('consent', [
                    'consentId',
                    'id'
                ]).foreignKey()
            }),
        auditLog: ({ one })=>({
                subject: one('subject', [
                    'subjectId',
                    'id'
                ]).foreignKey()
            })
    }
});
fumadb({
    namespace: 'c15t',
    schemas: [
        v1
    ]
});
const baseConsentSchema = z.object({
    subjectId: z.string().optional(),
    externalSubjectId: z.string().optional(),
    identityProvider: z.string().optional(),
    domain: z.string(),
    type: PolicyTypeSchema,
    metadata: z.record(z.string(), z.unknown()).optional()
});
const cookieBannerSchema = baseConsentSchema.extend({
    type: z.literal('cookie_banner'),
    preferences: z.record(z.string(), z.boolean())
});
const policyBasedSchema = baseConsentSchema.extend({
    type: z["enum"]([
        'privacy_policy',
        'dpa',
        'terms_and_conditions'
    ]),
    policyId: z.string().optional(),
    preferences: z.record(z.string(), z.boolean()).optional()
});
const otherConsentSchema = baseConsentSchema.extend({
    type: z["enum"]([
        'marketing_communications',
        'age_verification',
        'other'
    ]),
    preferences: z.record(z.string(), z.boolean()).optional()
});
const postConsentContract = oc.route({
    method: 'POST',
    path: '/consent/set',
    description: `Records a user's consent preferences and creates necessary consent records.
This endpoint handles various types of consent submissions:

1. Cookie Banner Consent:
   - Records granular cookie preferences
   - Supports multiple consent purposes
   - Creates audit trail for compliance

2. Policy-Based Consent:
   - Privacy Policy acceptance
   - Data Processing Agreement (DPA) consent
   - Terms and Conditions acceptance
   - Links consent to specific policy versions

3. Other Consent Types:
   - Marketing communications preferences
   - Age verification consent
   - Custom consent types

The endpoint performs the following operations:
- Creates or retrieves subject records
- Validates domain and policy information
- Creates consent records with audit trails
- Records consent purposes and preferences
- Generates audit logs for compliance

Use this endpoint to record user consent and maintain a compliant consent management system.`,
    tags: [
        'consent',
        'cookie-banner'
    ]
}).errors({
    INPUT_VALIDATION_FAILED: {
        status: 422,
        data: z.object({
            formErrors: z.array(z.string()),
            fieldErrors: z.record(z.string(), z.array(z.string()))
        }),
        error: 'Invalid input parameters'
    },
    SUBJECT_CREATION_FAILED: {
        status: 400,
        data: z.object({
            subjectId: z.string().optional(),
            externalSubjectId: z.string().optional()
        }),
        error: 'Failed to create or find subject'
    },
    DOMAIN_CREATION_FAILED: {
        status: 500,
        data: z.object({
            domain: z.string()
        }),
        error: 'Failed to create or find domain'
    },
    POLICY_NOT_FOUND: {
        status: 404,
        data: z.object({
            policyId: z.string(),
            type: z.string()
        }),
        error: 'Policy not found'
    },
    POLICY_INACTIVE: {
        status: 409,
        data: z.object({
            policyId: z.string(),
            type: z.string()
        }),
        error: 'Policy is not active'
    },
    POLICY_CREATION_FAILED: {
        status: 500,
        data: z.object({
            type: z.string()
        }),
        error: 'Failed to create or find policy'
    },
    PURPOSE_CREATION_FAILED: {
        status: 500,
        data: z.object({
            purposeCode: z.string()
        }),
        error: 'Failed to create consent purpose'
    },
    CONSENT_CREATION_FAILED: {
        status: 500,
        data: z.object({
            subjectId: z.string(),
            domain: z.string()
        }),
        error: 'Failed to create consent record'
    }
}).input(z.discriminatedUnion('type', [
    cookieBannerSchema,
    policyBasedSchema,
    otherConsentSchema
])).output(z.object({
    id: z.string(),
    subjectId: z.string().optional(),
    externalSubjectId: z.string().optional(),
    domainId: z.string(),
    domain: z.string(),
    type: PolicyTypeSchema,
    status: z.string(),
    recordId: z.string(),
    metadata: z.record(z.string(), z.unknown()).optional(),
    givenAt: z.date()
}));
const branding = [
    'c15t',
    'consent',
    'none'
];
const JurisdictionCodeSchema = z["enum"]([
    'GDPR',
    'CH',
    'BR',
    'PIPEDA',
    'AU',
    'APPI',
    'PIPA',
    'NONE'
]);
const JurisdictionInfoSchema = z.object({
    code: JurisdictionCodeSchema,
    message: z.string()
});
const TitleDescriptionSchema = z.object({
    title: z.string(),
    description: z.string()
});
const CompleteTranslationsSchema = z.object({
    common: z.object({
        acceptAll: z.string(),
        rejectAll: z.string(),
        customize: z.string(),
        save: z.string()
    }),
    cookieBanner: TitleDescriptionSchema,
    consentManagerDialog: TitleDescriptionSchema,
    consentTypes: z.object({
        experience: TitleDescriptionSchema,
        functionality: TitleDescriptionSchema,
        marketing: TitleDescriptionSchema,
        measurement: TitleDescriptionSchema,
        necessary: TitleDescriptionSchema
    }),
    frame: z.object({
        title: z.string(),
        actionButton: z.string()
    }),
    legalLinks: z.object({
        privacyPolicy: z.string(),
        termsOfService: z.string(),
        cookiePolicy: z.string()
    })
});
const PartialTranslationsSchema = z.object({
    common: z.object({
        acceptAll: z.string().optional(),
        rejectAll: z.string().optional(),
        customize: z.string().optional(),
        save: z.string().optional()
    }).partial(),
    cookieBanner: TitleDescriptionSchema.partial(),
    consentManagerDialog: TitleDescriptionSchema.partial(),
    consentTypes: z.object({
        experience: TitleDescriptionSchema.partial(),
        functionality: TitleDescriptionSchema.partial(),
        marketing: TitleDescriptionSchema.partial(),
        measurement: TitleDescriptionSchema.partial(),
        necessary: TitleDescriptionSchema.partial()
    }).partial(),
    frame: z.object({
        title: z.string().optional(),
        actionButton: z.string().optional()
    }).partial().optional(),
    legalLinks: z.object({
        privacyPolicy: z.string().optional(),
        termsOfService: z.string().optional(),
        cookiePolicy: z.string().optional()
    }).partial().optional()
});
const TranslationsSchema = z.union([
    CompleteTranslationsSchema,
    PartialTranslationsSchema
]);
const showConsentBannerContract = oc.route({
    method: 'GET',
    path: '/show-consent-banner',
    description: `Determines if a user should see a consent banner based on their location and applicable privacy regulations.
This endpoint performs the following checks:

1. Detects the user's location using various header information:
   - Cloudflare country headers
   - Vercel IP country headers
   - AWS CloudFront headers
   - Custom country code headers

2. Determines the applicable jurisdiction based on the location:
   - GDPR (EU/EEA/UK)
   - Swiss Data Protection Act
   - LGPD (Brazil)
   - PIPEDA (Canada)
   - Australian Privacy Principles
   - APPI (Japan)
   - PIPA (South Korea)

3. Returns detailed information about:
   - Whether to show the consent banner
   - The applicable jurisdiction and its requirements
   - The user's detected location (country and region)

Use this endpoint to implement geo-targeted consent banners and ensure compliance with regional privacy regulations.`,
    tags: [
        'cookie-banner'
    ]
}).output(z.object({
    showConsentBanner: z.boolean(),
    jurisdiction: JurisdictionInfoSchema,
    location: z.object({
        countryCode: z.string().nullable(),
        regionCode: z.string().nullable()
    }),
    translations: z.object({
        language: z.string(),
        translations: TranslationsSchema
    }),
    branding: z["enum"](branding)
}));
const verifyConsentInputSchema = z.strictObject({
    subjectId: z.string().optional(),
    externalSubjectId: z.string().optional(),
    domain: z.string(),
    type: PolicyTypeSchema,
    policyId: z.string().optional(),
    preferences: z.array(z.string()).optional()
});
const verify_contract_consentSchema = z.looseObject({
    id: z.string(),
    purposeIds: z.array(z.string())
});
const verifyConsentContract = oc.route({
    method: 'POST',
    path: '/consent/verify',
    description: `Verifies if a user has given valid consent for a specific policy and domain.
This endpoint performs comprehensive consent verification by:

1. Validating the subject's identity (using subjectId or externalSubjectId)
2. Verifying the domain's existence and validity
3. Checking if the specified policy exists and is active
4. Validating that all required purposes have been consented to
5. Ensuring the consent record is current and valid

The endpoint supports different types of consent verification:
- Cookie banner consent verification
- Privacy policy consent verification
- Terms and conditions verification
- Marketing communications consent verification
- Age verification
- Custom consent types

Use this endpoint to ensure compliance with privacy regulations and to verify user consent before processing personal data.`,
    tags: [
        'consent'
    ]
}).errors({
    INPUT_VALIDATION_FAILED: {
        status: 422,
        data: z.object({
            formErrors: z.array(z.string()),
            fieldErrors: z.record(z.string(), z.array(z.string()).optional())
        }),
        error: 'Invalid input parameters'
    },
    SUBJECT_NOT_FOUND: {
        status: 404,
        data: z.object({
            subjectId: z.string().optional(),
            externalSubjectId: z.string().optional()
        }),
        error: 'Subject not found'
    },
    DOMAIN_NOT_FOUND: {
        status: 404,
        data: z.object({
            domain: z.string()
        }),
        error: 'Domain not found'
    },
    POLICY_NOT_FOUND: {
        status: 404,
        data: z.object({
            policyId: z.string(),
            type: z.string()
        }),
        error: 'Policy not found or invalid'
    },
    PURPOSES_NOT_FOUND: {
        status: 404,
        data: z.object({
            preferences: z.array(z.string()),
            foundPurposes: z.array(z.string())
        }),
        error: 'Could not find all specified purposes'
    },
    COOKIE_BANNER_PREFERENCES_REQUIRED: {
        status: 400,
        data: z.object({
            type: z.literal('cookie_banner')
        }),
        error: 'Preferences are required for cookie banner consent'
    },
    NO_CONSENT_FOUND: {
        status: 404,
        data: z.object({
            policyId: z.string(),
            subjectId: z.string(),
            domainId: z.string()
        }),
        error: 'No consent found for the given policy'
    }
}).input(verifyConsentInputSchema).output(z.object({
    isValid: z.boolean(),
    reasons: z.array(z.string()).optional(),
    consent: verify_contract_consentSchema.optional()
}));
const consentContracts = {
    post: postConsentContract,
    showBanner: showConsentBannerContract,
    verify: verifyConsentContract,
    identify: identifyUserContract
};
const statusContract = oc.route({
    method: 'GET',
    path: '/status',
    description: `Returns the current operational status and health metrics of the service.
This endpoint provides real-time information about:
- Overall service status (ok/error)
- Current API version
- Server timestamp
- Storage system status and availability
- Client information (IP, User Agent, Region)

Use this endpoint for health checks, monitoring, and service status verification.`,
    tags: [
        'meta'
    ]
}).output(z.object({
    status: z["enum"]([
        'ok',
        'error'
    ]),
    version: z.string(),
    timestamp: z.date(),
    client: z.object({
        ip: z.string().nullable(),
        userAgent: z.string().nullable(),
        region: z.object({
            countryCode: z.string().nullable(),
            regionCode: z.string().nullable()
        })
    })
}));
const metaContracts = {
    status: statusContract
};
const config = {
    consent: consentContracts,
    meta: metaContracts
};
const os = implement(config);
export { config as contracts, os };
