import { ORPCError, implement } from "@orpc/server";
import { oc } from "@orpc/contract";
import { z } from "zod";
import { fumadb } from "fumadb";
import { column, idColumn, schema, table } from "fumadb/schema";
import base_x from "base-x";
import { baseTranslations, deepMergeTranslations } from "@c15t/translations";
const identifyUserSchema = z.object({
    consentId: z.string(),
    externalId: z.string(),
    identityProvider: z.string().optional()
});
const identifyUserContract = oc.route({
    method: 'PATCH',
    path: '/consent/identify',
    description: "Links a subject's external ID to a consent record by consent ID. This is used to identify a user across multiple devices and sessions.",
    tags: [
        'consent',
        'cookie-banner'
    ]
}).errors({
    CONSENT_NOT_FOUND: {
        status: 404,
        data: z.object({
            consentId: z.string()
        }),
        error: 'Consent not found'
    },
    IDENTIFICATION_FAILED: {
        status: 500,
        data: z.object({
            consentId: z.string()
        }),
        error: 'Failed to identify user'
    }
}).input(identifyUserSchema).output(z.object({
    success: z.boolean()
}));
const auditLogTable = table('auditLog', {
    id: idColumn('id', 'varchar(255)'),
    entityType: column('entityType', 'string'),
    entityId: column('entityId', 'string'),
    actionType: column('actionType', 'string'),
    subjectId: column('subjectId', 'string').nullable(),
    ipAddress: column('ipAddress', 'string').nullable(),
    userAgent: column('userAgent', 'string').nullable(),
    changes: column('changes', 'json').nullable(),
    metadata: column('metadata', 'json').nullable(),
    createdAt: column('createdAt', 'timestamp').defaultTo$('now'),
    eventTimezone: column('eventTimezone', 'string').defaultTo$(()=>'UTC')
});
z.object({
    id: z.string(),
    entityType: z.string(),
    entityId: z.string(),
    actionType: z.string(),
    subjectId: z.string().optional(),
    ipAddress: z.string().optional(),
    userAgent: z.string().optional(),
    changes: z.record(z.string(), z.unknown()).optional(),
    metadata: z.record(z.string(), z.unknown()).optional(),
    createdAt: z.date().prefault(()=>new Date()),
    eventTimezone: z.string().prefault('UTC')
});
const consentTable = table('consent', {
    id: idColumn('id', 'varchar(255)'),
    subjectId: column('subjectId', 'string'),
    domainId: column('domainId', 'string'),
    policyId: column('policyId', 'string').nullable(),
    purposeIds: column('purposeIds', 'json'),
    metadata: column('metadata', 'json').nullable(),
    ipAddress: column('ipAddress', 'string').nullable(),
    userAgent: column('userAgent', 'string').nullable(),
    status: column('status', 'string').defaultTo$(()=>'active'),
    withdrawalReason: column('withdrawalReason', 'string').nullable(),
    givenAt: column('givenAt', 'timestamp').defaultTo$('now'),
    validUntil: column('validUntil', 'timestamp').nullable(),
    isActive: column('isActive', 'bool').defaultTo$(()=>true)
});
const consentStatusSchema = z["enum"]([
    'active',
    'withdrawn',
    'expired'
]);
z.object({
    id: z.string(),
    subjectId: z.string(),
    domainId: z.string(),
    purposeIds: z.array(z.string()),
    metadata: z.record(z.string(), z.unknown()).nullish(),
    policyId: z.string().optional(),
    ipAddress: z.string().nullish(),
    userAgent: z.string().nullish(),
    status: consentStatusSchema.prefault('active'),
    withdrawalReason: z.string().nullish(),
    givenAt: z.date().prefault(()=>new Date()),
    validUntil: z.date().nullish(),
    isActive: z.boolean().prefault(true)
});
const consentPolicyTable = table('consentPolicy', {
    id: idColumn('id', 'varchar(255)'),
    version: column('version', 'string'),
    type: column('type', 'string'),
    name: column('name', 'string'),
    effectiveDate: column('effectiveDate', 'timestamp'),
    expirationDate: column('expirationDate', 'timestamp').nullable(),
    content: column('content', 'string'),
    contentHash: column('contentHash', 'string'),
    isActive: column('isActive', 'bool').defaultTo$(()=>true),
    createdAt: column('createdAt', 'timestamp').defaultTo$('now')
});
const PolicyTypeSchema = z["enum"]([
    'cookie_banner',
    'privacy_policy',
    'dpa',
    'terms_and_conditions',
    'marketing_communications',
    'age_verification',
    'other'
]);
z.object({
    id: z.string(),
    version: z.string(),
    type: PolicyTypeSchema,
    name: z.string(),
    effectiveDate: z.date(),
    expirationDate: z.date().nullish(),
    content: z.string(),
    contentHash: z.string(),
    isActive: z.boolean().prefault(true),
    createdAt: z.date().prefault(()=>new Date())
});
const consentPurposeTable = table('consentPurpose', {
    id: idColumn('id', 'varchar(255)'),
    code: column('code', 'string'),
    name: column('name', 'string'),
    description: column("description", 'string'),
    isEssential: column('isEssential', 'bool'),
    dataCategory: column('dataCategory', 'string').nullable(),
    legalBasis: column('legalBasis', 'string').nullable(),
    isActive: column('isActive', 'bool').defaultTo$(()=>true),
    createdAt: column('createdAt', 'timestamp').defaultTo$('now'),
    updatedAt: column('updatedAt', 'timestamp').defaultTo$('now')
});
z.object({
    id: z.string(),
    code: z.string(),
    name: z.string(),
    description: z.string(),
    isEssential: z.boolean(),
    dataCategory: z.string().nullish(),
    legalBasis: z.string().nullish(),
    isActive: z.boolean().prefault(true),
    createdAt: z.date().prefault(()=>new Date()),
    updatedAt: z.date().prefault(()=>new Date())
});
const consentRecordTable = table('consentRecord', {
    id: idColumn('id', 'varchar(255)'),
    subjectId: column('subjectId', 'string'),
    consentId: column('consentId', 'string').nullable(),
    actionType: column('actionType', 'string'),
    details: column('details', 'json').nullable(),
    createdAt: column('createdAt', 'timestamp').defaultTo$('now')
});
z.object({
    id: z.string(),
    subjectId: z.string(),
    consentId: z.string().nullish(),
    actionType: z.string(),
    details: z.record(z.string(), z.unknown()).nullish(),
    createdAt: z.date().prefault(()=>new Date())
});
const domainTable = table('domain', {
    id: idColumn('id', 'varchar(255)'),
    name: column('name', 'string').unique(),
    description: column("description", 'string').nullable(),
    allowedOrigins: column('allowedOrigins', 'json').nullable(),
    isVerified: column('isVerified', 'bool').defaultTo$(()=>true),
    isActive: column('isActive', 'bool').defaultTo$(()=>true),
    createdAt: column('createdAt', 'timestamp').defaultTo$('now'),
    updatedAt: column('updatedAt', 'timestamp').defaultTo$('now')
});
z.object({
    id: z.string(),
    name: z.string(),
    description: z.string().nullish(),
    allowedOrigins: z.array(z.string()).nullish(),
    isVerified: z.boolean().prefault(true),
    isActive: z.boolean().prefault(true),
    createdAt: z.date().prefault(()=>new Date()),
    updatedAt: z.date().prefault(()=>new Date())
});
const subjectTable = table('subject', {
    id: idColumn('id', 'varchar(255)'),
    isIdentified: column('isIdentified', 'bool').defaultTo$(()=>false),
    externalId: column('externalId', 'string').nullable(),
    identityProvider: column('identityProvider', 'string').nullable(),
    lastIpAddress: column('lastIpAddress', 'string').nullable(),
    subjectTimezone: column('subjectTimezone', 'string').nullable(),
    createdAt: column('createdAt', 'timestamp').defaultTo$('now'),
    updatedAt: column('updatedAt', 'timestamp').defaultTo$('now')
});
z.object({
    id: z.string(),
    isIdentified: z.boolean().prefault(false),
    externalId: z.string().nullish(),
    identityProvider: z.string().nullish(),
    lastIpAddress: z.string().optional(),
    subjectTimezone: z.string().nullish(),
    createdAt: z.date().prefault(()=>new Date()),
    updatedAt: z.date().prefault(()=>new Date())
});
const v1 = schema({
    version: '1.0.0',
    tables: {
        subject: subjectTable,
        domain: domainTable,
        consentPolicy: consentPolicyTable,
        consentPurpose: consentPurposeTable,
        consent: consentTable,
        auditLog: auditLogTable,
        consentRecord: consentRecordTable
    },
    relations: {
        subject: ({ many })=>({
                consents: many('consent'),
                consentRecords: many('consentRecord'),
                auditLogs: many('auditLog')
            }),
        domain: ({ many })=>({
                consents: many('consent')
            }),
        consentPolicy: ({ many })=>({
                consents: many('consent')
            }),
        consentPurpose: ()=>({}),
        consent: ({ one, many })=>({
                subject: one('subject', [
                    'subjectId',
                    'id'
                ]).foreignKey(),
                domain: one('domain', [
                    'domainId',
                    'id'
                ]).foreignKey(),
                policy: one('consentPolicy', [
                    'policyId',
                    'id'
                ]).foreignKey(),
                consentRecords: many('consentRecord')
            }),
        consentRecord: ({ one })=>({
                subject: one('subject', [
                    'subjectId',
                    'id'
                ]).foreignKey(),
                consent: one('consent', [
                    'consentId',
                    'id'
                ]).foreignKey()
            }),
        auditLog: ({ one })=>({
                subject: one('subject', [
                    'subjectId',
                    'id'
                ]).foreignKey()
            })
    }
});
fumadb({
    namespace: 'c15t',
    schemas: [
        v1
    ]
});
const baseConsentSchema = z.object({
    subjectId: z.string().optional(),
    externalSubjectId: z.string().optional(),
    identityProvider: z.string().optional(),
    domain: z.string(),
    type: PolicyTypeSchema,
    metadata: z.record(z.string(), z.unknown()).optional()
});
const cookieBannerSchema = baseConsentSchema.extend({
    type: z.literal('cookie_banner'),
    preferences: z.record(z.string(), z.boolean())
});
const policyBasedSchema = baseConsentSchema.extend({
    type: z["enum"]([
        'privacy_policy',
        'dpa',
        'terms_and_conditions'
    ]),
    policyId: z.string().optional(),
    preferences: z.record(z.string(), z.boolean()).optional()
});
const otherConsentSchema = baseConsentSchema.extend({
    type: z["enum"]([
        'marketing_communications',
        'age_verification',
        'other'
    ]),
    preferences: z.record(z.string(), z.boolean()).optional()
});
const postConsentContract = oc.route({
    method: 'POST',
    path: '/consent/set',
    description: `Records a user's consent preferences and creates necessary consent records.
This endpoint handles various types of consent submissions:

1. Cookie Banner Consent:
   - Records granular cookie preferences
   - Supports multiple consent purposes
   - Creates audit trail for compliance

2. Policy-Based Consent:
   - Privacy Policy acceptance
   - Data Processing Agreement (DPA) consent
   - Terms and Conditions acceptance
   - Links consent to specific policy versions

3. Other Consent Types:
   - Marketing communications preferences
   - Age verification consent
   - Custom consent types

The endpoint performs the following operations:
- Creates or retrieves subject records
- Validates domain and policy information
- Creates consent records with audit trails
- Records consent purposes and preferences
- Generates audit logs for compliance

Use this endpoint to record user consent and maintain a compliant consent management system.`,
    tags: [
        'consent',
        'cookie-banner'
    ]
}).errors({
    INPUT_VALIDATION_FAILED: {
        status: 422,
        data: z.object({
            formErrors: z.array(z.string()),
            fieldErrors: z.record(z.string(), z.array(z.string()))
        }),
        error: 'Invalid input parameters'
    },
    SUBJECT_CREATION_FAILED: {
        status: 400,
        data: z.object({
            subjectId: z.string().optional(),
            externalSubjectId: z.string().optional()
        }),
        error: 'Failed to create or find subject'
    },
    DOMAIN_CREATION_FAILED: {
        status: 500,
        data: z.object({
            domain: z.string()
        }),
        error: 'Failed to create or find domain'
    },
    POLICY_NOT_FOUND: {
        status: 404,
        data: z.object({
            policyId: z.string(),
            type: z.string()
        }),
        error: 'Policy not found'
    },
    POLICY_INACTIVE: {
        status: 409,
        data: z.object({
            policyId: z.string(),
            type: z.string()
        }),
        error: 'Policy is not active'
    },
    POLICY_CREATION_FAILED: {
        status: 500,
        data: z.object({
            type: z.string()
        }),
        error: 'Failed to create or find policy'
    },
    PURPOSE_CREATION_FAILED: {
        status: 500,
        data: z.object({
            purposeCode: z.string()
        }),
        error: 'Failed to create consent purpose'
    },
    CONSENT_CREATION_FAILED: {
        status: 500,
        data: z.object({
            subjectId: z.string(),
            domain: z.string()
        }),
        error: 'Failed to create consent record'
    }
}).input(z.discriminatedUnion('type', [
    cookieBannerSchema,
    policyBasedSchema,
    otherConsentSchema
])).output(z.object({
    id: z.string(),
    subjectId: z.string().optional(),
    externalSubjectId: z.string().optional(),
    domainId: z.string(),
    domain: z.string(),
    type: PolicyTypeSchema,
    status: z.string(),
    recordId: z.string(),
    metadata: z.record(z.string(), z.unknown()).optional(),
    givenAt: z.date()
}));
const types_branding = [
    'c15t',
    'consent',
    'none'
];
const JurisdictionMessages = {
    GDPR: 'GDPR or equivalent regulations require a cookie banner.',
    CH: 'Switzerland requires similar data protection measures.',
    BR: "Brazil's LGPD requires consent for cookies.",
    PIPEDA: 'PIPEDA requires consent for data collection.',
    AU: "Australia's Privacy Act mandates transparency about data collection.",
    APPI: "Japan's APPI requires consent for data collection.",
    PIPA: "South Korea's PIPA requires consent for data collection.",
    NONE: 'No specific requirements'
};
const JurisdictionCodeSchema = z["enum"]([
    'GDPR',
    'CH',
    'BR',
    'PIPEDA',
    'AU',
    'APPI',
    'PIPA',
    'NONE'
]);
const JurisdictionInfoSchema = z.object({
    code: JurisdictionCodeSchema,
    message: z.string()
});
const TitleDescriptionSchema = z.object({
    title: z.string(),
    description: z.string()
});
const CompleteTranslationsSchema = z.object({
    common: z.object({
        acceptAll: z.string(),
        rejectAll: z.string(),
        customize: z.string(),
        save: z.string()
    }),
    cookieBanner: TitleDescriptionSchema,
    consentManagerDialog: TitleDescriptionSchema,
    consentTypes: z.object({
        experience: TitleDescriptionSchema,
        functionality: TitleDescriptionSchema,
        marketing: TitleDescriptionSchema,
        measurement: TitleDescriptionSchema,
        necessary: TitleDescriptionSchema
    }),
    frame: z.object({
        title: z.string(),
        actionButton: z.string()
    }),
    legalLinks: z.object({
        privacyPolicy: z.string(),
        termsOfService: z.string(),
        cookiePolicy: z.string()
    })
});
const PartialTranslationsSchema = z.object({
    common: z.object({
        acceptAll: z.string().optional(),
        rejectAll: z.string().optional(),
        customize: z.string().optional(),
        save: z.string().optional()
    }).partial(),
    cookieBanner: TitleDescriptionSchema.partial(),
    consentManagerDialog: TitleDescriptionSchema.partial(),
    consentTypes: z.object({
        experience: TitleDescriptionSchema.partial(),
        functionality: TitleDescriptionSchema.partial(),
        marketing: TitleDescriptionSchema.partial(),
        measurement: TitleDescriptionSchema.partial(),
        necessary: TitleDescriptionSchema.partial()
    }).partial(),
    frame: z.object({
        title: z.string().optional(),
        actionButton: z.string().optional()
    }).partial().optional(),
    legalLinks: z.object({
        privacyPolicy: z.string().optional(),
        termsOfService: z.string().optional(),
        cookiePolicy: z.string().optional()
    }).partial().optional()
});
const TranslationsSchema = z.union([
    CompleteTranslationsSchema,
    PartialTranslationsSchema
]);
const showConsentBannerContract = oc.route({
    method: 'GET',
    path: '/show-consent-banner',
    description: `Determines if a user should see a consent banner based on their location and applicable privacy regulations.
This endpoint performs the following checks:

1. Detects the user's location using various header information:
   - Cloudflare country headers
   - Vercel IP country headers
   - AWS CloudFront headers
   - Custom country code headers

2. Determines the applicable jurisdiction based on the location:
   - GDPR (EU/EEA/UK)
   - Swiss Data Protection Act
   - LGPD (Brazil)
   - PIPEDA (Canada)
   - Australian Privacy Principles
   - APPI (Japan)
   - PIPA (South Korea)

3. Returns detailed information about:
   - Whether to show the consent banner
   - The applicable jurisdiction and its requirements
   - The user's detected location (country and region)

Use this endpoint to implement geo-targeted consent banners and ensure compliance with regional privacy regulations.`,
    tags: [
        'cookie-banner'
    ]
}).output(z.object({
    showConsentBanner: z.boolean(),
    jurisdiction: JurisdictionInfoSchema,
    location: z.object({
        countryCode: z.string().nullable(),
        regionCode: z.string().nullable()
    }),
    translations: z.object({
        language: z.string(),
        translations: TranslationsSchema
    }),
    branding: z["enum"](types_branding)
}));
const verifyConsentInputSchema = z.strictObject({
    subjectId: z.string().optional(),
    externalSubjectId: z.string().optional(),
    domain: z.string(),
    type: PolicyTypeSchema,
    policyId: z.string().optional(),
    preferences: z.array(z.string()).optional()
});
const verify_contract_consentSchema = z.looseObject({
    id: z.string(),
    purposeIds: z.array(z.string())
});
const verifyConsentContract = oc.route({
    method: 'POST',
    path: '/consent/verify',
    description: `Verifies if a user has given valid consent for a specific policy and domain.
This endpoint performs comprehensive consent verification by:

1. Validating the subject's identity (using subjectId or externalSubjectId)
2. Verifying the domain's existence and validity
3. Checking if the specified policy exists and is active
4. Validating that all required purposes have been consented to
5. Ensuring the consent record is current and valid

The endpoint supports different types of consent verification:
- Cookie banner consent verification
- Privacy policy consent verification
- Terms and conditions verification
- Marketing communications consent verification
- Age verification
- Custom consent types

Use this endpoint to ensure compliance with privacy regulations and to verify user consent before processing personal data.`,
    tags: [
        'consent'
    ]
}).errors({
    INPUT_VALIDATION_FAILED: {
        status: 422,
        data: z.object({
            formErrors: z.array(z.string()),
            fieldErrors: z.record(z.string(), z.array(z.string()).optional())
        }),
        error: 'Invalid input parameters'
    },
    SUBJECT_NOT_FOUND: {
        status: 404,
        data: z.object({
            subjectId: z.string().optional(),
            externalSubjectId: z.string().optional()
        }),
        error: 'Subject not found'
    },
    DOMAIN_NOT_FOUND: {
        status: 404,
        data: z.object({
            domain: z.string()
        }),
        error: 'Domain not found'
    },
    POLICY_NOT_FOUND: {
        status: 404,
        data: z.object({
            policyId: z.string(),
            type: z.string()
        }),
        error: 'Policy not found or invalid'
    },
    PURPOSES_NOT_FOUND: {
        status: 404,
        data: z.object({
            preferences: z.array(z.string()),
            foundPurposes: z.array(z.string())
        }),
        error: 'Could not find all specified purposes'
    },
    COOKIE_BANNER_PREFERENCES_REQUIRED: {
        status: 400,
        data: z.object({
            type: z.literal('cookie_banner')
        }),
        error: 'Preferences are required for cookie banner consent'
    },
    NO_CONSENT_FOUND: {
        status: 404,
        data: z.object({
            policyId: z.string(),
            subjectId: z.string(),
            domainId: z.string()
        }),
        error: 'No consent found for the given policy'
    }
}).input(verifyConsentInputSchema).output(z.object({
    isValid: z.boolean(),
    reasons: z.array(z.string()).optional(),
    consent: verify_contract_consentSchema.optional()
}));
const consentContracts = {
    post: postConsentContract,
    showBanner: showConsentBannerContract,
    verify: verifyConsentContract,
    identify: identifyUserContract
};
const statusContract = oc.route({
    method: 'GET',
    path: '/status',
    description: `Returns the current operational status and health metrics of the service.
This endpoint provides real-time information about:
- Overall service status (ok/error)
- Current API version
- Server timestamp
- Storage system status and availability
- Client information (IP, User Agent, Region)

Use this endpoint for health checks, monitoring, and service status verification.`,
    tags: [
        'meta'
    ]
}).output(z.object({
    status: z["enum"]([
        'ok',
        'error'
    ]),
    version: z.string(),
    timestamp: z.date(),
    client: z.object({
        ip: z.string().nullable(),
        userAgent: z.string().nullable(),
        region: z.object({
            countryCode: z.string().nullable(),
            regionCode: z.string().nullable()
        })
    })
}));
const metaContracts = {
    status: statusContract
};
const config = {
    consent: consentContracts,
    meta: metaContracts
};
const os = implement(config);
const prefixes = {
    auditLog: 'log',
    consent: 'cns',
    consentPolicy: 'pol',
    consentPurpose: 'pur',
    consentRecord: 'rec',
    domain: 'dom',
    subject: 'sub'
};
const b58 = base_x('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');
function generateId(model) {
    const buf = crypto.getRandomValues(new Uint8Array(20));
    const prefix = prefixes[model];
    const EPOCH_TIMESTAMP = 1700000000000;
    const t = Date.now() - EPOCH_TIMESTAMP;
    const high = Math.floor(t / 0x100000000);
    const low = t >>> 0;
    buf[0] = high >>> 24 & 255;
    buf[1] = high >>> 16 & 255;
    buf[2] = high >>> 8 & 255;
    buf[3] = 255 & high;
    buf[4] = low >>> 24 & 255;
    buf[5] = low >>> 16 & 255;
    buf[6] = low >>> 8 & 255;
    buf[7] = 255 & low;
    return `${prefix}_${b58.encode(buf)}`;
}
async function generateUniqueId(db, model, ctx, options = {}) {
    const { maxRetries = 10, attempt = 0, baseDelay = 5 } = options;
    if (attempt >= maxRetries) {
        const error = new Error(`Failed to generate unique ID for ${model} after ${maxRetries} attempts`);
        ctx?.logger?.error?.('ID generation failed', {
            model,
            maxRetries
        });
        throw error;
    }
    const id = generateId(model);
    try {
        const existing = await db.findFirst(model, {
            where: (b)=>b('id', '=', id)
        });
        if (existing) {
            ctx?.logger?.debug?.('ID conflict detected', {
                id,
                model,
                attempt: attempt + 1,
                maxRetries
            });
            const delay = Math.min(baseDelay * 2 ** attempt, 1000);
            await new Promise((resolve)=>setTimeout(resolve, delay));
            return generateUniqueId(db, model, ctx, {
                maxRetries,
                attempt: attempt + 1,
                baseDelay
            });
        }
        return id;
    } catch (error) {
        ctx?.logger?.error?.('Error checking ID uniqueness', {
            error: error.message,
            model,
            attempt
        });
        if (attempt < maxRetries - 1) {
            const delay = Math.min(baseDelay * 2 ** attempt, 2000);
            await new Promise((resolve)=>setTimeout(resolve, delay));
            return generateUniqueId(db, model, ctx, {
                maxRetries,
                attempt: attempt + 1,
                baseDelay
            });
        }
        throw error;
    }
}
const identifyUser = os.consent.identify.handler(async ({ input, context })=>{
    const typedContext = context;
    const { db, logger } = typedContext;
    logger.info('Handling identify-user request');
    const { consentId, externalId, identityProvider = 'external' } = input;
    const consent = await db.findFirst('consent', {
        where: (b)=>b('id', '=', consentId)
    });
    if (!consent) throw new ORPCError('CONSENT_NOT_FOUND', {
        data: {
            consentId
        }
    });
    await db.transaction(async (tx)=>{
        const existingSubject = await tx.findFirst('subject', {
            where: (b)=>b.and(b('externalId', '=', externalId), b('id', '!=', consent.subjectId))
        });
        if (existingSubject) {
            const currentSubjectId = consent.subjectId;
            const oldSubjectId = existingSubject.id;
            logger.info('Merging subjects', {
                currentSubjectId,
                oldSubjectId,
                externalId,
                identityProvider
            });
            await tx.updateMany('consent', {
                where: (b)=>b('subjectId', '=', currentSubjectId),
                set: {
                    subjectId: oldSubjectId
                }
            });
            await tx.updateMany('consentRecord', {
                where: (b)=>b('subjectId', '=', currentSubjectId),
                set: {
                    subjectId: oldSubjectId
                }
            });
            await tx.updateMany('auditLog', {
                where: (b)=>b('subjectId', '=', currentSubjectId),
                set: {
                    subjectId: oldSubjectId
                }
            });
            await tx.deleteMany('subject', {
                where: (b)=>b('id', '=', currentSubjectId)
            });
            await tx.create('auditLog', {
                id: await generateUniqueId(tx, 'auditLog', typedContext),
                subjectId: oldSubjectId,
                entityType: 'consent',
                entityId: consent.id,
                actionType: 'identify_user',
                ipAddress: typedContext.ipAddress || null,
                userAgent: typedContext.userAgent || null,
                eventTimezone: 'UTC',
                metadata: {
                    externalId,
                    identityProvider,
                    mergedFrom: currentSubjectId
                }
            });
        } else {
            await tx.updateMany('subject', {
                where: (b)=>b('id', '=', consent.subjectId),
                set: {
                    externalId,
                    identityProvider,
                    isIdentified: true,
                    updatedAt: new Date()
                }
            });
            await tx.create('auditLog', {
                id: await generateUniqueId(tx, 'auditLog', typedContext),
                subjectId: consent.subjectId,
                entityType: 'consent',
                entityId: consent.id,
                actionType: 'identify_user',
                ipAddress: typedContext.ipAddress || null,
                userAgent: typedContext.userAgent || null,
                eventTimezone: 'UTC',
                metadata: {
                    externalId,
                    identityProvider
                }
            });
        }
    });
    return {
        success: true
    };
});
const postConsent = os.consent.post.handler(async ({ input, context })=>{
    const typedContext = context;
    const logger = typedContext.logger;
    logger.info('Handling post-consent request');
    const { db, registry } = typedContext;
    const { type, subjectId, identityProvider, externalSubjectId, domain, metadata, preferences } = input;
    logger.debug('Request parameters', {
        type,
        subjectId,
        identityProvider,
        externalSubjectId,
        domain
    });
    try {
        const subject = await registry.findOrCreateSubject({
            subjectId,
            externalSubjectId,
            identityProvider,
            ipAddress: typedContext.ipAddress
        });
        if (!subject) throw new ORPCError('SUBJECT_CREATION_FAILED', {
            data: {
                subjectId,
                externalSubjectId
            }
        });
        logger.debug('Subject found/created', {
            subjectId: subject.id
        });
        const domainRecord = await typedContext.registry.findOrCreateDomain(domain);
        if (!domainRecord) throw new ORPCError('DOMAIN_CREATION_FAILED', {
            data: {
                domain
            }
        });
        let policyId;
        let purposeIds = [];
        if ('policyId' in input && input.policyId) {
            policyId = input.policyId;
            const policy = await typedContext.registry.findConsentPolicyById(policyId);
            if (!policy) throw new ORPCError('POLICY_NOT_FOUND', {
                data: {
                    policyId,
                    type
                }
            });
            if (!policy.isActive) throw new ORPCError('POLICY_INACTIVE', {
                data: {
                    policyId,
                    type
                }
            });
        } else {
            const policy = await typedContext.registry.findOrCreatePolicy(type);
            if (!policy) throw new ORPCError('POLICY_CREATION_FAILED', {
                data: {
                    type
                }
            });
            policyId = policy.id;
        }
        if (preferences) {
            const consentedPurposes = Object.entries(preferences).filter(([_, isConsented])=>isConsented).map(([purposeCode])=>purposeCode);
            logger.debug('Consented purposes', {
                consentedPurposes
            });
            const purposesRaw = await Promise.all(consentedPurposes.map((purposeCode)=>typedContext.registry.findOrCreateConsentPurposeByCode(purposeCode)));
            const purposes = purposesRaw.map((purpose)=>purpose?.id);
            logger.debug('Purposes: ', {
                purposes
            });
            purposeIds = purposes;
        }
        const result = await db.transaction(async (tx)=>{
            logger.debug('Creating consent record', {
                subjectId: subject.id,
                domainId: domainRecord.id,
                policyId,
                purposeIds
            });
            const consentRecord = await tx.create('consent', {
                id: await generateUniqueId(tx, 'consent', typedContext),
                subjectId: subject.id,
                domainId: domainRecord.id,
                policyId,
                purposeIds: {
                    json: purposeIds
                },
                status: 'active',
                isActive: true,
                ipAddress: typedContext.ipAddress || null,
                userAgent: typedContext.userAgent || null
            });
            logger.debug('Created consent', {
                consentRecord: consentRecord.id
            });
            logger.debug('Creating consentRecord entry', {
                subjectId: subject.id,
                consentId: consentRecord.id,
                actionType: 'consent_given',
                details: metadata
            });
            const record = await tx.create('consentRecord', {
                id: await generateUniqueId(tx, 'consentRecord', typedContext),
                subjectId: subject.id,
                consentId: consentRecord.id,
                actionType: 'consent_given',
                details: metadata
            });
            logger.debug('Created record entry', {
                record: record.id
            });
            logger.debug('Creating audit log', {
                subjectId: subject.id,
                entityType: 'consent',
                entityId: consentRecord.id,
                actionType: 'consent_given',
                metadata: metadata
            });
            await tx.create('auditLog', {
                id: await generateUniqueId(tx, 'auditLog', typedContext),
                subjectId: subject.id,
                entityType: 'consent',
                entityId: consentRecord.id,
                actionType: 'consent_given',
                metadata: {
                    consentId: consentRecord.id,
                    type
                },
                ipAddress: typedContext.ipAddress || null,
                userAgent: typedContext.userAgent || null,
                eventTimezone: 'UTC'
            });
            logger.debug('Created audit log');
            if (!consentRecord || !record) throw new ORPCError('CONSENT_CREATION_FAILED', {
                data: {
                    subjectId: subject.id,
                    domain
                }
            });
            return {
                consent: consentRecord,
                record
            };
        });
        return {
            id: result.consent.id,
            subjectId: subject.id,
            externalSubjectId: subject.externalId ?? void 0,
            identityProvider: subject.identityProvider ?? void 0,
            domainId: domainRecord.id,
            domain: domainRecord.name,
            type,
            status: result.consent.status,
            recordId: result.record.id,
            metadata,
            givenAt: result.consent.givenAt
        };
    } catch (error) {
        logger.error('Error in post-consent handler', {
            error: error instanceof Error ? error.message : String(error),
            errorType: error instanceof Error ? error.constructor.name : typeof error
        });
        if (error instanceof ORPCError) throw error;
        throw new ORPCError('INTERNAL_SERVER_ERROR', {
            message: error instanceof Error ? error.message : String(error)
        });
    }
});
function checkJurisdiction(countryCode) {
    const jurisdictions = {
        EU: new Set([
            'AT',
            'BE',
            'BG',
            'HR',
            'CY',
            'CZ',
            'DK',
            'EE',
            'FI',
            'FR',
            'DE',
            'GR',
            'HU',
            'IE',
            'IT',
            'LV',
            'LT',
            'LU',
            'MT',
            'NL',
            'PL',
            'PT',
            'RO',
            'SK',
            'SI',
            'ES',
            'SE'
        ]),
        EEA: new Set([
            'IS',
            'NO',
            'LI'
        ]),
        UK: new Set([
            'GB'
        ]),
        CH: new Set([
            'CH'
        ]),
        BR: new Set([
            'BR'
        ]),
        CA: new Set([
            'CA'
        ]),
        AU: new Set([
            'AU'
        ]),
        JP: new Set([
            'JP'
        ]),
        KR: new Set([
            'KR'
        ])
    };
    let showConsentBanner = true;
    let jurisdictionCode = 'NONE';
    if (countryCode) {
        const normalizedCountryCode = countryCode.toUpperCase();
        showConsentBanner = false;
        const jurisdictionMap = [
            {
                sets: [
                    jurisdictions.EU,
                    jurisdictions.EEA,
                    jurisdictions.UK
                ],
                code: 'GDPR'
            },
            {
                sets: [
                    jurisdictions.CH
                ],
                code: 'CH'
            },
            {
                sets: [
                    jurisdictions.BR
                ],
                code: 'BR'
            },
            {
                sets: [
                    jurisdictions.CA
                ],
                code: 'PIPEDA'
            },
            {
                sets: [
                    jurisdictions.AU
                ],
                code: 'AU'
            },
            {
                sets: [
                    jurisdictions.JP
                ],
                code: 'APPI'
            },
            {
                sets: [
                    jurisdictions.KR
                ],
                code: 'PIPA'
            }
        ];
        for (const { sets, code } of jurisdictionMap)if (sets.some((set)=>set.has(normalizedCountryCode))) {
            jurisdictionCode = code;
            showConsentBanner = true;
            break;
        }
    }
    const message = JurisdictionMessages[jurisdictionCode];
    return {
        showConsentBanner,
        jurisdictionCode,
        message
    };
}
function isSupportedBaseLanguage(lang) {
    return lang in baseTranslations;
}
function getPreferredLanguage(acceptLanguage, supportedLanguages) {
    if (!acceptLanguage) return 'en';
    const primaryLang = acceptLanguage.split(',')[0]?.split(';')[0]?.split('-')[0]?.toLowerCase();
    if (primaryLang && supportedLanguages.includes(primaryLang)) return primaryLang;
    return 'en';
}
function getTranslations(acceptLanguage, customTranslations) {
    const supportedDefaultLanguages = Object.keys(baseTranslations);
    const supportedCustomLanguages = Object.keys(customTranslations || {});
    const supportedLanguages = [
        ...supportedDefaultLanguages,
        ...supportedCustomLanguages
    ];
    const preferredLanguage = getPreferredLanguage(acceptLanguage, supportedLanguages);
    const base = isSupportedBaseLanguage(preferredLanguage) ? baseTranslations[preferredLanguage] : baseTranslations.en;
    const custom = supportedCustomLanguages.includes(preferredLanguage) ? customTranslations?.[preferredLanguage] : {};
    const translations = custom ? deepMergeTranslations(base, custom) : base;
    return {
        translations: translations,
        language: preferredLanguage
    };
}
function getHeaders(headers) {
    if (!headers) return {
        countryCode: null,
        regionCode: null,
        acceptLanguage: null
    };
    const normalizeHeader = (value)=>{
        if (!value) return null;
        return Array.isArray(value) ? value[0] ?? null : value;
    };
    const countryCode = normalizeHeader(headers.get('x-c15t-country')) ?? normalizeHeader(headers.get('cf-ipcountry')) ?? normalizeHeader(headers.get('x-vercel-ip-country')) ?? normalizeHeader(headers.get('x-amz-cf-ipcountry')) ?? normalizeHeader(headers.get('x-country-code'));
    const regionCode = normalizeHeader(headers.get('x-c15t-region')) ?? normalizeHeader(headers.get('x-vercel-ip-country-region')) ?? normalizeHeader(headers.get('x-region-code'));
    const acceptLanguage = normalizeHeader(headers.get('accept-language'));
    return {
        countryCode,
        regionCode,
        acceptLanguage
    };
}
function buildResponse({ shouldShowBanner, jurisdiction, location, acceptLanguage, customTranslations, branding = 'c15t' }) {
    return {
        showConsentBanner: shouldShowBanner,
        jurisdiction,
        location,
        translations: getTranslations(acceptLanguage, customTranslations),
        branding: branding
    };
}
const handler_showConsentBanner = os.consent.showBanner.handler(({ context })=>{
    const typedContext = context;
    const { customTranslations, disableGeoLocation, branding } = typedContext.advanced ?? {};
    const { countryCode, regionCode, acceptLanguage } = getHeaders(typedContext.headers);
    if (disableGeoLocation) return buildResponse({
        shouldShowBanner: true,
        jurisdiction: {
            code: 'NONE',
            message: JurisdictionMessages.NONE
        },
        location: {
            countryCode: null,
            regionCode: null
        },
        acceptLanguage,
        customTranslations,
        branding
    });
    const { showConsentBanner, jurisdictionCode, message } = checkJurisdiction(countryCode);
    return buildResponse({
        shouldShowBanner: showConsentBanner,
        jurisdiction: {
            code: jurisdictionCode,
            message
        },
        location: {
            countryCode,
            regionCode
        },
        acceptLanguage,
        customTranslations,
        branding
    });
});
const verifyConsent = os.consent.verify.handler(async ({ input, context })=>{
    const typedContext = context;
    const logger = typedContext.logger;
    logger.info('Handling verify-consent request');
    const { type, subjectId, externalSubjectId, domain, policyId, preferences } = input;
    logger.debug('Request parameters', {
        type,
        subjectId,
        externalSubjectId,
        domain,
        policyId,
        preferences
    });
    try {
        const domainRecord = await typedContext.registry.findDomainByName(domain);
        if (!domainRecord) throw new ORPCError('DOMAIN_NOT_FOUND', {
            data: {
                domain
            }
        });
        const subject = await typedContext.registry.findOrCreateSubject({
            subjectId,
            externalSubjectId,
            ipAddress: typedContext.ipAddress ?? 'unknown'
        });
        if (!subject) throw new ORPCError('SUBJECT_NOT_FOUND', {
            data: {
                subjectId,
                externalSubjectId
            }
        });
        if ('cookie_banner' === type && (!preferences || 0 === preferences.length)) throw new ORPCError('COOKIE_BANNER_PREFERENCES_REQUIRED', {
            data: {
                type: 'cookie_banner'
            }
        });
        const purposePromises = preferences?.map((purpose)=>typedContext.registry.findOrCreateConsentPurposeByCode(purpose));
        const rawPurposes = await Promise.all(purposePromises ?? []);
        const purposeIds = rawPurposes.filter((purpose)=>null !== purpose).map((purpose)=>purpose.id);
        if (purposeIds.length !== (preferences?.length ?? 0)) throw new ORPCError('PURPOSES_NOT_FOUND', {
            data: {
                preferences: preferences ?? [],
                foundPurposes: rawPurposes.filter((p)=>null !== p).map((p)=>p.code)
            }
        });
        if (policyId) {
            const policy = await typedContext.registry.findConsentPolicyById(policyId);
            if (!policy || policy.type !== type) throw new ORPCError('POLICY_NOT_FOUND', {
                data: {
                    policyId,
                    type
                }
            });
            return await checkPolicyConsent({
                policyId: policy.id,
                subjectId: subject.id,
                domainId: domainRecord.id,
                purposeIds,
                type,
                context: typedContext
            });
        }
        const latestPolicy = await typedContext.registry.findOrCreatePolicy(type);
        if (!latestPolicy) throw new ORPCError('POLICY_NOT_FOUND', {
            data: {
                policyId: 'latest',
                type
            }
        });
        return await checkPolicyConsent({
            policyId: latestPolicy.id,
            subjectId: subject.id,
            domainId: domainRecord.id,
            purposeIds,
            type,
            context: typedContext
        });
    } catch (error) {
        logger.error('Error in verify-consent handler', {
            error: error instanceof Error ? error.message : String(error),
            errorType: error instanceof Error ? error.constructor.name : typeof error
        });
        if (error instanceof ORPCError) throw error;
        throw new ORPCError('INTERNAL_SERVER_ERROR', {
            message: error instanceof Error ? error.message : String(error)
        });
    }
});
async function checkPolicyConsent({ policyId, subjectId, domainId, purposeIds, type, context }) {
    const { registry, db } = context;
    const rawConsents = await db.findMany('consent', {
        where: (b)=>b.and(b('subjectId', '=', subjectId), b('policyId', '=', policyId), b('domainId', '=', domainId)),
        orderBy: [
            'givenAt',
            'desc'
        ]
    });
    const filteredConsents = rawConsents.filter((consent)=>{
        if (!purposeIds) return true;
        return purposeIds.every((id)=>consent.purposeIds.some((purposeId)=>purposeId === id));
    });
    await registry.createAuditLog({
        subjectId,
        entityType: 'consent_policy',
        entityId: policyId,
        actionType: 'verify_consent',
        metadata: {
            type,
            policyId,
            purposeIds,
            success: 0 !== filteredConsents.length,
            ...filteredConsents.length > 0 ? {
                consentId: filteredConsents[0]?.id
            } : {}
        },
        eventTimezone: 'UTC'
    });
    if (0 === rawConsents.length || 0 === filteredConsents.length) return {
        isValid: false
    };
    return {
        isValid: true,
        consent: filteredConsents[0]
    };
}
const consentHandlers = {
    post: postConsent,
    showBanner: handler_showConsentBanner,
    verify: verifyConsent,
    identify: identifyUser
};
const statusHandler = os.meta.status.handler(({ context })=>{
    const typedContext = context;
    const headers = typedContext.headers;
    const normalizeHeader = (value)=>{
        if (!value) return null;
        return Array.isArray(value) ? value[0] ?? null : value;
    };
    const countryCode = normalizeHeader(headers?.get('cf-ipcountry')) ?? normalizeHeader(headers?.get('x-vercel-ip-country')) ?? normalizeHeader(headers?.get('x-amz-cf-ipcountry')) ?? normalizeHeader(headers?.get('x-country-code'));
    const regionCode = normalizeHeader(headers?.get('x-vercel-ip-country-region')) ?? normalizeHeader(headers?.get('x-region-code'));
    return {
        status: 'ok',
        version: "1.8.0",
        timestamp: new Date(),
        client: {
            ip: typedContext.ipAddress ?? null,
            userAgent: typedContext.userAgent ?? null,
            region: {
                countryCode,
                regionCode
            }
        }
    };
});
const metaHandlers = {
    status: statusHandler
};
const router = os.router({
    consent: consentHandlers,
    meta: metaHandlers
});
export { router };
