import { createLogger as logger_createLogger } from "@c15t/logger";
import { OpenAPIHandler } from "@orpc/openapi/fetch";
import { ORPCError, implement } from "@orpc/server";
import { CORSPlugin } from "@orpc/server/plugins";
import defu from "defu";
import { OpenAPIGenerator } from "@orpc/openapi";
import { ZodToJsonSchemaConverter } from "@orpc/zod";
import { oc } from "@orpc/contract";
import { z } from "zod";
import { fumadb } from "fumadb";
import { column, idColumn, schema, table } from "fumadb/schema";
import base_x from "base-x";
import { baseTranslations, deepMergeTranslations } from "@c15t/translations";
import { resourceFromAttributes } from "@opentelemetry/resources";
import { NodeSDK } from "@opentelemetry/sdk-node";
import { ConsoleSpanExporter } from "@opentelemetry/sdk-trace-base";
import { SpanStatusCode, trace } from "@opentelemetry/api";
const WWW_REGEX = /^www\./;
const PROTOCOL_WWW_REGEX = /^https?:\/\/(www\.)?/;
const SUPPORTED_METHODS = [
    'GET',
    'POST',
    'PUT',
    'DELETE',
    'PATCH',
    'OPTIONS'
];
const SUPPORTED_HEADERS = [
    'Content-Type',
    'Authorization',
    'x-request-id',
    'x-c15t-country',
    'x-c15t-region',
    'accept-language'
];
const DEFAULT_CORS_CONFIG = {
    origin: async (origin)=>await Promise.resolve(origin || '*'),
    credentials: true,
    allowHeaders: SUPPORTED_HEADERS,
    maxAge: 600,
    methods: SUPPORTED_METHODS
};
function createCORSOptions(trustedOrigins) {
    if (!trustedOrigins) return DEFAULT_CORS_CONFIG;
    const origins = Array.isArray(trustedOrigins) ? trustedOrigins : [
        trustedOrigins
    ];
    if (0 === origins.length) return DEFAULT_CORS_CONFIG;
    function normalizeOrigin(origin) {
        try {
            if (!origin.includes('://') && !origin.includes(':') && !origin.includes('/')) return origin.toLowerCase();
            const originWithProtocol = origin.startsWith('http://') || origin.startsWith('https://') || origin.startsWith('ws://') || origin.startsWith('wss://') ? origin : `http://${origin}`;
            const url = new URL(originWithProtocol);
            const hostname = url.hostname.replace(WWW_REGEX, '');
            return `${hostname}${url.port ? `:${url.port}` : ''}`;
        } catch  {
            return origin.replace(PROTOCOL_WWW_REGEX, '').replace(WWW_REGEX, '');
        }
    }
    function expandWithWWW(origins) {
        const expanded = new Set();
        for (const origin of origins){
            if ('*' === origin) {
                expanded.add('*');
                continue;
            }
            const normalized = normalizeOrigin(origin);
            expanded.add(normalized);
            if (!normalized.includes('www.')) expanded.add(`www.${normalized}`);
        }
        return Array.from(expanded);
    }
    const expandedTrusted = expandWithWWW(origins);
    const returnConfig = {
        origin: async (origin)=>{
            if (!origin) return '*';
            const normalizedOrigin = normalizeOrigin(origin);
            if (expandedTrusted.includes('*')) return origin;
            const isTrusted = expandedTrusted.some((trusted)=>{
                const normalizedTrusted = normalizeOrigin(trusted);
                if ('localhost' === normalizedTrusted) return 'localhost' === normalizedOrigin || normalizedOrigin.startsWith('localhost:') || '127.0.0.1' === normalizedOrigin || normalizedOrigin.startsWith('127.0.0.1:') || '[::1]' === normalizedOrigin || normalizedOrigin.startsWith('[::1]:');
                return normalizedTrusted === normalizedOrigin;
            });
            return isTrusted ? origin : null;
        },
        credentials: true,
        allowHeaders: SUPPORTED_HEADERS,
        maxAge: 600,
        methods: SUPPORTED_METHODS
    };
    return returnConfig;
}
const STRIP_REGEX = /^(https?:\/\/)|(wss?:\/\/)|(\/+$)|:\d+/g;
function matchesWildcard(hostname, wildcardPattern, logger) {
    const wildcardDomain = wildcardPattern.slice(2);
    const isValid = hostname !== wildcardDomain && hostname.endsWith(`.${wildcardDomain}`);
    logger?.debug(`Wildcard match result: ${isValid} ${hostname} ends with .${wildcardDomain}`);
    return isValid;
}
function isOriginTrusted(origin, trustedDomains, logger) {
    try {
        if (0 === trustedDomains.length) throw new Error('No trusted domains');
        logger?.debug(`Checking if origin ${origin} is trusted in ${trustedDomains}`);
        if (trustedDomains.includes('*')) {
            logger?.debug('Allowing all origins');
            return true;
        }
        const url = new URL(origin);
        const originHostname = url.hostname.toLowerCase();
        logger?.debug(`Parsed origin hostname: ${originHostname}`);
        return trustedDomains.some((domain)=>{
            if (!domain || '' === domain.trim()) {
                logger?.debug('Skipping empty domain');
                return false;
            }
            const strippedDomain = domain.replace(STRIP_REGEX, '').toLowerCase();
            logger?.debug(`Checking against stripped domain: ${strippedDomain}`);
            if (strippedDomain.startsWith('*.')) return matchesWildcard(originHostname, strippedDomain, logger);
            const isMatch = originHostname === strippedDomain;
            logger?.debug(`Exact match result: ${isMatch} ${originHostname} === ${strippedDomain}`);
            return isMatch;
        });
    } catch (error) {
        logger?.error('Error validating origin:', error);
        return false;
    }
}
function extractCORSInfo(request, trustedOrigins, logger) {
    const origin = request.headers.get('origin');
    if (!origin || !trustedOrigins) return {
        origin: origin,
        isTrusted: false
    };
    return {
        origin,
        isTrusted: isOriginTrusted(origin, trustedOrigins, logger)
    };
}
const processCors = (request, context, trustedOrigins)=>{
    const { origin, isTrusted } = extractCORSInfo(request, trustedOrigins, context.logger);
    if (origin) {
        context.origin = origin;
        context.trustedOrigin = isTrusted;
    }
    return context;
};
const createOpenAPIConfig = (options)=>{
    const basePath = options.basePath || '';
    return {
        enabled: true,
        specPath: `${basePath}/spec.json`,
        docsPath: `${basePath}/docs`,
        ...options.advanced?.openapi || {}
    };
};
const createDefaultOpenAPIOptions = (options)=>({
        info: {
            title: options.appName || 'c15t API',
            version: "1.8.0",
            description: 'API for consent management'
        },
        servers: [
            {
                url: options.basePath || '/'
            }
        ],
        security: [
            {
                bearerAuth: []
            }
        ]
    });
const identifyUserSchema = z.object({
    consentId: z.string(),
    externalId: z.string(),
    identityProvider: z.string().optional()
});
const identifyUserContract = oc.route({
    method: 'PATCH',
    path: '/consent/identify',
    description: "Links a subject's external ID to a consent record by consent ID. This is used to identify a user across multiple devices and sessions.",
    tags: [
        'consent',
        'cookie-banner'
    ]
}).errors({
    CONSENT_NOT_FOUND: {
        status: 404,
        data: z.object({
            consentId: z.string()
        }),
        error: 'Consent not found'
    },
    IDENTIFICATION_FAILED: {
        status: 500,
        data: z.object({
            consentId: z.string()
        }),
        error: 'Failed to identify user'
    }
}).input(identifyUserSchema).output(z.object({
    success: z.boolean()
}));
const auditLogTable = table('auditLog', {
    id: idColumn('id', 'varchar(255)'),
    entityType: column('entityType', 'string'),
    entityId: column('entityId', 'string'),
    actionType: column('actionType', 'string'),
    subjectId: column('subjectId', 'string').nullable(),
    ipAddress: column('ipAddress', 'string').nullable(),
    userAgent: column('userAgent', 'string').nullable(),
    changes: column('changes', 'json').nullable(),
    metadata: column('metadata', 'json').nullable(),
    createdAt: column('createdAt', 'timestamp').defaultTo$('now'),
    eventTimezone: column('eventTimezone', 'string').defaultTo$(()=>'UTC')
});
z.object({
    id: z.string(),
    entityType: z.string(),
    entityId: z.string(),
    actionType: z.string(),
    subjectId: z.string().optional(),
    ipAddress: z.string().optional(),
    userAgent: z.string().optional(),
    changes: z.record(z.string(), z.unknown()).optional(),
    metadata: z.record(z.string(), z.unknown()).optional(),
    createdAt: z.date().prefault(()=>new Date()),
    eventTimezone: z.string().prefault('UTC')
});
const consentTable = table('consent', {
    id: idColumn('id', 'varchar(255)'),
    subjectId: column('subjectId', 'string'),
    domainId: column('domainId', 'string'),
    policyId: column('policyId', 'string').nullable(),
    purposeIds: column('purposeIds', 'json'),
    metadata: column('metadata', 'json').nullable(),
    ipAddress: column('ipAddress', 'string').nullable(),
    userAgent: column('userAgent', 'string').nullable(),
    status: column('status', 'string').defaultTo$(()=>'active'),
    withdrawalReason: column('withdrawalReason', 'string').nullable(),
    givenAt: column('givenAt', 'timestamp').defaultTo$('now'),
    validUntil: column('validUntil', 'timestamp').nullable(),
    isActive: column('isActive', 'bool').defaultTo$(()=>true)
});
const consentStatusSchema = z["enum"]([
    'active',
    'withdrawn',
    'expired'
]);
z.object({
    id: z.string(),
    subjectId: z.string(),
    domainId: z.string(),
    purposeIds: z.array(z.string()),
    metadata: z.record(z.string(), z.unknown()).nullish(),
    policyId: z.string().optional(),
    ipAddress: z.string().nullish(),
    userAgent: z.string().nullish(),
    status: consentStatusSchema.prefault('active'),
    withdrawalReason: z.string().nullish(),
    givenAt: z.date().prefault(()=>new Date()),
    validUntil: z.date().nullish(),
    isActive: z.boolean().prefault(true)
});
const consentPolicyTable = table('consentPolicy', {
    id: idColumn('id', 'varchar(255)'),
    version: column('version', 'string'),
    type: column('type', 'string'),
    name: column('name', 'string'),
    effectiveDate: column('effectiveDate', 'timestamp'),
    expirationDate: column('expirationDate', 'timestamp').nullable(),
    content: column('content', 'string'),
    contentHash: column('contentHash', 'string'),
    isActive: column('isActive', 'bool').defaultTo$(()=>true),
    createdAt: column('createdAt', 'timestamp').defaultTo$('now')
});
const PolicyTypeSchema = z["enum"]([
    'cookie_banner',
    'privacy_policy',
    'dpa',
    'terms_and_conditions',
    'marketing_communications',
    'age_verification',
    'other'
]);
z.object({
    id: z.string(),
    version: z.string(),
    type: PolicyTypeSchema,
    name: z.string(),
    effectiveDate: z.date(),
    expirationDate: z.date().nullish(),
    content: z.string(),
    contentHash: z.string(),
    isActive: z.boolean().prefault(true),
    createdAt: z.date().prefault(()=>new Date())
});
const consentPurposeTable = table('consentPurpose', {
    id: idColumn('id', 'varchar(255)'),
    code: column('code', 'string'),
    name: column('name', 'string'),
    description: column("description", 'string'),
    isEssential: column('isEssential', 'bool'),
    dataCategory: column('dataCategory', 'string').nullable(),
    legalBasis: column('legalBasis', 'string').nullable(),
    isActive: column('isActive', 'bool').defaultTo$(()=>true),
    createdAt: column('createdAt', 'timestamp').defaultTo$('now'),
    updatedAt: column('updatedAt', 'timestamp').defaultTo$('now')
});
z.object({
    id: z.string(),
    code: z.string(),
    name: z.string(),
    description: z.string(),
    isEssential: z.boolean(),
    dataCategory: z.string().nullish(),
    legalBasis: z.string().nullish(),
    isActive: z.boolean().prefault(true),
    createdAt: z.date().prefault(()=>new Date()),
    updatedAt: z.date().prefault(()=>new Date())
});
const consentRecordTable = table('consentRecord', {
    id: idColumn('id', 'varchar(255)'),
    subjectId: column('subjectId', 'string'),
    consentId: column('consentId', 'string').nullable(),
    actionType: column('actionType', 'string'),
    details: column('details', 'json').nullable(),
    createdAt: column('createdAt', 'timestamp').defaultTo$('now')
});
z.object({
    id: z.string(),
    subjectId: z.string(),
    consentId: z.string().nullish(),
    actionType: z.string(),
    details: z.record(z.string(), z.unknown()).nullish(),
    createdAt: z.date().prefault(()=>new Date())
});
const domainTable = table('domain', {
    id: idColumn('id', 'varchar(255)'),
    name: column('name', 'string').unique(),
    description: column("description", 'string').nullable(),
    allowedOrigins: column('allowedOrigins', 'json').nullable(),
    isVerified: column('isVerified', 'bool').defaultTo$(()=>true),
    isActive: column('isActive', 'bool').defaultTo$(()=>true),
    createdAt: column('createdAt', 'timestamp').defaultTo$('now'),
    updatedAt: column('updatedAt', 'timestamp').defaultTo$('now')
});
z.object({
    id: z.string(),
    name: z.string(),
    description: z.string().nullish(),
    allowedOrigins: z.array(z.string()).nullish(),
    isVerified: z.boolean().prefault(true),
    isActive: z.boolean().prefault(true),
    createdAt: z.date().prefault(()=>new Date()),
    updatedAt: z.date().prefault(()=>new Date())
});
const subjectTable = table('subject', {
    id: idColumn('id', 'varchar(255)'),
    isIdentified: column('isIdentified', 'bool').defaultTo$(()=>false),
    externalId: column('externalId', 'string').nullable(),
    identityProvider: column('identityProvider', 'string').nullable(),
    lastIpAddress: column('lastIpAddress', 'string').nullable(),
    subjectTimezone: column('subjectTimezone', 'string').nullable(),
    createdAt: column('createdAt', 'timestamp').defaultTo$('now'),
    updatedAt: column('updatedAt', 'timestamp').defaultTo$('now')
});
z.object({
    id: z.string(),
    isIdentified: z.boolean().prefault(false),
    externalId: z.string().nullish(),
    identityProvider: z.string().nullish(),
    lastIpAddress: z.string().optional(),
    subjectTimezone: z.string().nullish(),
    createdAt: z.date().prefault(()=>new Date()),
    updatedAt: z.date().prefault(()=>new Date())
});
const v1 = schema({
    version: '1.0.0',
    tables: {
        subject: subjectTable,
        domain: domainTable,
        consentPolicy: consentPolicyTable,
        consentPurpose: consentPurposeTable,
        consent: consentTable,
        auditLog: auditLogTable,
        consentRecord: consentRecordTable
    },
    relations: {
        subject: ({ many })=>({
                consents: many('consent'),
                consentRecords: many('consentRecord'),
                auditLogs: many('auditLog')
            }),
        domain: ({ many })=>({
                consents: many('consent')
            }),
        consentPolicy: ({ many })=>({
                consents: many('consent')
            }),
        consentPurpose: ()=>({}),
        consent: ({ one, many })=>({
                subject: one('subject', [
                    'subjectId',
                    'id'
                ]).foreignKey(),
                domain: one('domain', [
                    'domainId',
                    'id'
                ]).foreignKey(),
                policy: one('consentPolicy', [
                    'policyId',
                    'id'
                ]).foreignKey(),
                consentRecords: many('consentRecord')
            }),
        consentRecord: ({ one })=>({
                subject: one('subject', [
                    'subjectId',
                    'id'
                ]).foreignKey(),
                consent: one('consent', [
                    'consentId',
                    'id'
                ]).foreignKey()
            }),
        auditLog: ({ one })=>({
                subject: one('subject', [
                    'subjectId',
                    'id'
                ]).foreignKey()
            })
    }
});
const DB = fumadb({
    namespace: 'c15t',
    schemas: [
        v1
    ]
});
const baseConsentSchema = z.object({
    subjectId: z.string().optional(),
    externalSubjectId: z.string().optional(),
    identityProvider: z.string().optional(),
    domain: z.string(),
    type: PolicyTypeSchema,
    metadata: z.record(z.string(), z.unknown()).optional()
});
const cookieBannerSchema = baseConsentSchema.extend({
    type: z.literal('cookie_banner'),
    preferences: z.record(z.string(), z.boolean())
});
const policyBasedSchema = baseConsentSchema.extend({
    type: z["enum"]([
        'privacy_policy',
        'dpa',
        'terms_and_conditions'
    ]),
    policyId: z.string().optional(),
    preferences: z.record(z.string(), z.boolean()).optional()
});
const otherConsentSchema = baseConsentSchema.extend({
    type: z["enum"]([
        'marketing_communications',
        'age_verification',
        'other'
    ]),
    preferences: z.record(z.string(), z.boolean()).optional()
});
const postConsentContract = oc.route({
    method: 'POST',
    path: '/consent/set',
    description: `Records a user's consent preferences and creates necessary consent records.
This endpoint handles various types of consent submissions:

1. Cookie Banner Consent:
   - Records granular cookie preferences
   - Supports multiple consent purposes
   - Creates audit trail for compliance

2. Policy-Based Consent:
   - Privacy Policy acceptance
   - Data Processing Agreement (DPA) consent
   - Terms and Conditions acceptance
   - Links consent to specific policy versions

3. Other Consent Types:
   - Marketing communications preferences
   - Age verification consent
   - Custom consent types

The endpoint performs the following operations:
- Creates or retrieves subject records
- Validates domain and policy information
- Creates consent records with audit trails
- Records consent purposes and preferences
- Generates audit logs for compliance

Use this endpoint to record user consent and maintain a compliant consent management system.`,
    tags: [
        'consent',
        'cookie-banner'
    ]
}).errors({
    INPUT_VALIDATION_FAILED: {
        status: 422,
        data: z.object({
            formErrors: z.array(z.string()),
            fieldErrors: z.record(z.string(), z.array(z.string()))
        }),
        error: 'Invalid input parameters'
    },
    SUBJECT_CREATION_FAILED: {
        status: 400,
        data: z.object({
            subjectId: z.string().optional(),
            externalSubjectId: z.string().optional()
        }),
        error: 'Failed to create or find subject'
    },
    DOMAIN_CREATION_FAILED: {
        status: 500,
        data: z.object({
            domain: z.string()
        }),
        error: 'Failed to create or find domain'
    },
    POLICY_NOT_FOUND: {
        status: 404,
        data: z.object({
            policyId: z.string(),
            type: z.string()
        }),
        error: 'Policy not found'
    },
    POLICY_INACTIVE: {
        status: 409,
        data: z.object({
            policyId: z.string(),
            type: z.string()
        }),
        error: 'Policy is not active'
    },
    POLICY_CREATION_FAILED: {
        status: 500,
        data: z.object({
            type: z.string()
        }),
        error: 'Failed to create or find policy'
    },
    PURPOSE_CREATION_FAILED: {
        status: 500,
        data: z.object({
            purposeCode: z.string()
        }),
        error: 'Failed to create consent purpose'
    },
    CONSENT_CREATION_FAILED: {
        status: 500,
        data: z.object({
            subjectId: z.string(),
            domain: z.string()
        }),
        error: 'Failed to create consent record'
    }
}).input(z.discriminatedUnion('type', [
    cookieBannerSchema,
    policyBasedSchema,
    otherConsentSchema
])).output(z.object({
    id: z.string(),
    subjectId: z.string().optional(),
    externalSubjectId: z.string().optional(),
    domainId: z.string(),
    domain: z.string(),
    type: PolicyTypeSchema,
    status: z.string(),
    recordId: z.string(),
    metadata: z.record(z.string(), z.unknown()).optional(),
    givenAt: z.date()
}));
const types_branding = [
    'c15t',
    'consent',
    'none'
];
const JurisdictionMessages = {
    GDPR: 'GDPR or equivalent regulations require a cookie banner.',
    CH: 'Switzerland requires similar data protection measures.',
    BR: "Brazil's LGPD requires consent for cookies.",
    PIPEDA: 'PIPEDA requires consent for data collection.',
    AU: "Australia's Privacy Act mandates transparency about data collection.",
    APPI: "Japan's APPI requires consent for data collection.",
    PIPA: "South Korea's PIPA requires consent for data collection.",
    NONE: 'No specific requirements'
};
const JurisdictionCodeSchema = z["enum"]([
    'GDPR',
    'CH',
    'BR',
    'PIPEDA',
    'AU',
    'APPI',
    'PIPA',
    'NONE'
]);
const JurisdictionInfoSchema = z.object({
    code: JurisdictionCodeSchema,
    message: z.string()
});
const TitleDescriptionSchema = z.object({
    title: z.string(),
    description: z.string()
});
const CompleteTranslationsSchema = z.object({
    common: z.object({
        acceptAll: z.string(),
        rejectAll: z.string(),
        customize: z.string(),
        save: z.string()
    }),
    cookieBanner: TitleDescriptionSchema,
    consentManagerDialog: TitleDescriptionSchema,
    consentTypes: z.object({
        experience: TitleDescriptionSchema,
        functionality: TitleDescriptionSchema,
        marketing: TitleDescriptionSchema,
        measurement: TitleDescriptionSchema,
        necessary: TitleDescriptionSchema
    }),
    frame: z.object({
        title: z.string(),
        actionButton: z.string()
    }),
    legalLinks: z.object({
        privacyPolicy: z.string(),
        termsOfService: z.string(),
        cookiePolicy: z.string()
    })
});
const PartialTranslationsSchema = z.object({
    common: z.object({
        acceptAll: z.string().optional(),
        rejectAll: z.string().optional(),
        customize: z.string().optional(),
        save: z.string().optional()
    }).partial(),
    cookieBanner: TitleDescriptionSchema.partial(),
    consentManagerDialog: TitleDescriptionSchema.partial(),
    consentTypes: z.object({
        experience: TitleDescriptionSchema.partial(),
        functionality: TitleDescriptionSchema.partial(),
        marketing: TitleDescriptionSchema.partial(),
        measurement: TitleDescriptionSchema.partial(),
        necessary: TitleDescriptionSchema.partial()
    }).partial(),
    frame: z.object({
        title: z.string().optional(),
        actionButton: z.string().optional()
    }).partial().optional(),
    legalLinks: z.object({
        privacyPolicy: z.string().optional(),
        termsOfService: z.string().optional(),
        cookiePolicy: z.string().optional()
    }).partial().optional()
});
const TranslationsSchema = z.union([
    CompleteTranslationsSchema,
    PartialTranslationsSchema
]);
const showConsentBannerContract = oc.route({
    method: 'GET',
    path: '/show-consent-banner',
    description: `Determines if a user should see a consent banner based on their location and applicable privacy regulations.
This endpoint performs the following checks:

1. Detects the user's location using various header information:
   - Cloudflare country headers
   - Vercel IP country headers
   - AWS CloudFront headers
   - Custom country code headers

2. Determines the applicable jurisdiction based on the location:
   - GDPR (EU/EEA/UK)
   - Swiss Data Protection Act
   - LGPD (Brazil)
   - PIPEDA (Canada)
   - Australian Privacy Principles
   - APPI (Japan)
   - PIPA (South Korea)

3. Returns detailed information about:
   - Whether to show the consent banner
   - The applicable jurisdiction and its requirements
   - The user's detected location (country and region)

Use this endpoint to implement geo-targeted consent banners and ensure compliance with regional privacy regulations.`,
    tags: [
        'cookie-banner'
    ]
}).output(z.object({
    showConsentBanner: z.boolean(),
    jurisdiction: JurisdictionInfoSchema,
    location: z.object({
        countryCode: z.string().nullable(),
        regionCode: z.string().nullable()
    }),
    translations: z.object({
        language: z.string(),
        translations: TranslationsSchema
    }),
    branding: z["enum"](types_branding)
}));
const verifyConsentInputSchema = z.strictObject({
    subjectId: z.string().optional(),
    externalSubjectId: z.string().optional(),
    domain: z.string(),
    type: PolicyTypeSchema,
    policyId: z.string().optional(),
    preferences: z.array(z.string()).optional()
});
const verify_contract_consentSchema = z.looseObject({
    id: z.string(),
    purposeIds: z.array(z.string())
});
const verifyConsentContract = oc.route({
    method: 'POST',
    path: '/consent/verify',
    description: `Verifies if a user has given valid consent for a specific policy and domain.
This endpoint performs comprehensive consent verification by:

1. Validating the subject's identity (using subjectId or externalSubjectId)
2. Verifying the domain's existence and validity
3. Checking if the specified policy exists and is active
4. Validating that all required purposes have been consented to
5. Ensuring the consent record is current and valid

The endpoint supports different types of consent verification:
- Cookie banner consent verification
- Privacy policy consent verification
- Terms and conditions verification
- Marketing communications consent verification
- Age verification
- Custom consent types

Use this endpoint to ensure compliance with privacy regulations and to verify user consent before processing personal data.`,
    tags: [
        'consent'
    ]
}).errors({
    INPUT_VALIDATION_FAILED: {
        status: 422,
        data: z.object({
            formErrors: z.array(z.string()),
            fieldErrors: z.record(z.string(), z.array(z.string()).optional())
        }),
        error: 'Invalid input parameters'
    },
    SUBJECT_NOT_FOUND: {
        status: 404,
        data: z.object({
            subjectId: z.string().optional(),
            externalSubjectId: z.string().optional()
        }),
        error: 'Subject not found'
    },
    DOMAIN_NOT_FOUND: {
        status: 404,
        data: z.object({
            domain: z.string()
        }),
        error: 'Domain not found'
    },
    POLICY_NOT_FOUND: {
        status: 404,
        data: z.object({
            policyId: z.string(),
            type: z.string()
        }),
        error: 'Policy not found or invalid'
    },
    PURPOSES_NOT_FOUND: {
        status: 404,
        data: z.object({
            preferences: z.array(z.string()),
            foundPurposes: z.array(z.string())
        }),
        error: 'Could not find all specified purposes'
    },
    COOKIE_BANNER_PREFERENCES_REQUIRED: {
        status: 400,
        data: z.object({
            type: z.literal('cookie_banner')
        }),
        error: 'Preferences are required for cookie banner consent'
    },
    NO_CONSENT_FOUND: {
        status: 404,
        data: z.object({
            policyId: z.string(),
            subjectId: z.string(),
            domainId: z.string()
        }),
        error: 'No consent found for the given policy'
    }
}).input(verifyConsentInputSchema).output(z.object({
    isValid: z.boolean(),
    reasons: z.array(z.string()).optional(),
    consent: verify_contract_consentSchema.optional()
}));
const consentContracts = {
    post: postConsentContract,
    showBanner: showConsentBannerContract,
    verify: verifyConsentContract,
    identify: identifyUserContract
};
const statusContract = oc.route({
    method: 'GET',
    path: '/status',
    description: `Returns the current operational status and health metrics of the service.
This endpoint provides real-time information about:
- Overall service status (ok/error)
- Current API version
- Server timestamp
- Storage system status and availability
- Client information (IP, User Agent, Region)

Use this endpoint for health checks, monitoring, and service status verification.`,
    tags: [
        'meta'
    ]
}).output(z.object({
    status: z["enum"]([
        'ok',
        'error'
    ]),
    version: z.string(),
    timestamp: z.date(),
    client: z.object({
        ip: z.string().nullable(),
        userAgent: z.string().nullable(),
        region: z.object({
            countryCode: z.string().nullable(),
            regionCode: z.string().nullable()
        })
    })
}));
const metaContracts = {
    status: statusContract
};
const contracts_config = {
    consent: consentContracts,
    meta: metaContracts
};
const os = implement(contracts_config);
const prefixes = {
    auditLog: 'log',
    consent: 'cns',
    consentPolicy: 'pol',
    consentPurpose: 'pur',
    consentRecord: 'rec',
    domain: 'dom',
    subject: 'sub'
};
const b58 = base_x('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');
function generateId(model) {
    const buf = crypto.getRandomValues(new Uint8Array(20));
    const prefix = prefixes[model];
    const EPOCH_TIMESTAMP = 1700000000000;
    const t = Date.now() - EPOCH_TIMESTAMP;
    const high = Math.floor(t / 0x100000000);
    const low = t >>> 0;
    buf[0] = high >>> 24 & 255;
    buf[1] = high >>> 16 & 255;
    buf[2] = high >>> 8 & 255;
    buf[3] = 255 & high;
    buf[4] = low >>> 24 & 255;
    buf[5] = low >>> 16 & 255;
    buf[6] = low >>> 8 & 255;
    buf[7] = 255 & low;
    return `${prefix}_${b58.encode(buf)}`;
}
async function generateUniqueId(db, model, ctx, options = {}) {
    const { maxRetries = 10, attempt = 0, baseDelay = 5 } = options;
    if (attempt >= maxRetries) {
        const error = new Error(`Failed to generate unique ID for ${model} after ${maxRetries} attempts`);
        ctx?.logger?.error?.('ID generation failed', {
            model,
            maxRetries
        });
        throw error;
    }
    const id = generateId(model);
    try {
        const existing = await db.findFirst(model, {
            where: (b)=>b('id', '=', id)
        });
        if (existing) {
            ctx?.logger?.debug?.('ID conflict detected', {
                id,
                model,
                attempt: attempt + 1,
                maxRetries
            });
            const delay = Math.min(baseDelay * 2 ** attempt, 1000);
            await new Promise((resolve)=>setTimeout(resolve, delay));
            return generateUniqueId(db, model, ctx, {
                maxRetries,
                attempt: attempt + 1,
                baseDelay
            });
        }
        return id;
    } catch (error) {
        ctx?.logger?.error?.('Error checking ID uniqueness', {
            error: error.message,
            model,
            attempt
        });
        if (attempt < maxRetries - 1) {
            const delay = Math.min(baseDelay * 2 ** attempt, 2000);
            await new Promise((resolve)=>setTimeout(resolve, delay));
            return generateUniqueId(db, model, ctx, {
                maxRetries,
                attempt: attempt + 1,
                baseDelay
            });
        }
        throw error;
    }
}
const identifyUser = os.consent.identify.handler(async ({ input, context })=>{
    const typedContext = context;
    const { db, logger } = typedContext;
    logger.info('Handling identify-user request');
    const { consentId, externalId, identityProvider = 'external' } = input;
    const consent = await db.findFirst('consent', {
        where: (b)=>b('id', '=', consentId)
    });
    if (!consent) throw new ORPCError('CONSENT_NOT_FOUND', {
        data: {
            consentId
        }
    });
    await db.transaction(async (tx)=>{
        const existingSubject = await tx.findFirst('subject', {
            where: (b)=>b.and(b('externalId', '=', externalId), b('id', '!=', consent.subjectId))
        });
        if (existingSubject) {
            const currentSubjectId = consent.subjectId;
            const oldSubjectId = existingSubject.id;
            logger.info('Merging subjects', {
                currentSubjectId,
                oldSubjectId,
                externalId,
                identityProvider
            });
            await tx.updateMany('consent', {
                where: (b)=>b('subjectId', '=', currentSubjectId),
                set: {
                    subjectId: oldSubjectId
                }
            });
            await tx.updateMany('consentRecord', {
                where: (b)=>b('subjectId', '=', currentSubjectId),
                set: {
                    subjectId: oldSubjectId
                }
            });
            await tx.updateMany('auditLog', {
                where: (b)=>b('subjectId', '=', currentSubjectId),
                set: {
                    subjectId: oldSubjectId
                }
            });
            await tx.deleteMany('subject', {
                where: (b)=>b('id', '=', currentSubjectId)
            });
            await tx.create('auditLog', {
                id: await generateUniqueId(tx, 'auditLog', typedContext),
                subjectId: oldSubjectId,
                entityType: 'consent',
                entityId: consent.id,
                actionType: 'identify_user',
                ipAddress: typedContext.ipAddress || null,
                userAgent: typedContext.userAgent || null,
                eventTimezone: 'UTC',
                metadata: {
                    externalId,
                    identityProvider,
                    mergedFrom: currentSubjectId
                }
            });
        } else {
            await tx.updateMany('subject', {
                where: (b)=>b('id', '=', consent.subjectId),
                set: {
                    externalId,
                    identityProvider,
                    isIdentified: true,
                    updatedAt: new Date()
                }
            });
            await tx.create('auditLog', {
                id: await generateUniqueId(tx, 'auditLog', typedContext),
                subjectId: consent.subjectId,
                entityType: 'consent',
                entityId: consent.id,
                actionType: 'identify_user',
                ipAddress: typedContext.ipAddress || null,
                userAgent: typedContext.userAgent || null,
                eventTimezone: 'UTC',
                metadata: {
                    externalId,
                    identityProvider
                }
            });
        }
    });
    return {
        success: true
    };
});
const postConsent = os.consent.post.handler(async ({ input, context })=>{
    const typedContext = context;
    const logger = typedContext.logger;
    logger.info('Handling post-consent request');
    const { db, registry } = typedContext;
    const { type, subjectId, identityProvider, externalSubjectId, domain, metadata, preferences } = input;
    logger.debug('Request parameters', {
        type,
        subjectId,
        identityProvider,
        externalSubjectId,
        domain
    });
    try {
        const subject = await registry.findOrCreateSubject({
            subjectId,
            externalSubjectId,
            identityProvider,
            ipAddress: typedContext.ipAddress
        });
        if (!subject) throw new ORPCError('SUBJECT_CREATION_FAILED', {
            data: {
                subjectId,
                externalSubjectId
            }
        });
        logger.debug('Subject found/created', {
            subjectId: subject.id
        });
        const domainRecord = await typedContext.registry.findOrCreateDomain(domain);
        if (!domainRecord) throw new ORPCError('DOMAIN_CREATION_FAILED', {
            data: {
                domain
            }
        });
        let policyId;
        let purposeIds = [];
        if ('policyId' in input && input.policyId) {
            policyId = input.policyId;
            const policy = await typedContext.registry.findConsentPolicyById(policyId);
            if (!policy) throw new ORPCError('POLICY_NOT_FOUND', {
                data: {
                    policyId,
                    type
                }
            });
            if (!policy.isActive) throw new ORPCError('POLICY_INACTIVE', {
                data: {
                    policyId,
                    type
                }
            });
        } else {
            const policy = await typedContext.registry.findOrCreatePolicy(type);
            if (!policy) throw new ORPCError('POLICY_CREATION_FAILED', {
                data: {
                    type
                }
            });
            policyId = policy.id;
        }
        if (preferences) {
            const consentedPurposes = Object.entries(preferences).filter(([_, isConsented])=>isConsented).map(([purposeCode])=>purposeCode);
            logger.debug('Consented purposes', {
                consentedPurposes
            });
            const purposesRaw = await Promise.all(consentedPurposes.map((purposeCode)=>typedContext.registry.findOrCreateConsentPurposeByCode(purposeCode)));
            const purposes = purposesRaw.map((purpose)=>purpose?.id);
            logger.debug('Purposes: ', {
                purposes
            });
            purposeIds = purposes;
        }
        const result = await db.transaction(async (tx)=>{
            logger.debug('Creating consent record', {
                subjectId: subject.id,
                domainId: domainRecord.id,
                policyId,
                purposeIds
            });
            const consentRecord = await tx.create('consent', {
                id: await generateUniqueId(tx, 'consent', typedContext),
                subjectId: subject.id,
                domainId: domainRecord.id,
                policyId,
                purposeIds: {
                    json: purposeIds
                },
                status: 'active',
                isActive: true,
                ipAddress: typedContext.ipAddress || null,
                userAgent: typedContext.userAgent || null
            });
            logger.debug('Created consent', {
                consentRecord: consentRecord.id
            });
            logger.debug('Creating consentRecord entry', {
                subjectId: subject.id,
                consentId: consentRecord.id,
                actionType: 'consent_given',
                details: metadata
            });
            const record = await tx.create('consentRecord', {
                id: await generateUniqueId(tx, 'consentRecord', typedContext),
                subjectId: subject.id,
                consentId: consentRecord.id,
                actionType: 'consent_given',
                details: metadata
            });
            logger.debug('Created record entry', {
                record: record.id
            });
            logger.debug('Creating audit log', {
                subjectId: subject.id,
                entityType: 'consent',
                entityId: consentRecord.id,
                actionType: 'consent_given',
                metadata: metadata
            });
            await tx.create('auditLog', {
                id: await generateUniqueId(tx, 'auditLog', typedContext),
                subjectId: subject.id,
                entityType: 'consent',
                entityId: consentRecord.id,
                actionType: 'consent_given',
                metadata: {
                    consentId: consentRecord.id,
                    type
                },
                ipAddress: typedContext.ipAddress || null,
                userAgent: typedContext.userAgent || null,
                eventTimezone: 'UTC'
            });
            logger.debug('Created audit log');
            if (!consentRecord || !record) throw new ORPCError('CONSENT_CREATION_FAILED', {
                data: {
                    subjectId: subject.id,
                    domain
                }
            });
            return {
                consent: consentRecord,
                record
            };
        });
        return {
            id: result.consent.id,
            subjectId: subject.id,
            externalSubjectId: subject.externalId ?? void 0,
            identityProvider: subject.identityProvider ?? void 0,
            domainId: domainRecord.id,
            domain: domainRecord.name,
            type,
            status: result.consent.status,
            recordId: result.record.id,
            metadata,
            givenAt: result.consent.givenAt
        };
    } catch (error) {
        logger.error('Error in post-consent handler', {
            error: error instanceof Error ? error.message : String(error),
            errorType: error instanceof Error ? error.constructor.name : typeof error
        });
        if (error instanceof ORPCError) throw error;
        throw new ORPCError('INTERNAL_SERVER_ERROR', {
            message: error instanceof Error ? error.message : String(error)
        });
    }
});
function checkJurisdiction(countryCode) {
    const jurisdictions = {
        EU: new Set([
            'AT',
            'BE',
            'BG',
            'HR',
            'CY',
            'CZ',
            'DK',
            'EE',
            'FI',
            'FR',
            'DE',
            'GR',
            'HU',
            'IE',
            'IT',
            'LV',
            'LT',
            'LU',
            'MT',
            'NL',
            'PL',
            'PT',
            'RO',
            'SK',
            'SI',
            'ES',
            'SE'
        ]),
        EEA: new Set([
            'IS',
            'NO',
            'LI'
        ]),
        UK: new Set([
            'GB'
        ]),
        CH: new Set([
            'CH'
        ]),
        BR: new Set([
            'BR'
        ]),
        CA: new Set([
            'CA'
        ]),
        AU: new Set([
            'AU'
        ]),
        JP: new Set([
            'JP'
        ]),
        KR: new Set([
            'KR'
        ])
    };
    let showConsentBanner = true;
    let jurisdictionCode = 'NONE';
    if (countryCode) {
        const normalizedCountryCode = countryCode.toUpperCase();
        showConsentBanner = false;
        const jurisdictionMap = [
            {
                sets: [
                    jurisdictions.EU,
                    jurisdictions.EEA,
                    jurisdictions.UK
                ],
                code: 'GDPR'
            },
            {
                sets: [
                    jurisdictions.CH
                ],
                code: 'CH'
            },
            {
                sets: [
                    jurisdictions.BR
                ],
                code: 'BR'
            },
            {
                sets: [
                    jurisdictions.CA
                ],
                code: 'PIPEDA'
            },
            {
                sets: [
                    jurisdictions.AU
                ],
                code: 'AU'
            },
            {
                sets: [
                    jurisdictions.JP
                ],
                code: 'APPI'
            },
            {
                sets: [
                    jurisdictions.KR
                ],
                code: 'PIPA'
            }
        ];
        for (const { sets, code } of jurisdictionMap)if (sets.some((set)=>set.has(normalizedCountryCode))) {
            jurisdictionCode = code;
            showConsentBanner = true;
            break;
        }
    }
    const message = JurisdictionMessages[jurisdictionCode];
    return {
        showConsentBanner,
        jurisdictionCode,
        message
    };
}
function isSupportedBaseLanguage(lang) {
    return lang in baseTranslations;
}
function getPreferredLanguage(acceptLanguage, supportedLanguages) {
    if (!acceptLanguage) return 'en';
    const primaryLang = acceptLanguage.split(',')[0]?.split(';')[0]?.split('-')[0]?.toLowerCase();
    if (primaryLang && supportedLanguages.includes(primaryLang)) return primaryLang;
    return 'en';
}
function getTranslations(acceptLanguage, customTranslations) {
    const supportedDefaultLanguages = Object.keys(baseTranslations);
    const supportedCustomLanguages = Object.keys(customTranslations || {});
    const supportedLanguages = [
        ...supportedDefaultLanguages,
        ...supportedCustomLanguages
    ];
    const preferredLanguage = getPreferredLanguage(acceptLanguage, supportedLanguages);
    const base = isSupportedBaseLanguage(preferredLanguage) ? baseTranslations[preferredLanguage] : baseTranslations.en;
    const custom = supportedCustomLanguages.includes(preferredLanguage) ? customTranslations?.[preferredLanguage] : {};
    const translations = custom ? deepMergeTranslations(base, custom) : base;
    return {
        translations: translations,
        language: preferredLanguage
    };
}
function getHeaders(headers) {
    if (!headers) return {
        countryCode: null,
        regionCode: null,
        acceptLanguage: null
    };
    const normalizeHeader = (value)=>{
        if (!value) return null;
        return Array.isArray(value) ? value[0] ?? null : value;
    };
    const countryCode = normalizeHeader(headers.get('x-c15t-country')) ?? normalizeHeader(headers.get('cf-ipcountry')) ?? normalizeHeader(headers.get('x-vercel-ip-country')) ?? normalizeHeader(headers.get('x-amz-cf-ipcountry')) ?? normalizeHeader(headers.get('x-country-code'));
    const regionCode = normalizeHeader(headers.get('x-c15t-region')) ?? normalizeHeader(headers.get('x-vercel-ip-country-region')) ?? normalizeHeader(headers.get('x-region-code'));
    const acceptLanguage = normalizeHeader(headers.get('accept-language'));
    return {
        countryCode,
        regionCode,
        acceptLanguage
    };
}
function buildResponse({ shouldShowBanner, jurisdiction, location, acceptLanguage, customTranslations, branding = 'c15t' }) {
    return {
        showConsentBanner: shouldShowBanner,
        jurisdiction,
        location,
        translations: getTranslations(acceptLanguage, customTranslations),
        branding: branding
    };
}
const handler_showConsentBanner = os.consent.showBanner.handler(({ context })=>{
    const typedContext = context;
    const { customTranslations, disableGeoLocation, branding } = typedContext.advanced ?? {};
    const { countryCode, regionCode, acceptLanguage } = getHeaders(typedContext.headers);
    if (disableGeoLocation) return buildResponse({
        shouldShowBanner: true,
        jurisdiction: {
            code: 'NONE',
            message: JurisdictionMessages.NONE
        },
        location: {
            countryCode: null,
            regionCode: null
        },
        acceptLanguage,
        customTranslations,
        branding
    });
    const { showConsentBanner, jurisdictionCode, message } = checkJurisdiction(countryCode);
    return buildResponse({
        shouldShowBanner: showConsentBanner,
        jurisdiction: {
            code: jurisdictionCode,
            message
        },
        location: {
            countryCode,
            regionCode
        },
        acceptLanguage,
        customTranslations,
        branding
    });
});
const verifyConsent = os.consent.verify.handler(async ({ input, context })=>{
    const typedContext = context;
    const logger = typedContext.logger;
    logger.info('Handling verify-consent request');
    const { type, subjectId, externalSubjectId, domain, policyId, preferences } = input;
    logger.debug('Request parameters', {
        type,
        subjectId,
        externalSubjectId,
        domain,
        policyId,
        preferences
    });
    try {
        const domainRecord = await typedContext.registry.findDomainByName(domain);
        if (!domainRecord) throw new ORPCError('DOMAIN_NOT_FOUND', {
            data: {
                domain
            }
        });
        const subject = await typedContext.registry.findOrCreateSubject({
            subjectId,
            externalSubjectId,
            ipAddress: typedContext.ipAddress ?? 'unknown'
        });
        if (!subject) throw new ORPCError('SUBJECT_NOT_FOUND', {
            data: {
                subjectId,
                externalSubjectId
            }
        });
        if ('cookie_banner' === type && (!preferences || 0 === preferences.length)) throw new ORPCError('COOKIE_BANNER_PREFERENCES_REQUIRED', {
            data: {
                type: 'cookie_banner'
            }
        });
        const purposePromises = preferences?.map((purpose)=>typedContext.registry.findOrCreateConsentPurposeByCode(purpose));
        const rawPurposes = await Promise.all(purposePromises ?? []);
        const purposeIds = rawPurposes.filter((purpose)=>null !== purpose).map((purpose)=>purpose.id);
        if (purposeIds.length !== (preferences?.length ?? 0)) throw new ORPCError('PURPOSES_NOT_FOUND', {
            data: {
                preferences: preferences ?? [],
                foundPurposes: rawPurposes.filter((p)=>null !== p).map((p)=>p.code)
            }
        });
        if (policyId) {
            const policy = await typedContext.registry.findConsentPolicyById(policyId);
            if (!policy || policy.type !== type) throw new ORPCError('POLICY_NOT_FOUND', {
                data: {
                    policyId,
                    type
                }
            });
            return await checkPolicyConsent({
                policyId: policy.id,
                subjectId: subject.id,
                domainId: domainRecord.id,
                purposeIds,
                type,
                context: typedContext
            });
        }
        const latestPolicy = await typedContext.registry.findOrCreatePolicy(type);
        if (!latestPolicy) throw new ORPCError('POLICY_NOT_FOUND', {
            data: {
                policyId: 'latest',
                type
            }
        });
        return await checkPolicyConsent({
            policyId: latestPolicy.id,
            subjectId: subject.id,
            domainId: domainRecord.id,
            purposeIds,
            type,
            context: typedContext
        });
    } catch (error) {
        logger.error('Error in verify-consent handler', {
            error: error instanceof Error ? error.message : String(error),
            errorType: error instanceof Error ? error.constructor.name : typeof error
        });
        if (error instanceof ORPCError) throw error;
        throw new ORPCError('INTERNAL_SERVER_ERROR', {
            message: error instanceof Error ? error.message : String(error)
        });
    }
});
async function checkPolicyConsent({ policyId, subjectId, domainId, purposeIds, type, context }) {
    const { registry, db } = context;
    const rawConsents = await db.findMany('consent', {
        where: (b)=>b.and(b('subjectId', '=', subjectId), b('policyId', '=', policyId), b('domainId', '=', domainId)),
        orderBy: [
            'givenAt',
            'desc'
        ]
    });
    const filteredConsents = rawConsents.filter((consent)=>{
        if (!purposeIds) return true;
        return purposeIds.every((id)=>consent.purposeIds.some((purposeId)=>purposeId === id));
    });
    await registry.createAuditLog({
        subjectId,
        entityType: 'consent_policy',
        entityId: policyId,
        actionType: 'verify_consent',
        metadata: {
            type,
            policyId,
            purposeIds,
            success: 0 !== filteredConsents.length,
            ...filteredConsents.length > 0 ? {
                consentId: filteredConsents[0]?.id
            } : {}
        },
        eventTimezone: 'UTC'
    });
    if (0 === rawConsents.length || 0 === filteredConsents.length) return {
        isValid: false
    };
    return {
        isValid: true,
        consent: filteredConsents[0]
    };
}
const consentHandlers = {
    post: postConsent,
    showBanner: handler_showConsentBanner,
    verify: verifyConsent,
    identify: identifyUser
};
const statusHandler = os.meta.status.handler(({ context })=>{
    const typedContext = context;
    const headers = typedContext.headers;
    const normalizeHeader = (value)=>{
        if (!value) return null;
        return Array.isArray(value) ? value[0] ?? null : value;
    };
    const countryCode = normalizeHeader(headers?.get('cf-ipcountry')) ?? normalizeHeader(headers?.get('x-vercel-ip-country')) ?? normalizeHeader(headers?.get('x-amz-cf-ipcountry')) ?? normalizeHeader(headers?.get('x-country-code'));
    const regionCode = normalizeHeader(headers?.get('x-vercel-ip-country-region')) ?? normalizeHeader(headers?.get('x-region-code'));
    return {
        status: 'ok',
        version: "1.8.0",
        timestamp: new Date(),
        client: {
            ip: typedContext.ipAddress ?? null,
            userAgent: typedContext.userAgent ?? null,
            region: {
                countryCode,
                regionCode
            }
        }
    };
});
const metaHandlers = {
    status: statusHandler
};
const router = os.router({
    consent: consentHandlers,
    meta: metaHandlers
});
const mergeOpenAPIOptions = (defaultOptions, userOptions)=>{
    const merged = {
        ...defaultOptions
    };
    if (userOptions.info && 'object' == typeof userOptions.info) merged.info = {
        ...merged.info,
        ...userOptions.info
    };
    for (const [key, value] of Object.entries(userOptions))if ('info' !== key) merged[key] = value;
    return merged;
};
const createOpenAPISpec = (context, options)=>{
    const openAPIGenerator = new OpenAPIGenerator({
        schemaConverters: [
            new ZodToJsonSchemaConverter()
        ]
    });
    const getOpenAPISpec = async ()=>{
        if (getOpenAPISpec.cached) return getOpenAPISpec.cached;
        const defaultOptions = createDefaultOpenAPIOptions(options);
        const mergedOptions = options.advanced?.openapi?.options ? mergeOpenAPIOptions(defaultOptions, options.advanced.openapi.options) : defaultOptions;
        try {
            const spec = await openAPIGenerator.generate(router, mergedOptions);
            getOpenAPISpec.cached = spec;
            return spec;
        } catch (error) {
            context.logger?.error('Failed to generate OpenAPI spec:', error);
            return {
                openapi: '3.0.0',
                info: {
                    title: options.appName || 'c15t API',
                    version: '0.0.0'
                },
                paths: {}
            };
        }
    };
    return getOpenAPISpec;
};
const createDocsUI = (options)=>{
    const config = createOpenAPIConfig(options);
    if (config.customUiTemplate) return config.customUiTemplate;
    return `
    <!doctype html>
    <html>
      <head>
        <title>${options.appName || 'c15t API'} Documentation</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" type="image/svg+xml" href="https://c15t.com/icon.svg" />
      </head>
      <body>
        <script
          id="api-reference"
          data-url="${encodeURI(config.specPath)}">
        </script>
        <script src="https://cdn.jsdelivr.net/npm/@scalar/api-reference"></script>
      </body>
    </html>
  `;
};
const DEFAULT_IP_HEADERS = [
    'x-client-ip',
    'x-forwarded-for',
    'cf-connecting-ip',
    'fastly-client-ip',
    'x-real-ip',
    'x-cluster-client-ip',
    'x-forwarded',
    'forwarded-for',
    'forwarded'
];
function getIpAddress(req, options) {
    const ipAddress = options.advanced?.ipAddress;
    if (ipAddress?.disableIpTracking) return 'unknown';
    const ipHeaders = ipAddress?.ipAddressHeaders || DEFAULT_IP_HEADERS;
    const headers = req instanceof Request ? req.headers : req;
    for (const key of ipHeaders){
        const value = headers.get(key);
        if (value) {
            const ip = value.split(',')[0]?.trim();
            if (ip) return ip;
        }
    }
    return 'unknown';
}
const generate_id_prefixes = {
    auditLog: 'log',
    consent: 'cns',
    consentPolicy: 'pol',
    consentPurpose: 'pur',
    consentRecord: 'rec',
    domain: 'dom',
    subject: 'sub'
};
const generate_id_b58 = base_x('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');
function generate_id_generateId(model) {
    const buf = crypto.getRandomValues(new Uint8Array(20));
    const prefix = generate_id_prefixes[model];
    const EPOCH_TIMESTAMP = 1700000000000;
    const t = Date.now() - EPOCH_TIMESTAMP;
    const high = Math.floor(t / 0x100000000);
    const low = t >>> 0;
    buf[0] = high >>> 24 & 255;
    buf[1] = high >>> 16 & 255;
    buf[2] = high >>> 8 & 255;
    buf[3] = 255 & high;
    buf[4] = low >>> 24 & 255;
    buf[5] = low >>> 16 & 255;
    buf[6] = low >>> 8 & 255;
    buf[7] = 255 & low;
    return `${prefix}_${generate_id_b58.encode(buf)}`;
}
async function generate_id_generateUniqueId(db, model, ctx, options = {}) {
    const { maxRetries = 10, attempt = 0, baseDelay = 5 } = options;
    if (attempt >= maxRetries) {
        const error = new Error(`Failed to generate unique ID for ${model} after ${maxRetries} attempts`);
        ctx?.logger?.error?.('ID generation failed', {
            model,
            maxRetries
        });
        throw error;
    }
    const id = generate_id_generateId(model);
    try {
        const existing = await db.findFirst(model, {
            where: (b)=>b('id', '=', id)
        });
        if (existing) {
            ctx?.logger?.debug?.('ID conflict detected', {
                id,
                model,
                attempt: attempt + 1,
                maxRetries
            });
            const delay = Math.min(baseDelay * 2 ** attempt, 1000);
            await new Promise((resolve)=>setTimeout(resolve, delay));
            return generate_id_generateUniqueId(db, model, ctx, {
                maxRetries,
                attempt: attempt + 1,
                baseDelay
            });
        }
        return id;
    } catch (error) {
        ctx?.logger?.error?.('Error checking ID uniqueness', {
            error: error.message,
            model,
            attempt
        });
        if (attempt < maxRetries - 1) {
            const delay = Math.min(baseDelay * 2 ** attempt, 2000);
            await new Promise((resolve)=>setTimeout(resolve, delay));
            return generate_id_generateUniqueId(db, model, ctx, {
                maxRetries,
                attempt: attempt + 1,
                baseDelay
            });
        }
        throw error;
    }
}
function auditLogRegistry({ db, ctx }) {
    const logger = ctx?.logger ?? {
        debug: ()=>void 0,
        error: ()=>void 0
    };
    return {
        createAuditLog: async (auditLog)=>{
            logger.debug('Creating audit log', {
                auditLog
            });
            const createdLog = await db.create('auditLog', {
                id: await generate_id_generateUniqueId(db, 'auditLog', ctx),
                createdAt: new Date(),
                ...auditLog
            });
            if (!createdLog) {
                logger.error('Failed to create audit log', {
                    auditLog
                });
                throw new ORPCError('INTERNAL_SERVER_ERROR', {
                    message: 'Failed to create audit log',
                    status: 500
                });
            }
            return createdLog;
        }
    };
}
function consentRegistry({ db, ctx }) {
    const { logger } = ctx;
    return {
        createConsent: async (consent)=>{
            logger.debug('Creating consent', {
                consent
            });
            const createdConsent = await db.create('consent', {
                id: await generate_id_generateUniqueId(db, 'consent', ctx),
                subjectId: consent.subjectId,
                domainId: consent.domainId,
                policyId: consent.policyId,
                purposeIds: consent.purposeIds,
                metadata: consent.metadata,
                ipAddress: consent.ipAddress,
                userAgent: consent.userAgent,
                status: consent.status,
                givenAt: consent.givenAt,
                isActive: consent.isActive
            });
            if (!createdConsent) throw new ORPCError('CONSENT_CREATION_FAILED', {
                message: 'Failed to create consent - operation returned null',
                status: 500,
                data: {
                    subjectId: consent.subjectId,
                    domainId: consent.domainId
                }
            });
            return createdConsent;
        }
    };
}
function policyRegistry({ db, ctx }) {
    const { logger } = ctx;
    async function generatePolicyPlaceholder(name, date) {
        const content = `[PLACEHOLDER] This is an automatically generated version of the ${name} policy.\n\nThis placeholder content should be replaced with actual policy terms before being presented to users.\n\nGenerated on: ${date.toISOString()}`;
        let contentHash;
        try {
            const encoder = new TextEncoder();
            const data = encoder.encode(content);
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            contentHash = Array.from(new Uint8Array(hashBuffer)).map((b)=>b.toString(16).padStart(2, '0')).join('');
        } catch  {
            throw new ORPCError('POLICY_CREATION_FAILED', {
                message: 'Failed to generate policy content hash',
                status: 500,
                data: {
                    name
                }
            });
        }
        return {
            content,
            contentHash
        };
    }
    return {
        findConsentPolicyById: async (policyId)=>{
            const policy = await db.findFirst('consentPolicy', {
                where: (b)=>b('id', '=', policyId)
            });
            return policy;
        },
        findOrCreatePolicy: async (type)=>{
            const existingPolicy = await db.findFirst('consentPolicy', {
                where: (b)=>b.and(b('isActive', '=', true), b('type', '=', type)),
                orderBy: [
                    'effectiveDate',
                    'desc'
                ]
            });
            if (existingPolicy) {
                logger.debug('Found existing policy', {
                    type,
                    policyId: existingPolicy.id
                });
                return existingPolicy;
            }
            const { content, contentHash } = await generatePolicyPlaceholder(type, new Date());
            const policy = await db.create('consentPolicy', {
                id: await generate_id_generateUniqueId(db, 'consentPolicy', ctx),
                version: '1.0.0',
                type,
                name: type,
                effectiveDate: new Date(),
                content,
                contentHash,
                isActive: true,
                expirationDate: null
            });
            return policy;
        }
    };
}
function consentPurposeRegistry({ db, ctx }) {
    const { logger } = ctx;
    return {
        findOrCreateConsentPurposeByCode: async (code)=>{
            const existingPurpose = await db.findFirst('consentPurpose', {
                where: (b)=>b('code', '=', code)
            });
            if (existingPurpose) {
                logger.debug('Found existing consent purpose', {
                    code
                });
                return existingPurpose;
            }
            logger.debug('Creating consent purpose', {
                code
            });
            const createdPurpose = await db.create('consentPurpose', {
                id: await generate_id_generateUniqueId(db, 'consentPurpose', ctx),
                code,
                name: code,
                description: `Auto-created consentPurpose for ${code}`,
                isActive: true,
                isEssential: false,
                legalBasis: 'consent'
            });
            if (!createdPurpose) throw new ORPCError('PURPOSE_CREATION_FAILED', {
                message: 'Failed to create consent purpose',
                status: 500,
                data: {
                    purposeCode: code
                }
            });
            return createdPurpose;
        }
    };
}
function domainRegistry({ db, ctx }) {
    const { logger } = ctx;
    const findDomainByName = async (name)=>{
        const domain = await db.findFirst('domain', {
            where: (b)=>b('name', '=', name)
        });
        if (!domain) logger.debug('No domain found', {
            name
        });
        return domain;
    };
    return {
        findDomainByName,
        findOrCreateDomain: async (name)=>{
            const existingDomain = await findDomainByName(name);
            if (existingDomain) {
                logger.debug('Found existing domain', {
                    name
                });
                return existingDomain;
            }
            logger.debug('Creating new domain', {
                name
            });
            const domain = await db.create('domain', {
                id: await generate_id_generateUniqueId(db, 'domain', ctx),
                name,
                description: `Auto-created domain for ${name}`,
                isActive: true,
                isVerified: true,
                allowedOrigins: []
            });
            if (!domain) throw new ORPCError('DOMAIN_CREATION_FAILED', {
                message: 'Failed to create domain',
                status: 503,
                data: {
                    name
                }
            });
            return domain;
        }
    };
}
function subjectRegistry({ db, ctx }) {
    const { logger } = ctx;
    return {
        findOrCreateSubject: async ({ subjectId, externalSubjectId, identityProvider, ipAddress = 'unknown' })=>{
            if (subjectId && externalSubjectId) {
                const subject = await db.findFirst('subject', {
                    where: (b)=>b.and(b('id', '=', subjectId), b('externalId', '=', externalSubjectId))
                });
                if (!subject) {
                    logger?.error('Subject not found', {
                        providedSubjectId: subjectId,
                        providedExternalId: externalSubjectId
                    });
                    throw new ORPCError('SUBJECT_NOT_FOUND', {
                        message: 'The specified subject could not be found. Please verify the subject identifiers and try again.',
                        status: 404,
                        data: {
                            providedSubjectId: subjectId,
                            providedExternalId: externalSubjectId
                        }
                    });
                }
                return subject;
            }
            if (subjectId) {
                const subject = await db.findFirst('subject', {
                    where: (b)=>b('id', '=', subjectId)
                });
                if (!subject) throw new ORPCError('SUBJECT_NOT_FOUND', {
                    message: 'Subject not found by subjectId',
                    status: 404,
                    data: {
                        subjectId
                    }
                });
                return subject;
            }
            if (externalSubjectId) {
                logger.debug('Finding/Creating subject with external id');
                await db.upsert('subject', {
                    where: (b)=>b('externalId', '=', externalSubjectId),
                    create: {
                        id: await generate_id_generateUniqueId(db, 'subject', ctx),
                        externalId: externalSubjectId,
                        identityProvider: identityProvider ?? 'external',
                        lastIpAddress: ipAddress,
                        isIdentified: !!externalSubjectId
                    },
                    update: {
                        lastIpAddress: ipAddress
                    }
                });
                const subject = await db.findFirst('subject', {
                    where: (b)=>b('externalId', '=', externalSubjectId)
                });
                return subject;
            }
            logger?.debug('Creating new anonymous subject');
            const subject = await db.create('subject', {
                id: await generate_id_generateUniqueId(db, 'subject', ctx),
                externalId: null,
                identityProvider: 'anonymous',
                lastIpAddress: ipAddress,
                isIdentified: false
            });
            logger.debug('Created new anonymous subject', {
                subject
            });
            return subject;
        }
    };
}
const createRegistry = (ctx)=>({
        ...auditLogRegistry(ctx),
        ...subjectRegistry(ctx),
        ...consentRegistry(ctx),
        ...consentPurposeRegistry(ctx),
        ...policyRegistry(ctx),
        ...domainRegistry(ctx)
    });
function createTelemetryOptions(appName = 'c15t', telemetryConfig) {
    const config = {
        disabled: telemetryConfig?.disabled ?? false,
        tracer: telemetryConfig?.tracer,
        defaultAttributes: {
            ...telemetryConfig?.defaultAttributes || {},
            'service.name': String(appName),
            'service.version': "1.8.0"
        }
    };
    return config;
}
const getTracer = (options)=>{
    if (options?.advanced?.telemetry?.tracer) return options.advanced.telemetry.tracer;
    return trace.getTracer(options?.appName ?? 'c15t');
};
const createRequestSpan = (method, path, options)=>{
    if (options?.advanced?.telemetry?.disabled) return null;
    const tracer = getTracer(options);
    const span = tracer.startSpan(`${method} ${path}`, {
        attributes: {
            'http.method': method,
            'http.path': path,
            ...options?.advanced?.telemetry?.defaultAttributes || {}
        }
    });
    return span;
};
const withRequestSpan = async (method, path, operation, options)=>{
    const span = createRequestSpan(method, path, options);
    if (!span) return operation();
    try {
        const result = await operation();
        span.setStatus({
            code: SpanStatusCode.OK
        });
        return result;
    } catch (error) {
        handleSpanError(span, error);
        throw error;
    } finally{
        span.end();
    }
};
const handleSpanError = (span, error)=>{
    span.setStatus({
        code: SpanStatusCode.ERROR,
        message: error instanceof Error ? error.message : String(error)
    });
    if (error instanceof Error) {
        span.setAttribute('error.type', error.name);
        span.setAttribute('error.message', error.message);
        if (error.stack) span.setAttribute('error.stack', error.stack);
    }
};
let globalLogger;
function initLogger(options) {
    globalLogger = logger_createLogger(options);
    return globalLogger;
}
let telemetrySdk;
const initializeTelemetry = (appName, telemetryOptions, logger)=>{
    if (telemetrySdk) {
        logger.debug('Telemetry SDK already initialized, skipping');
        return true;
    }
    if (telemetryOptions?.disabled) {
        logger.info('Telemetry is disabled by configuration');
        return false;
    }
    try {
        const resource = resourceFromAttributes({
            'service.name': appName,
            'service.version': "1.8.0",
            ...telemetryOptions?.defaultAttributes || {}
        });
        logger.debug('Initializing telemetry with resource attributes', {
            attributes: resource.attributes
        });
        const traceExporter = telemetryOptions?.tracer ? void 0 : new ConsoleSpanExporter();
        telemetrySdk = new NodeSDK({
            resource,
            traceExporter
        });
        telemetrySdk.start();
        logger.info('Telemetry successfully initialized');
        return true;
    } catch (error) {
        logger.error('Telemetry initialization failed', {
            error: error instanceof Error ? error.message : String(error),
            stack: error instanceof Error ? error.stack : void 0
        });
        logger.warn('Continuing without telemetry');
        return false;
    }
};
const init = (options)=>{
    const appName = options.appName || 'c15t';
    const logger = initLogger({
        ...options.logger,
        appName: String(appName)
    });
    const telemetryOptions = createTelemetryOptions(String(appName), options.advanced?.telemetry);
    const telemetryInitialized = initializeTelemetry(String(appName), telemetryOptions, logger);
    if (telemetryOptions?.disabled) logger.info('Telemetry is disabled by configuration');
    else if (telemetryInitialized) logger.info('Telemetry initialized successfully');
    else logger.warn('Telemetry initialization failed, continuing without telemetry');
    const client = DB.client(options.adapter);
    const orm = client.orm('1.0.0');
    const context = {
        ...options,
        appName,
        logger,
        db: orm,
        registry: createRegistry({
            db: orm,
            ctx: {
                logger
            }
        })
    };
    return context;
};
const defineConfig = (config)=>config;
const c15tInstance = (options)=>{
    const context = init(options);
    const corsOptions = createCORSOptions(options.trustedOrigins);
    const rpcHandler = new OpenAPIHandler(router, {
        plugins: [
            new CORSPlugin(corsOptions)
        ]
    });
    const openApiConfig = createOpenAPIConfig(options);
    const getDocsUI = ()=>createDocsUI(options);
    const processTelemetry = (request, context)=>{
        const url = new URL(request.url);
        const path = url.pathname;
        const method = request.method;
        withRequestSpan(method, path, async ()=>{}, options);
        context.path = path;
        context.method = method;
        context.headers = request.headers;
        context.userAgent = request.headers.get('user-agent') || void 0;
        return context;
    };
    const handleOpenApiSpecRequest = async (url)=>{
        if (openApiConfig.enabled && url.pathname === openApiConfig.specPath) {
            const getOpenAPISpec = createOpenAPISpec(context, options);
            const spec = await getOpenAPISpec();
            return new Response(JSON.stringify(spec), {
                status: 200,
                headers: {
                    'Content-Type': 'application/json'
                }
            });
        }
        return null;
    };
    const handleDocsUiRequest = (url)=>{
        if (openApiConfig.enabled && url.pathname === openApiConfig.docsPath) {
            const html = getDocsUI();
            return new Response(html, {
                status: 200,
                headers: {
                    'Content-Type': 'text/html',
                    'Content-Security-Policy': "default-src 'self'; script-src 'self' https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net;"
                }
            });
        }
        return null;
    };
    const createORPCErrorResponse = (error)=>{
        const sanitizedMessage = error.message.replace(/[^\w\s.,;:!?()[\]{}'"+-]/g, '');
        return new Response(JSON.stringify({
            code: error.code,
            message: sanitizedMessage,
            data: error.data ?? {},
            status: error.status,
            defined: true
        }), {
            status: error.status,
            headers: {
                'Content-Type': 'application/json'
            }
        });
    };
    const createUnknownErrorResponse = (error)=>{
        const message = error instanceof Error ? error.message : String(error);
        let status = 500;
        if (error instanceof Error && 'status' in error) {
            const statusValue = error.status;
            if ('number' == typeof statusValue && statusValue >= 100 && statusValue < 600) status = statusValue;
        }
        return new Response(JSON.stringify({
            code: 'INTERNAL_SERVER_ERROR',
            message,
            status,
            defined: true,
            data: {}
        }), {
            status,
            headers: {
                'Content-Type': 'application/json'
            }
        });
    };
    const handleApiRequest = async (request, ctx)=>{
        const { logger } = ctx;
        const enrichedContext = {
            ...context,
            ipAddress: getIpAddress(request, options),
            userAgent: request.headers.get('user-agent') || void 0
        };
        processCors(request, enrichedContext, options.trustedOrigins);
        processTelemetry(request, enrichedContext);
        logger.debug?.('Handling prefix', {
            prefix: options.basePath || '/'
        });
        const { matched, response } = await rpcHandler.handle(request, {
            prefix: options.basePath || '/',
            context: enrichedContext
        });
        if (matched && response) {
            logger.debug('Handler matched', {
                request,
                matched,
                response
            });
            return response;
        }
        logger.debug('No handler matched', {
            request,
            matched,
            response
        });
        return new Response('Not Found', {
            status: 404
        });
    };
    const handler = async (request, ctxOverride)=>{
        try {
            const url = new URL(request.url);
            logger_createLogger(options.logger)?.debug?.('Incoming request', {
                method: request.method,
                pathname: url.pathname
            });
            const openApiResponse = await handleOpenApiSpecRequest(url);
            if (openApiResponse) return openApiResponse;
            const docsResponse = handleDocsUiRequest(url);
            if (docsResponse) return docsResponse;
            const ctx = defu(ctxOverride || {}, context);
            const basePath = options.basePath;
            logger_createLogger(options.logger)?.debug?.('[c15t] Using basePath', {
                basePath
            });
            logger_createLogger(options.logger)?.debug?.('[c15t] Routing request', {
                method: request.method,
                url: request.url,
                prefix: basePath
            });
            return await handleApiRequest(request, ctx);
        } catch (error) {
            const logger = options.logger ? logger_createLogger(options.logger) : console;
            logger.error('Request handling error:', error);
            if (error instanceof ORPCError) return createORPCErrorResponse(error);
            return createUnknownErrorResponse(error);
        }
    };
    const createNextHandlers = ()=>{
        const nextHandler = async (request)=>await handler(request);
        return {
            GET: nextHandler,
            POST: nextHandler,
            PUT: nextHandler,
            PATCH: nextHandler,
            DELETE: nextHandler,
            OPTIONS: nextHandler,
            HEAD: nextHandler
        };
    };
    return {
        options,
        $context: context,
        router: router,
        handler,
        ...createNextHandlers(),
        getOpenAPISpec: ()=>{
            const getOpenAPISpec = createOpenAPISpec(context, options);
            return getOpenAPISpec();
        },
        getDocsUI
    };
};
var __webpack_exports__version = "1.8.0";
export { c15tInstance, defineConfig, __webpack_exports__version as version };
