import { ORPCError, implement } from "@orpc/server";
import { oc } from "@orpc/contract";
import { ZodError, z } from "zod";
import base_x from "base-x";
import "neverthrow";
import { trace } from "@opentelemetry/api";
import { logger as logger_logger } from "@c15t/logger";
import { baseTranslations, deepMergeTranslations } from "@c15t/translations";
const identifyUserSchema = z.object({
    consentId: z.string(),
    externalId: z.string(),
    identityProvider: z.string().optional()
});
const identifyUserContract = oc.route({
    method: 'PATCH',
    path: '/consent/identify',
    description: "Links a subject's external ID to a consent record by consent ID. This is used to identify a user across multiple devices and sessions.",
    tags: [
        'consent',
        'cookie-banner'
    ]
}).errors({
    CONSENT_NOT_FOUND: {
        status: 404,
        data: z.object({
            consentId: z.string()
        }),
        error: 'Consent not found'
    },
    IDENTIFICATION_FAILED: {
        status: 500,
        data: z.object({
            consentId: z.string()
        }),
        error: 'Failed to identify user'
    }
}).input(identifyUserSchema).output(z.object({
    success: z.boolean()
}));
const COMMON_TIMEZONES = {
    UTC: 'UTC',
    GMT: 'GMT',
    EASTERN: 'America/New_York',
    CENTRAL: 'America/Chicago',
    MOUNTAIN: 'America/Denver',
    PACIFIC: 'America/Los_Angeles',
    LONDON: 'Europe/London',
    PARIS: 'Europe/Paris',
    BERLIN: 'Europe/Berlin',
    TOKYO: 'Asia/Tokyo',
    SHANGHAI: 'Asia/Shanghai',
    SINGAPORE: 'Asia/Singapore',
    SYDNEY: 'Australia/Sydney',
    SAO_PAULO: 'America/Sao_Paulo'
};
base_x('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');
const fieldConfigSchema = z.object({
    required: z.boolean().prefault(true),
    returned: z.boolean().prefault(true),
    input: z.boolean().prefault(true),
    defaultValue: z.any().optional(),
    transform: z.object({
        input: z.any().optional(),
        output: z.any().optional()
    }).optional(),
    validator: z.any().optional(),
    unique: z.boolean().optional(),
    indexed: z.boolean().optional(),
    sortable: z.boolean().prefault(true),
    fieldName: z.string().optional(),
    bigint: z.boolean().prefault(false)
});
const stringFieldSchema = fieldConfigSchema.extend({
    type: z.literal('string'),
    minLength: z.number().optional(),
    maxLength: z.number().optional(),
    pattern: z.string().optional()
});
const numberFieldSchema = fieldConfigSchema.extend({
    type: z.literal('number'),
    min: z.number().optional(),
    max: z.number().optional()
});
const booleanFieldSchema = fieldConfigSchema.extend({
    type: z.literal('boolean')
});
const dateFieldSchema = fieldConfigSchema.extend({
    type: z.literal('date'),
    minDate: z.date().optional(),
    maxDate: z.date().optional(),
    dateOnly: z.boolean().prefault(false),
    format: z.record(z.string(), z.unknown()).optional()
});
const timezoneFieldSchema = fieldConfigSchema.extend({
    type: z.literal('timezone'),
    validateTimezone: z.boolean().prefault(true),
    suggestedValues: z.array(z.string()).optional(),
    restrictToSuggestedValues: z.boolean().prefault(false)
});
const jsonFieldSchema = fieldConfigSchema.extend({
    type: z.literal('json'),
    validateJson: z.boolean().prefault(true)
});
const stringArrayFieldSchema = fieldConfigSchema.extend({
    type: z.literal('string[]')
});
const numberArrayFieldSchema = fieldConfigSchema.extend({
    type: z.literal('number[]')
});
z.discriminatedUnion('type', [
    stringFieldSchema,
    numberFieldSchema,
    booleanFieldSchema,
    dateFieldSchema,
    timezoneFieldSchema,
    jsonFieldSchema,
    stringArrayFieldSchema,
    numberArrayFieldSchema
]);
Object.freeze({
    NOT_FOUND: 'Resource not found',
    BAD_REQUEST: 'Bad request',
    CONFLICT: 'Conflict with current state',
    MISSING_REQUIRED_PARAMETER: 'Missing required parameter',
    UNAUTHORIZED: 'Unauthorized',
    FORBIDDEN: 'Forbidden',
    INTERNAL_SERVER_ERROR: 'Internal server error',
    INITIALIZATION_FAILED: 'Initialization failed',
    DATABASE_CONNECTION_ERROR: 'Database connection error',
    DATABASE_QUERY_ERROR: 'Database query error',
    INVALID_CONFIGURATION: 'Invalid configuration',
    REQUEST_HANDLER_ERROR: 'Request handler error',
    INVALID_REQUEST: 'Invalid request',
    UNKNOWN_ERROR: 'Unknown error',
    NETWORK_ERROR: 'Network error',
    PLUGIN_INITIALIZATION_FAILED: 'Plugin initialization failed',
    API_RETRIEVAL_ERROR: 'API retrieval error',
    VALIDATION_ERROR: 'Validation error',
    UNEXPECTED: 'Unexpected error'
});
Object.freeze({
    VALIDATION: 'validation',
    AUTHORIZATION: 'authorization',
    STORAGE: 'storage',
    NETWORK: 'network',
    PLUGIN: 'plugin',
    CONFIGURATION: 'configuration',
    UNEXPECTED: 'unexpected'
});
trace.getTracer('@doubletie/results');
const schema_auditLogSchema = z.object({
    id: z.string(),
    entityType: z.string(),
    entityId: z.string(),
    actionType: z.string(),
    subjectId: z.string().optional(),
    ipAddress: z.string().optional(),
    userAgent: z.string().optional(),
    changes: z.record(z.string(), z.unknown()).optional(),
    metadata: z.record(z.string(), z.unknown()).optional(),
    createdAt: z.date().prefault(()=>new Date())
});
function getAuditLogTable(options, auditLogFields) {
    const auditLogConfig = options.tables?.auditLog;
    const subjectConfig = options.tables?.subject;
    return {
        entityName: auditLogConfig?.entityName || 'auditLog',
        entityPrefix: auditLogConfig?.entityPrefix || 'log',
        schema: schema_auditLogSchema,
        fields: {
            entityType: {
                type: 'string',
                required: true,
                fieldName: auditLogConfig?.fields?.entityType || 'entityType'
            },
            entityId: {
                type: 'string',
                required: true,
                fieldName: auditLogConfig?.fields?.entityId || 'entityId'
            },
            actionType: {
                type: 'string',
                required: true,
                fieldName: auditLogConfig?.fields?.actionType || 'actionType'
            },
            subjectId: {
                type: 'string',
                required: false,
                fieldName: auditLogConfig?.fields?.subjectId || 'subjectId',
                references: {
                    model: subjectConfig?.entityName || 'subject',
                    field: 'id'
                }
            },
            ipAddress: {
                type: 'string',
                required: false,
                fieldName: auditLogConfig?.fields?.ipAddress || 'ipAddress'
            },
            userAgent: {
                type: 'string',
                required: false,
                fieldName: auditLogConfig?.fields?.userAgent || 'userAgent'
            },
            changes: {
                type: 'json',
                required: false,
                fieldName: auditLogConfig?.fields?.changes || 'changes'
            },
            metadata: {
                type: 'json',
                required: false,
                fieldName: auditLogConfig?.fields?.metadata || 'metadata'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: auditLogConfig?.fields?.createdAt || 'createdAt'
            },
            eventTimezone: {
                type: 'timezone',
                required: true,
                defaultValue: COMMON_TIMEZONES.UTC,
                fieldName: auditLogConfig?.fields?.eventTimezone || 'eventTimezone'
            },
            ...auditLogFields || {},
            ...auditLogConfig?.additionalFields || {}
        },
        indexes: [
            {
                name: 'entity_index',
                fields: [
                    'entityType',
                    'entityId'
                ]
            },
            {
                name: 'action_type_index',
                fields: [
                    'actionType'
                ]
            },
            {
                name: 'subject_id_index',
                fields: [
                    'subjectId'
                ]
            },
            {
                name: 'created_at_index',
                fields: [
                    'createdAt'
                ]
            }
        ],
        order: 5
    };
}
const schema_consentSchema = z.object({
    id: z.string(),
    subjectId: z.string(),
    domainId: z.string(),
    purposeIds: z.array(z.string()),
    metadata: z.record(z.string(), z.unknown()).nullable().optional(),
    policyId: z.string().optional(),
    ipAddress: z.string().nullable().optional(),
    userAgent: z.string().nullable().optional(),
    status: z["enum"]([
        'active',
        'withdrawn',
        'expired'
    ]).prefault('active'),
    withdrawalReason: z.string().nullable().optional(),
    givenAt: z.date().prefault(()=>new Date()),
    validUntil: z.date().nullable().optional(),
    isActive: z.boolean().prefault(true)
});
function getConsentTable(options, consentFields) {
    const consentConfig = options.tables?.consent;
    const subjectConfig = options.tables?.subject;
    const domainConfig = options.tables?.domain;
    const policyConfig = options.tables?.consentPolicy;
    return {
        entityName: consentConfig?.entityName || 'consent',
        entityPrefix: consentConfig?.entityPrefix || 'cns',
        schema: schema_consentSchema,
        fields: {
            subjectId: {
                type: 'string',
                required: true,
                fieldName: consentConfig?.fields?.subjectId || 'subjectId',
                references: {
                    model: subjectConfig?.entityName || 'subject',
                    field: 'id'
                }
            },
            domainId: {
                type: 'string',
                required: true,
                fieldName: consentConfig?.fields?.domainId || 'domainId',
                references: {
                    model: domainConfig?.entityName || 'domain',
                    field: 'id'
                }
            },
            purposeIds: {
                type: 'json',
                required: false,
                fieldName: consentConfig?.fields?.purposeIds || 'purposeIds'
            },
            metadata: {
                type: 'json',
                required: false,
                fieldName: consentConfig?.fields?.metadata || 'metadata'
            },
            policyId: {
                type: 'string',
                required: false,
                fieldName: consentConfig?.fields?.policyId || 'policyId',
                references: {
                    model: policyConfig?.entityName || 'consentPolicy',
                    field: 'id'
                }
            },
            ipAddress: {
                type: 'string',
                required: false,
                fieldName: consentConfig?.fields?.ipAddress || 'ipAddress'
            },
            userAgent: {
                type: 'string',
                required: false,
                fieldName: consentConfig?.fields?.userAgent || 'userAgent'
            },
            status: {
                type: 'string',
                defaultValue: ()=>'active',
                required: true,
                fieldName: consentConfig?.fields?.status || 'status'
            },
            withdrawalReason: {
                type: 'string',
                required: false,
                fieldName: consentConfig?.fields?.withdrawalReason || 'withdrawalReason'
            },
            givenAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: consentConfig?.fields?.givenAt || 'givenAt'
            },
            validUntil: {
                type: 'date',
                required: false,
                fieldName: consentConfig?.fields?.validUntil || 'validUntil',
                transform: {
                    input: (val, data)=>{
                        if (val) return val;
                        const expiresIn = consentConfig?.expiresIn || 31536000;
                        const givenAt = data.givenAt instanceof Date ? data.givenAt : new Date();
                        if (expiresIn > 0) {
                            const validUntil = new Date(givenAt);
                            validUntil.setSeconds(validUntil.getSeconds() + expiresIn);
                            return validUntil;
                        }
                    }
                }
            },
            isActive: {
                type: 'boolean',
                defaultValue: true,
                required: true,
                fieldName: consentConfig?.fields?.isActive || 'isActive'
            },
            ...consentFields || {},
            ...consentConfig?.additionalFields || {}
        },
        order: 3
    };
}
const PolicyTypeSchema = z["enum"]([
    'cookie_banner',
    'privacy_policy',
    'dpa',
    'terms_and_conditions',
    'marketing_communications',
    'age_verification',
    'other'
]);
const schema_consentPolicySchema = z.object({
    id: z.string(),
    version: z.string(),
    type: PolicyTypeSchema,
    name: z.string(),
    effectiveDate: z.date(),
    expirationDate: z.date().nullable().optional(),
    content: z.string(),
    contentHash: z.string(),
    isActive: z.boolean().prefault(true),
    createdAt: z.date().prefault(()=>new Date()),
    updatedAt: z.date().prefault(()=>new Date())
});
function getConsentPolicyTable(options, policyFields) {
    const consentPolicyConfig = options.tables?.consentPolicy;
    return {
        entityName: consentPolicyConfig?.entityName || 'consentPolicy',
        entityPrefix: consentPolicyConfig?.entityPrefix || 'pol',
        schema: schema_consentPolicySchema,
        fields: {
            version: {
                type: 'string',
                required: true,
                fieldName: consentPolicyConfig?.fields?.version || 'version'
            },
            type: {
                type: 'string',
                required: true,
                fieldName: consentPolicyConfig?.fields?.type || 'type'
            },
            name: {
                type: 'string',
                required: true,
                fieldName: consentPolicyConfig?.fields?.name || 'name'
            },
            effectiveDate: {
                type: 'date',
                required: true,
                fieldName: consentPolicyConfig?.fields?.effectiveDate || 'effectiveDate'
            },
            expirationDate: {
                type: 'date',
                required: false,
                fieldName: consentPolicyConfig?.fields?.expirationDate || 'expirationDate'
            },
            content: {
                type: 'string',
                required: true,
                fieldName: consentPolicyConfig?.fields?.content || 'content'
            },
            contentHash: {
                type: 'string',
                required: true,
                fieldName: consentPolicyConfig?.fields?.contentHash || 'contentHash'
            },
            isActive: {
                type: 'boolean',
                defaultValue: true,
                required: true,
                fieldName: consentPolicyConfig?.fields?.isActive || 'isActive'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: consentPolicyConfig?.fields?.createdAt || 'createdAt'
            },
            ...policyFields || {},
            ...consentPolicyConfig?.additionalFields || {}
        },
        order: 2
    };
}
const schema_purposeSchema = z.object({
    id: z.string(),
    code: z.string(),
    name: z.string(),
    description: z.string(),
    isEssential: z.boolean().prefault(false),
    dataCategory: z.string().nullish(),
    legalBasis: z.string().nullish(),
    isActive: z.boolean().prefault(true),
    createdAt: z.date().prefault(()=>new Date()),
    updatedAt: z.date().prefault(()=>new Date())
});
function getPurposeTable(options, purposeFields) {
    const purposeConfig = options.tables?.consentPurpose;
    return {
        entityName: purposeConfig?.entityName || 'consentPurpose',
        entityPrefix: purposeConfig?.entityPrefix || 'pur',
        schema: schema_purposeSchema,
        fields: {
            code: {
                type: 'string',
                required: true,
                fieldName: purposeConfig?.fields?.code || 'code'
            },
            name: {
                type: 'string',
                required: true,
                fieldName: purposeConfig?.fields?.name || 'name'
            },
            description: {
                type: 'string',
                required: true,
                fieldName: purposeConfig?.fields?.description || "description"
            },
            isEssential: {
                type: 'boolean',
                defaultValue: ()=>false,
                required: true,
                fieldName: purposeConfig?.fields?.isEssential || 'isEssential'
            },
            dataCategory: {
                type: 'string',
                required: false,
                fieldName: purposeConfig?.fields?.dataCategory || 'dataCategory'
            },
            legalBasis: {
                type: 'string',
                required: false,
                fieldName: purposeConfig?.fields?.legalBasis || 'legalBasis'
            },
            isActive: {
                type: 'boolean',
                defaultValue: true,
                required: true,
                fieldName: purposeConfig?.fields?.isActive || 'isActive'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: purposeConfig?.fields?.createdAt || 'createdAt'
            },
            updatedAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: purposeConfig?.fields?.updatedAt || 'updatedAt'
            },
            ...purposeFields || {},
            ...purposeConfig?.additionalFields || {}
        },
        order: 1
    };
}
const schema_consentRecordSchema = z.object({
    id: z.string(),
    subjectId: z.string(),
    consentId: z.string().optional(),
    actionType: z.string(),
    details: z.record(z.string(), z.unknown()).optional(),
    createdAt: z.date().prefault(()=>new Date()),
    updatedAt: z.date().prefault(()=>new Date())
});
function getConsentRecordTable(options, recordFields) {
    const recordConfig = options.tables?.record;
    const subjectConfig = options.tables?.subject;
    const consentConfig = options.tables?.consent;
    return {
        entityName: recordConfig?.entityName || 'consentRecord',
        entityPrefix: recordConfig?.entityPrefix || 'rec',
        schema: schema_consentRecordSchema,
        fields: {
            subjectId: {
                type: 'string',
                required: true,
                fieldName: recordConfig?.fields?.subjectId || 'subjectId',
                references: {
                    model: subjectConfig?.entityName || 'subject',
                    field: 'id'
                }
            },
            consentId: {
                type: 'string',
                required: false,
                fieldName: recordConfig?.fields?.consentId || 'consentId',
                references: {
                    model: consentConfig?.entityName || 'consent',
                    field: 'id'
                }
            },
            actionType: {
                type: 'string',
                required: true,
                fieldName: recordConfig?.fields?.actionType || 'actionType'
            },
            details: {
                type: 'json',
                required: false,
                fieldName: recordConfig?.fields?.details || 'details'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: recordConfig?.fields?.createdAt || 'createdAt'
            },
            ...recordFields || {},
            ...recordConfig?.additionalFields || {}
        },
        order: 4
    };
}
const schema_domainSchema = z.object({
    id: z.string(),
    name: z.string().min(1),
    description: z.string().optional(),
    allowedOrigins: z.array(z.string()).optional().prefault([]),
    isVerified: z.boolean().prefault(true),
    isActive: z.boolean().prefault(true),
    createdAt: z.date().prefault(()=>new Date()),
    updatedAt: z.date().prefault(()=>new Date())
});
function getDomainTable(options, domainFields) {
    const domainConfig = options.tables?.domain;
    return {
        entityName: domainConfig?.entityName || 'domain',
        entityPrefix: domainConfig?.entityPrefix || 'dom',
        schema: schema_domainSchema,
        fields: {
            name: {
                type: 'string',
                required: true,
                unique: true,
                fieldName: domainConfig?.fields?.name || 'name'
            },
            description: {
                type: 'string',
                required: false,
                fieldName: domainConfig?.fields?.description || "description"
            },
            allowedOrigins: {
                type: 'json',
                defaultValue: ()=>[],
                required: false,
                fieldName: domainConfig?.fields?.allowedOrigins || 'allowedOrigins'
            },
            isVerified: {
                type: 'boolean',
                defaultValue: true,
                required: true,
                fieldName: domainConfig?.fields?.isVerified || 'isVerified'
            },
            isActive: {
                type: 'boolean',
                defaultValue: true,
                required: true,
                fieldName: domainConfig?.fields?.isActive || 'isActive'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: domainConfig?.fields?.createdAt || 'createdAt'
            },
            updatedAt: {
                type: 'date',
                required: false,
                fieldName: domainConfig?.fields?.updatedAt || 'updatedAt'
            },
            ...domainFields || {},
            ...domainConfig?.additionalFields || {}
        },
        order: 1
    };
}
const schema_subjectSchema = z.object({
    id: z.string(),
    isIdentified: z.boolean().prefault(false),
    externalId: z.string().nullable().optional(),
    identityProvider: z.string().optional(),
    lastIpAddress: z.string().optional(),
    createdAt: z.date().prefault(()=>new Date()),
    updatedAt: z.date().prefault(()=>new Date())
});
function getSubjectTable(options, subjectFields) {
    const subjectConfig = options.tables?.subject;
    return {
        entityName: subjectConfig?.entityName || 'subject',
        entityPrefix: subjectConfig?.entityPrefix || 'sub',
        schema: schema_subjectSchema,
        fields: {
            isIdentified: {
                type: 'boolean',
                defaultValue: ()=>false,
                required: true,
                fieldName: subjectConfig?.fields?.isIdentified || 'isIdentified'
            },
            externalId: {
                type: 'string',
                required: false,
                fieldName: subjectConfig?.fields?.externalId || 'externalId'
            },
            identityProvider: {
                type: 'string',
                required: false,
                fieldName: subjectConfig?.fields?.identityProvider || 'identityProvider'
            },
            lastIpAddress: {
                type: 'string',
                required: false,
                fieldName: subjectConfig?.fields?.lastIpAddress || 'lastIpAddress'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: subjectConfig?.fields?.createdAt || 'createdAt'
            },
            updatedAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: subjectConfig?.fields?.updatedAt || 'updatedAt'
            },
            subjectTimezone: {
                type: 'timezone',
                required: false,
                defaultValue: COMMON_TIMEZONES.UTC,
                fieldName: subjectConfig?.fields?.subjectTimezone || 'subjectTimezone'
            },
            ...subjectFields || {},
            ...subjectConfig?.additionalFields || {}
        },
        order: 1
    };
}
const getConsentTables = (options)=>{
    const pluginSchema = options.plugins?.reduce((acc, plugin)=>{
        const schema = plugin.schema;
        if (!schema) return acc;
        for (const [key, value] of Object.entries(schema))acc[key] = {
            fields: {
                ...acc[key]?.fields,
                ...value.fields
            },
            entityName: key
        };
        return acc;
    }, {});
    const { subject, consentPurpose, consentPolicy, domain, geoLocation, consent, consentPurposeJunction, record, consentGeoLocation, consentWithdrawal, auditLog, ...pluginTables } = pluginSchema || {};
    return {
        subject: getSubjectTable(options, subject?.fields),
        consentPurpose: getPurposeTable(options, consentPurpose?.fields),
        consentPolicy: getConsentPolicyTable(options, consentPolicy?.fields),
        domain: getDomainTable(options, domain?.fields),
        consent: getConsentTable(options, consent?.fields),
        consentRecord: getConsentRecordTable(options, record?.fields),
        auditLog: getAuditLogTable(options, auditLog?.fields),
        ...pluginTables
    };
};
function definition_validateEntityOutput(tableName, data, options) {
    const tables = getConsentTables(options);
    const table = tables[tableName];
    if (!table) throw new Error(`Table ${tableName} not found`);
    const processedData = {
        ...data
    };
    for (const [field, def] of Object.entries(table.fields))if ('date' === def.type && 'string' == typeof processedData[field]) processedData[field] = new Date(processedData[field]);
    try {
        return table.schema.parse(processedData);
    } catch (error) {
        if (error instanceof ZodError) logger_logger.error(`[validateEntityOutput] Validation failed for table ${String(tableName)}`, {
            table,
            issues: error.issues
        });
        throw error;
    }
}
const baseConsentSchema = z.object({
    subjectId: z.string().optional(),
    externalSubjectId: z.string().optional(),
    identityProvider: z.string().optional(),
    domain: z.string(),
    type: PolicyTypeSchema,
    metadata: z.record(z.string(), z.unknown()).optional()
});
const cookieBannerSchema = baseConsentSchema.extend({
    type: z.literal('cookie_banner'),
    preferences: z.record(z.string(), z.boolean())
});
const policyBasedSchema = baseConsentSchema.extend({
    type: z["enum"]([
        'privacy_policy',
        'dpa',
        'terms_and_conditions'
    ]),
    policyId: z.string().optional(),
    preferences: z.record(z.string(), z.boolean()).optional()
});
const otherConsentSchema = baseConsentSchema.extend({
    type: z["enum"]([
        'marketing_communications',
        'age_verification',
        'other'
    ]),
    preferences: z.record(z.string(), z.boolean()).optional()
});
const postConsentContract = oc.route({
    method: 'POST',
    path: '/consent/set',
    description: `Records a user's consent preferences and creates necessary consent records.
This endpoint handles various types of consent submissions:

1. Cookie Banner Consent:
   - Records granular cookie preferences
   - Supports multiple consent purposes
   - Creates audit trail for compliance

2. Policy-Based Consent:
   - Privacy Policy acceptance
   - Data Processing Agreement (DPA) consent
   - Terms and Conditions acceptance
   - Links consent to specific policy versions

3. Other Consent Types:
   - Marketing communications preferences
   - Age verification consent
   - Custom consent types

The endpoint performs the following operations:
- Creates or retrieves subject records
- Validates domain and policy information
- Creates consent records with audit trails
- Records consent purposes and preferences
- Generates audit logs for compliance

Use this endpoint to record user consent and maintain a compliant consent management system.`,
    tags: [
        'consent',
        'cookie-banner'
    ]
}).errors({
    INPUT_VALIDATION_FAILED: {
        status: 422,
        data: z.object({
            formErrors: z.array(z.string()),
            fieldErrors: z.record(z.string(), z.array(z.string()))
        }),
        error: 'Invalid input parameters'
    },
    SUBJECT_CREATION_FAILED: {
        status: 400,
        data: z.object({
            subjectId: z.string().optional(),
            externalSubjectId: z.string().optional()
        }),
        error: 'Failed to create or find subject'
    },
    DOMAIN_CREATION_FAILED: {
        status: 500,
        data: z.object({
            domain: z.string()
        }),
        error: 'Failed to create or find domain'
    },
    POLICY_NOT_FOUND: {
        status: 404,
        data: z.object({
            policyId: z.string(),
            type: z.string()
        }),
        error: 'Policy not found'
    },
    POLICY_INACTIVE: {
        status: 409,
        data: z.object({
            policyId: z.string(),
            type: z.string()
        }),
        error: 'Policy is not active'
    },
    POLICY_CREATION_FAILED: {
        status: 500,
        data: z.object({
            type: z.string()
        }),
        error: 'Failed to create or find policy'
    },
    PURPOSE_CREATION_FAILED: {
        status: 500,
        data: z.object({
            purposeCode: z.string()
        }),
        error: 'Failed to create consent purpose'
    },
    CONSENT_CREATION_FAILED: {
        status: 500,
        data: z.object({
            subjectId: z.string(),
            domain: z.string()
        }),
        error: 'Failed to create consent record'
    }
}).input(z.discriminatedUnion('type', [
    cookieBannerSchema,
    policyBasedSchema,
    otherConsentSchema
])).output(z.object({
    id: z.string(),
    subjectId: z.string().optional(),
    externalSubjectId: z.string().optional(),
    domainId: z.string(),
    domain: z.string(),
    type: PolicyTypeSchema,
    status: z.string(),
    recordId: z.string(),
    metadata: z.record(z.string(), z.unknown()).optional(),
    givenAt: z.date()
}));
const types_branding = [
    'c15t',
    'consent',
    'none'
];
const JurisdictionMessages = {
    GDPR: 'GDPR or equivalent regulations require a cookie banner.',
    CH: 'Switzerland requires similar data protection measures.',
    BR: "Brazil's LGPD requires consent for cookies.",
    PIPEDA: 'PIPEDA requires consent for data collection.',
    AU: "Australia's Privacy Act mandates transparency about data collection.",
    APPI: "Japan's APPI requires consent for data collection.",
    PIPA: "South Korea's PIPA requires consent for data collection.",
    NONE: 'No specific requirements'
};
const JurisdictionCodeSchema = z["enum"]([
    'GDPR',
    'CH',
    'BR',
    'PIPEDA',
    'AU',
    'APPI',
    'PIPA',
    'NONE'
]);
const JurisdictionInfoSchema = z.object({
    code: JurisdictionCodeSchema,
    message: z.string()
});
const TitleDescriptionSchema = z.object({
    title: z.string(),
    description: z.string()
});
const CompleteTranslationsSchema = z.object({
    common: z.object({
        acceptAll: z.string(),
        rejectAll: z.string(),
        customize: z.string(),
        save: z.string()
    }),
    cookieBanner: TitleDescriptionSchema,
    consentManagerDialog: TitleDescriptionSchema,
    consentTypes: z.object({
        experience: TitleDescriptionSchema,
        functionality: TitleDescriptionSchema,
        marketing: TitleDescriptionSchema,
        measurement: TitleDescriptionSchema,
        necessary: TitleDescriptionSchema
    }),
    frame: z.object({
        title: z.string(),
        actionButton: z.string()
    }),
    legalLinks: z.object({
        privacyPolicy: z.string(),
        termsOfService: z.string(),
        cookiePolicy: z.string()
    })
});
const PartialTranslationsSchema = z.object({
    common: z.object({
        acceptAll: z.string().optional(),
        rejectAll: z.string().optional(),
        customize: z.string().optional(),
        save: z.string().optional()
    }).partial(),
    cookieBanner: TitleDescriptionSchema.partial(),
    consentManagerDialog: TitleDescriptionSchema.partial(),
    consentTypes: z.object({
        experience: TitleDescriptionSchema.partial(),
        functionality: TitleDescriptionSchema.partial(),
        marketing: TitleDescriptionSchema.partial(),
        measurement: TitleDescriptionSchema.partial(),
        necessary: TitleDescriptionSchema.partial()
    }).partial(),
    frame: z.object({
        title: z.string().optional(),
        actionButton: z.string().optional()
    }).partial().optional(),
    legalLinks: z.object({
        privacyPolicy: z.string().optional(),
        termsOfService: z.string().optional(),
        cookiePolicy: z.string().optional()
    }).partial().optional()
});
const TranslationsSchema = z.union([
    CompleteTranslationsSchema,
    PartialTranslationsSchema
]);
const showConsentBannerContract = oc.route({
    method: 'GET',
    path: '/show-consent-banner',
    description: `Determines if a user should see a consent banner based on their location and applicable privacy regulations.
This endpoint performs the following checks:

1. Detects the user's location using various header information:
   - Cloudflare country headers
   - Vercel IP country headers
   - AWS CloudFront headers
   - Custom country code headers

2. Determines the applicable jurisdiction based on the location:
   - GDPR (EU/EEA/UK)
   - Swiss Data Protection Act
   - LGPD (Brazil)
   - PIPEDA (Canada)
   - Australian Privacy Principles
   - APPI (Japan)
   - PIPA (South Korea)

3. Returns detailed information about:
   - Whether to show the consent banner
   - The applicable jurisdiction and its requirements
   - The user's detected location (country and region)

Use this endpoint to implement geo-targeted consent banners and ensure compliance with regional privacy regulations.`,
    tags: [
        'cookie-banner'
    ]
}).output(z.object({
    showConsentBanner: z.boolean(),
    jurisdiction: JurisdictionInfoSchema,
    location: z.object({
        countryCode: z.string().nullable(),
        regionCode: z.string().nullable()
    }),
    translations: z.object({
        language: z.string(),
        translations: TranslationsSchema
    }),
    branding: z["enum"](types_branding)
}));
const verifyConsentInputSchema = z.strictObject({
    subjectId: z.string().optional(),
    externalSubjectId: z.string().optional(),
    domain: z.string(),
    type: PolicyTypeSchema,
    policyId: z.string().optional(),
    preferences: z.array(z.string()).optional()
});
const verify_contract_consentSchema = z.looseObject({
    id: z.string(),
    purposeIds: z.array(z.string())
});
const verifyConsentContract = oc.route({
    method: 'POST',
    path: '/consent/verify',
    description: `Verifies if a user has given valid consent for a specific policy and domain.
This endpoint performs comprehensive consent verification by:

1. Validating the subject's identity (using subjectId or externalSubjectId)
2. Verifying the domain's existence and validity
3. Checking if the specified policy exists and is active
4. Validating that all required purposes have been consented to
5. Ensuring the consent record is current and valid

The endpoint supports different types of consent verification:
- Cookie banner consent verification
- Privacy policy consent verification
- Terms and conditions verification
- Marketing communications consent verification
- Age verification
- Custom consent types

Use this endpoint to ensure compliance with privacy regulations and to verify user consent before processing personal data.`,
    tags: [
        'consent'
    ]
}).errors({
    INPUT_VALIDATION_FAILED: {
        status: 422,
        data: z.object({
            formErrors: z.array(z.string()),
            fieldErrors: z.record(z.string(), z.array(z.string()).optional())
        }),
        error: 'Invalid input parameters'
    },
    SUBJECT_NOT_FOUND: {
        status: 404,
        data: z.object({
            subjectId: z.string().optional(),
            externalSubjectId: z.string().optional()
        }),
        error: 'Subject not found'
    },
    DOMAIN_NOT_FOUND: {
        status: 404,
        data: z.object({
            domain: z.string()
        }),
        error: 'Domain not found'
    },
    POLICY_NOT_FOUND: {
        status: 404,
        data: z.object({
            policyId: z.string(),
            type: z.string()
        }),
        error: 'Policy not found or invalid'
    },
    PURPOSES_NOT_FOUND: {
        status: 404,
        data: z.object({
            preferences: z.array(z.string()),
            foundPurposes: z.array(z.string())
        }),
        error: 'Could not find all specified purposes'
    },
    COOKIE_BANNER_PREFERENCES_REQUIRED: {
        status: 400,
        data: z.object({
            type: z.literal('cookie_banner')
        }),
        error: 'Preferences are required for cookie banner consent'
    },
    NO_CONSENT_FOUND: {
        status: 404,
        data: z.object({
            policyId: z.string(),
            subjectId: z.string(),
            domainId: z.string()
        }),
        error: 'No consent found for the given policy'
    }
}).input(verifyConsentInputSchema).output(z.object({
    isValid: z.boolean(),
    reasons: z.array(z.string()).optional(),
    consent: verify_contract_consentSchema.optional()
}));
const consentContracts = {
    post: postConsentContract,
    showBanner: showConsentBannerContract,
    verify: verifyConsentContract,
    identify: identifyUserContract
};
const statusContract = oc.route({
    method: 'GET',
    path: '/status',
    description: `Returns the current operational status and health metrics of the service.
This endpoint provides real-time information about:
- Overall service status (ok/error)
- Current API version
- Server timestamp
- Storage system status and availability
- Client information (IP, User Agent, Region)

Use this endpoint for health checks, monitoring, and service status verification.`,
    tags: [
        'meta'
    ]
}).output(z.object({
    status: z["enum"]([
        'ok',
        'error'
    ]),
    version: z.string(),
    timestamp: z.date(),
    storage: z.object({
        type: z.string(),
        available: z.boolean()
    }),
    client: z.object({
        ip: z.string().nullable(),
        userAgent: z.string().nullable(),
        region: z.object({
            countryCode: z.string().nullable(),
            regionCode: z.string().nullable()
        })
    })
}));
const metaContracts = {
    status: statusContract
};
const contracts_config = {
    consent: consentContracts,
    meta: metaContracts
};
const os = implement(contracts_config);
const identifyUser = os.consent.identify.handler(async ({ input, context })=>{
    const typedContext = context;
    const { adapter, logger } = typedContext;
    logger.info('Handling identify-user request');
    const rawConsent = await adapter.findOne({
        model: 'consent',
        where: [
            {
                field: 'id',
                value: input.consentId
            }
        ]
    });
    const consent = rawConsent ? definition_validateEntityOutput('consent', rawConsent, typedContext.options) : null;
    if (!consent) throw new ORPCError('CONSENT_NOT_FOUND', {
        data: {
            consentId: input.consentId
        }
    });
    await typedContext.adapter.transaction({
        callback: async (tx)=>{
            const existingSubject = await tx.findOne({
                model: 'subject',
                where: [
                    {
                        field: 'externalId',
                        value: input.externalId
                    },
                    {
                        field: 'id',
                        value: consent.subjectId,
                        connector: 'AND',
                        operator: 'ne'
                    }
                ]
            });
            if (existingSubject && 'id' in existingSubject) {
                const currentSubjectId = consent.subjectId;
                const oldSubjectId = existingSubject.id;
                logger.info('Merging subjects', {
                    currentSubjectId,
                    oldSubjectId,
                    externalId: input.externalId
                });
                await tx.updateMany({
                    model: 'consent',
                    where: [
                        {
                            field: 'subjectId',
                            value: currentSubjectId
                        }
                    ],
                    update: {
                        subjectId: oldSubjectId
                    }
                });
                await tx.updateMany({
                    model: 'consentRecord',
                    where: [
                        {
                            field: 'subjectId',
                            value: currentSubjectId
                        }
                    ],
                    update: {
                        subjectId: oldSubjectId
                    }
                });
                await tx.updateMany({
                    model: 'auditLog',
                    where: [
                        {
                            field: 'subjectId',
                            value: currentSubjectId
                        }
                    ],
                    update: {
                        subjectId: oldSubjectId
                    }
                });
                await tx.deleteMany({
                    model: 'subject',
                    where: [
                        {
                            field: 'id',
                            value: currentSubjectId
                        }
                    ]
                });
                await tx.create({
                    model: 'auditLog',
                    data: {
                        subjectId: oldSubjectId,
                        entityType: 'consent',
                        entityId: consent.id,
                        actionType: 'identify_user',
                        ipAddress: typedContext.ipAddress || null,
                        userAgent: typedContext.userAgent || null,
                        eventTimezone: 'UTC',
                        metadata: {
                            externalId: input.externalId,
                            mergedFrom: currentSubjectId
                        }
                    }
                });
            } else {
                await tx.update({
                    model: 'subject',
                    where: [
                        {
                            field: 'id',
                            value: consent.subjectId
                        }
                    ],
                    update: {
                        externalId: input.externalId,
                        identityProvider: input.identityProvider || 'external',
                        isIdentified: true,
                        updatedAt: new Date()
                    }
                });
                await tx.create({
                    model: 'auditLog',
                    data: {
                        subjectId: consent.subjectId,
                        entityType: 'consent',
                        entityId: consent.id,
                        actionType: 'identify_user',
                        ipAddress: typedContext.ipAddress || null,
                        userAgent: typedContext.userAgent || null,
                        eventTimezone: 'UTC',
                        metadata: {
                            externalId: input.externalId,
                            identityProvider: input.identityProvider || 'external'
                        }
                    }
                });
            }
        }
    });
    return {
        success: true
    };
});
const postConsent = os.consent.post.handler(async ({ input, context })=>{
    const typedContext = context;
    const logger = typedContext.logger;
    logger.info('Handling post-consent request');
    const { type, subjectId, externalSubjectId, identityProvider, domain, metadata, preferences } = input;
    logger.debug('Request parameters', {
        type,
        subjectId,
        externalSubjectId,
        identityProvider,
        domain
    });
    try {
        const subject = await typedContext.registry.findOrCreateSubject({
            subjectId,
            externalSubjectId,
            identityProvider,
            ipAddress: typedContext.ipAddress || 'unknown'
        });
        if (!subject) throw new ORPCError('SUBJECT_CREATION_FAILED', {
            data: {
                subjectId,
                externalSubjectId
            }
        });
        logger.debug('Subject found/created', {
            subjectId: subject.id
        });
        const domainRecord = await typedContext.registry.findOrCreateDomain(domain);
        if (!domainRecord) throw new ORPCError('DOMAIN_CREATION_FAILED', {
            data: {
                domain
            }
        });
        const now = new Date();
        let policyId;
        let purposeIds = [];
        if ('policyId' in input && input.policyId) {
            policyId = input.policyId;
            const policy = await typedContext.registry.findConsentPolicyById(policyId);
            if (!policy) throw new ORPCError('POLICY_NOT_FOUND', {
                data: {
                    policyId,
                    type
                }
            });
            if (!policy.isActive) throw new ORPCError('POLICY_INACTIVE', {
                data: {
                    policyId,
                    type
                }
            });
        } else {
            const policy = await typedContext.registry.findOrCreatePolicy(type);
            if (!policy) throw new ORPCError('POLICY_CREATION_FAILED', {
                data: {
                    type
                }
            });
            policyId = policy.id;
        }
        if (preferences) {
            const consentedPurposes = Object.entries(preferences).filter(([_, isConsented])=>isConsented).map(([purposeCode])=>purposeCode);
            const existingPurposes = await Promise.all(consentedPurposes.map((purposeCode)=>typedContext.registry.findConsentPurposeByCode(purposeCode)));
            const purposesToCreate = consentedPurposes.filter((_purposeCode, index)=>!existingPurposes[index]);
            const createdPurposes = await Promise.all(purposesToCreate.map((purposeCode)=>typedContext.registry.createConsentPurpose({
                    code: purposeCode,
                    name: purposeCode,
                    description: `Auto-created consentPurpose for ${purposeCode}`,
                    isActive: true,
                    isEssential: false,
                    legalBasis: 'consent',
                    createdAt: now,
                    updatedAt: now
                })));
            purposeIds = [
                ...existingPurposes.filter((p)=>null !== p).map((p)=>p.id),
                ...createdPurposes.filter((p)=>null !== p).map((p)=>p.id)
            ];
            if (purposeIds.length !== consentedPurposes.length) throw new ORPCError('PURPOSE_CREATION_FAILED', {
                data: {
                    purposeCode: purposesToCreate[purposeIds.length - consentedPurposes.length]
                }
            });
        }
        const result = await typedContext.adapter.transaction({
            callback: async (tx)=>{
                const consentRecord = await tx.create({
                    model: 'consent',
                    data: {
                        subjectId: subject.id,
                        domainId: domainRecord.id,
                        policyId,
                        purposeIds,
                        status: 'active',
                        isActive: true,
                        givenAt: now,
                        ipAddress: typedContext.ipAddress || null,
                        userAgent: typedContext.userAgent || null,
                        history: []
                    }
                });
                const record = await tx.create({
                    model: 'consentRecord',
                    data: {
                        subjectId: subject.id,
                        consentId: consentRecord.id,
                        actionType: 'consent_given',
                        details: metadata,
                        createdAt: now
                    }
                });
                await tx.create({
                    model: 'auditLog',
                    data: {
                        subjectId: subject.id,
                        entityType: 'consent',
                        entityId: consentRecord.id,
                        actionType: 'consent_given',
                        details: {
                            consentId: consentRecord.id,
                            type
                        },
                        timestamp: now,
                        ipAddress: typedContext.ipAddress || null,
                        userAgent: typedContext.userAgent || null
                    }
                });
                return {
                    consent: consentRecord,
                    record
                };
            }
        });
        if (!result || !result.consent || !result.record) throw new ORPCError('CONSENT_CREATION_FAILED', {
            data: {
                subjectId: subject.id,
                domain
            }
        });
        return {
            id: result.consent.id,
            subjectId: subject.id,
            externalSubjectId: subject.externalId ?? void 0,
            identityProvider: subject.identityProvider ?? void 0,
            domainId: domainRecord.id,
            domain: domainRecord.name,
            type,
            status: result.consent.status,
            recordId: result.record.id,
            metadata,
            givenAt: result.consent.givenAt
        };
    } catch (error) {
        logger.error('Error in post-consent handler', {
            error: error instanceof Error ? error.message : String(error),
            errorType: error instanceof Error ? error.constructor.name : typeof error
        });
        if (error instanceof ORPCError) throw error;
        throw new ORPCError('INTERNAL_SERVER_ERROR', {
            message: error instanceof Error ? error.message : String(error)
        });
    }
});
function checkJurisdiction(countryCode) {
    const jurisdictions = {
        EU: new Set([
            'AT',
            'BE',
            'BG',
            'HR',
            'CY',
            'CZ',
            'DK',
            'EE',
            'FI',
            'FR',
            'DE',
            'GR',
            'HU',
            'IE',
            'IT',
            'LV',
            'LT',
            'LU',
            'MT',
            'NL',
            'PL',
            'PT',
            'RO',
            'SK',
            'SI',
            'ES',
            'SE'
        ]),
        EEA: new Set([
            'IS',
            'NO',
            'LI'
        ]),
        UK: new Set([
            'GB'
        ]),
        CH: new Set([
            'CH'
        ]),
        BR: new Set([
            'BR'
        ]),
        CA: new Set([
            'CA'
        ]),
        AU: new Set([
            'AU'
        ]),
        JP: new Set([
            'JP'
        ]),
        KR: new Set([
            'KR'
        ])
    };
    let showConsentBanner = true;
    let jurisdictionCode = 'NONE';
    if (countryCode) {
        const normalizedCountryCode = countryCode.toUpperCase();
        showConsentBanner = false;
        const jurisdictionMap = [
            {
                sets: [
                    jurisdictions.EU,
                    jurisdictions.EEA,
                    jurisdictions.UK
                ],
                code: 'GDPR'
            },
            {
                sets: [
                    jurisdictions.CH
                ],
                code: 'CH'
            },
            {
                sets: [
                    jurisdictions.BR
                ],
                code: 'BR'
            },
            {
                sets: [
                    jurisdictions.CA
                ],
                code: 'PIPEDA'
            },
            {
                sets: [
                    jurisdictions.AU
                ],
                code: 'AU'
            },
            {
                sets: [
                    jurisdictions.JP
                ],
                code: 'APPI'
            },
            {
                sets: [
                    jurisdictions.KR
                ],
                code: 'PIPA'
            }
        ];
        for (const { sets, code } of jurisdictionMap)if (sets.some((set)=>set.has(normalizedCountryCode))) {
            jurisdictionCode = code;
            showConsentBanner = true;
            break;
        }
    }
    const message = JurisdictionMessages[jurisdictionCode];
    return {
        showConsentBanner,
        jurisdictionCode,
        message
    };
}
function isSupportedBaseLanguage(lang) {
    return lang in baseTranslations;
}
function getPreferredLanguage(acceptLanguage, supportedLanguages) {
    if (!acceptLanguage) return 'en';
    const primaryLang = acceptLanguage.split(',')[0]?.split(';')[0]?.split('-')[0]?.toLowerCase();
    if (primaryLang && supportedLanguages.includes(primaryLang)) return primaryLang;
    return 'en';
}
function getTranslations(acceptLanguage, customTranslations) {
    const supportedDefaultLanguages = Object.keys(baseTranslations);
    const supportedCustomLanguages = Object.keys(customTranslations || {});
    const supportedLanguages = [
        ...supportedDefaultLanguages,
        ...supportedCustomLanguages
    ];
    const preferredLanguage = getPreferredLanguage(acceptLanguage, supportedLanguages);
    const base = isSupportedBaseLanguage(preferredLanguage) ? baseTranslations[preferredLanguage] : baseTranslations.en;
    const custom = supportedCustomLanguages.includes(preferredLanguage) ? customTranslations?.[preferredLanguage] : {};
    const translations = custom ? deepMergeTranslations(base, custom) : base;
    return {
        translations: translations,
        language: preferredLanguage
    };
}
function getHeaders(headers) {
    if (!headers) return {
        countryCode: null,
        regionCode: null,
        acceptLanguage: null
    };
    const normalizeHeader = (value)=>{
        if (!value) return null;
        return Array.isArray(value) ? value[0] ?? null : value;
    };
    const countryCode = normalizeHeader(headers.get('x-c15t-country')) ?? normalizeHeader(headers.get('cf-ipcountry')) ?? normalizeHeader(headers.get('x-vercel-ip-country')) ?? normalizeHeader(headers.get('x-amz-cf-ipcountry')) ?? normalizeHeader(headers.get('x-country-code'));
    const regionCode = normalizeHeader(headers.get('x-c15t-region')) ?? normalizeHeader(headers.get('x-vercel-ip-country-region')) ?? normalizeHeader(headers.get('x-region-code'));
    const acceptLanguage = normalizeHeader(headers.get('accept-language'));
    return {
        countryCode,
        regionCode,
        acceptLanguage
    };
}
function buildResponse({ shouldShowBanner, jurisdiction, location, acceptLanguage, customTranslations, branding = 'c15t' }) {
    return {
        showConsentBanner: shouldShowBanner,
        jurisdiction,
        location,
        translations: getTranslations(acceptLanguage, customTranslations),
        branding
    };
}
const handler_showConsentBanner = os.consent.showBanner.handler(({ context })=>{
    const typedContext = context;
    const { customTranslations, disableGeoLocation, branding } = typedContext.options.advanced ?? {};
    const { countryCode, regionCode, acceptLanguage } = getHeaders(typedContext.headers);
    if (disableGeoLocation) return buildResponse({
        shouldShowBanner: true,
        jurisdiction: {
            code: 'NONE',
            message: JurisdictionMessages.NONE
        },
        location: {
            countryCode: null,
            regionCode: null
        },
        acceptLanguage,
        customTranslations,
        branding
    });
    const { showConsentBanner, jurisdictionCode, message } = checkJurisdiction(countryCode);
    return buildResponse({
        shouldShowBanner: showConsentBanner,
        jurisdiction: {
            code: jurisdictionCode,
            message
        },
        location: {
            countryCode,
            regionCode
        },
        acceptLanguage,
        customTranslations,
        branding
    });
});
const verifyConsent = os.consent.verify.handler(async ({ input, context })=>{
    const typedContext = context;
    const logger = typedContext.logger;
    logger.info('Handling verify-consent request');
    const { type, subjectId, externalSubjectId, domain, policyId, preferences } = input;
    logger.debug('Request parameters', {
        type,
        subjectId,
        externalSubjectId,
        domain,
        policyId,
        preferences
    });
    try {
        const subject = await typedContext.registry.findOrCreateSubject({
            subjectId,
            externalSubjectId,
            ipAddress: typedContext.ipAddress || 'unknown'
        });
        if (!subject) throw new ORPCError('SUBJECT_NOT_FOUND', {
            data: {
                subjectId,
                externalSubjectId
            }
        });
        const domainRecord = await typedContext.registry.findDomain(domain);
        if (!domainRecord) throw new ORPCError('DOMAIN_NOT_FOUND', {
            data: {
                domain
            }
        });
        if ('cookie_banner' === type && (!preferences || 0 === preferences.length)) throw new ORPCError('COOKIE_BANNER_PREFERENCES_REQUIRED', {
            data: {
                type: 'cookie_banner'
            }
        });
        const purposePromises = preferences?.map((purpose)=>typedContext.registry.findConsentPurposeByCode(purpose));
        const rawPurposes = await Promise.all(purposePromises ?? []);
        const purposeIds = rawPurposes.filter((purpose)=>null !== purpose).map((purpose)=>purpose.id);
        if (purposeIds.length !== (preferences?.length ?? 0)) throw new ORPCError('PURPOSES_NOT_FOUND', {
            data: {
                preferences: preferences ?? [],
                foundPurposes: rawPurposes.filter((p)=>null !== p).map((p)=>p.code)
            }
        });
        if (policyId) {
            const policy = await typedContext.registry.findConsentPolicyById(policyId);
            if (!policy || policy.type !== type) throw new ORPCError('POLICY_NOT_FOUND', {
                data: {
                    policyId,
                    type
                }
            });
            return await checkPolicyConsent({
                policyId: policy.id,
                subjectId: subject.id,
                domainId: domainRecord.id,
                purposeIds,
                type,
                context: typedContext
            });
        }
        const latestPolicy = await typedContext.registry.findOrCreatePolicy(type);
        if (!latestPolicy) throw new ORPCError('POLICY_NOT_FOUND', {
            data: {
                policyId: 'latest',
                type
            }
        });
        return await checkPolicyConsent({
            policyId: latestPolicy.id,
            subjectId: subject.id,
            domainId: domainRecord.id,
            purposeIds,
            type,
            context: typedContext
        });
    } catch (error) {
        logger.error('Error in verify-consent handler', {
            error: error instanceof Error ? error.message : String(error),
            errorType: error instanceof Error ? error.constructor.name : typeof error
        });
        if (error instanceof ORPCError) throw error;
        throw new ORPCError('INTERNAL_SERVER_ERROR', {
            message: error instanceof Error ? error.message : String(error)
        });
    }
});
async function checkPolicyConsent({ policyId, subjectId, domainId, purposeIds, type, context }) {
    const { registry, adapter } = context;
    const rawConsents = await adapter.findMany({
        model: 'consent',
        where: [
            {
                field: 'subjectId',
                value: subjectId
            },
            {
                field: 'policyId',
                value: policyId
            },
            {
                field: 'domainId',
                value: domainId
            }
        ],
        sortBy: {
            field: 'givenAt',
            direction: 'desc'
        }
    });
    const filteredConsents = rawConsents.filter((consent)=>{
        if (!purposeIds) return true;
        return purposeIds.every((id)=>consent.purposeIds.some((purposeId)=>purposeId === id));
    });
    await registry.createAuditLog({
        subjectId,
        entityType: 'consent_policy',
        entityId: policyId,
        actionType: 'verify_consent',
        metadata: {
            type,
            policyId,
            purposeIds,
            success: 0 !== filteredConsents.length,
            ...filteredConsents.length > 0 ? {
                consentId: filteredConsents[0]?.id
            } : {}
        }
    });
    if (0 === rawConsents.length) throw new ORPCError('NO_CONSENT_FOUND', {
        data: {
            policyId,
            subjectId,
            domainId
        }
    });
    if (0 === filteredConsents.length) throw new ORPCError('NO_CONSENT_FOUND', {
        data: {
            policyId,
            subjectId,
            domainId
        }
    });
    return {
        isValid: true,
        consent: filteredConsents[0]
    };
}
const consentHandlers = {
    post: postConsent,
    showBanner: handler_showConsentBanner,
    verify: verifyConsent,
    identify: identifyUser
};
const statusHandler = os.meta.status.handler(({ context })=>{
    const typedContext = context;
    const headers = typedContext.headers;
    const normalizeHeader = (value)=>{
        if (!value) return null;
        return Array.isArray(value) ? value[0] ?? null : value;
    };
    const countryCode = normalizeHeader(headers?.get('cf-ipcountry')) ?? normalizeHeader(headers?.get('x-vercel-ip-country')) ?? normalizeHeader(headers?.get('x-amz-cf-ipcountry')) ?? normalizeHeader(headers?.get('x-country-code'));
    const regionCode = normalizeHeader(headers?.get('x-vercel-ip-country-region')) ?? normalizeHeader(headers?.get('x-region-code'));
    return {
        status: 'ok',
        version: "1.8.0",
        timestamp: new Date(),
        storage: {
            type: typedContext.adapter?.id ?? 'MemoryAdapter',
            available: !!typedContext.adapter
        },
        client: {
            ip: typedContext.ipAddress ?? null,
            userAgent: typedContext.userAgent ?? null,
            region: {
                countryCode,
                regionCode
            }
        }
    };
});
const metaHandlers = {
    status: statusHandler
};
const router = os.router({
    consent: consentHandlers,
    meta: metaHandlers
});
export { router };
