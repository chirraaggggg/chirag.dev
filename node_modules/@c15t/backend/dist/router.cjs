"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.n = (module)=>{
        var getter = module && module.__esModule ? ()=>module['default'] : ()=>module;
        __webpack_require__.d(getter, {
            a: getter
        });
        return getter;
    };
})();
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
(()=>{
    __webpack_require__.r = (exports1)=>{
        if ('undefined' != typeof Symbol && Symbol.toStringTag) Object.defineProperty(exports1, Symbol.toStringTag, {
            value: 'Module'
        });
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
    };
})();
var __webpack_exports__ = {};
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
    router: ()=>router
});
const server_namespaceObject = require("@orpc/server");
const contract_namespaceObject = require("@orpc/contract");
const external_zod_namespaceObject = require("zod");
const identifyUserSchema = external_zod_namespaceObject.z.object({
    consentId: external_zod_namespaceObject.z.string(),
    externalId: external_zod_namespaceObject.z.string(),
    identityProvider: external_zod_namespaceObject.z.string().optional()
});
const identifyUserContract = contract_namespaceObject.oc.route({
    method: 'PATCH',
    path: '/consent/identify',
    description: "Links a subject's external ID to a consent record by consent ID. This is used to identify a user across multiple devices and sessions.",
    tags: [
        'consent',
        'cookie-banner'
    ]
}).errors({
    CONSENT_NOT_FOUND: {
        status: 404,
        data: external_zod_namespaceObject.z.object({
            consentId: external_zod_namespaceObject.z.string()
        }),
        error: 'Consent not found'
    },
    IDENTIFICATION_FAILED: {
        status: 500,
        data: external_zod_namespaceObject.z.object({
            consentId: external_zod_namespaceObject.z.string()
        }),
        error: 'Failed to identify user'
    }
}).input(identifyUserSchema).output(external_zod_namespaceObject.z.object({
    success: external_zod_namespaceObject.z.boolean()
}));
const COMMON_TIMEZONES = {
    UTC: 'UTC',
    GMT: 'GMT',
    EASTERN: 'America/New_York',
    CENTRAL: 'America/Chicago',
    MOUNTAIN: 'America/Denver',
    PACIFIC: 'America/Los_Angeles',
    LONDON: 'Europe/London',
    PARIS: 'Europe/Paris',
    BERLIN: 'Europe/Berlin',
    TOKYO: 'Asia/Tokyo',
    SHANGHAI: 'Asia/Shanghai',
    SINGAPORE: 'Asia/Singapore',
    SYDNEY: 'Australia/Sydney',
    SAO_PAULO: 'America/Sao_Paulo'
};
const external_base_x_namespaceObject = require("base-x");
var external_base_x_default = /*#__PURE__*/ __webpack_require__.n(external_base_x_namespaceObject);
external_base_x_default()('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');
const fieldConfigSchema = external_zod_namespaceObject.z.object({
    required: external_zod_namespaceObject.z.boolean().prefault(true),
    returned: external_zod_namespaceObject.z.boolean().prefault(true),
    input: external_zod_namespaceObject.z.boolean().prefault(true),
    defaultValue: external_zod_namespaceObject.z.any().optional(),
    transform: external_zod_namespaceObject.z.object({
        input: external_zod_namespaceObject.z.any().optional(),
        output: external_zod_namespaceObject.z.any().optional()
    }).optional(),
    validator: external_zod_namespaceObject.z.any().optional(),
    unique: external_zod_namespaceObject.z.boolean().optional(),
    indexed: external_zod_namespaceObject.z.boolean().optional(),
    sortable: external_zod_namespaceObject.z.boolean().prefault(true),
    fieldName: external_zod_namespaceObject.z.string().optional(),
    bigint: external_zod_namespaceObject.z.boolean().prefault(false)
});
const stringFieldSchema = fieldConfigSchema.extend({
    type: external_zod_namespaceObject.z.literal('string'),
    minLength: external_zod_namespaceObject.z.number().optional(),
    maxLength: external_zod_namespaceObject.z.number().optional(),
    pattern: external_zod_namespaceObject.z.string().optional()
});
const numberFieldSchema = fieldConfigSchema.extend({
    type: external_zod_namespaceObject.z.literal('number'),
    min: external_zod_namespaceObject.z.number().optional(),
    max: external_zod_namespaceObject.z.number().optional()
});
const booleanFieldSchema = fieldConfigSchema.extend({
    type: external_zod_namespaceObject.z.literal('boolean')
});
const dateFieldSchema = fieldConfigSchema.extend({
    type: external_zod_namespaceObject.z.literal('date'),
    minDate: external_zod_namespaceObject.z.date().optional(),
    maxDate: external_zod_namespaceObject.z.date().optional(),
    dateOnly: external_zod_namespaceObject.z.boolean().prefault(false),
    format: external_zod_namespaceObject.z.record(external_zod_namespaceObject.z.string(), external_zod_namespaceObject.z.unknown()).optional()
});
const timezoneFieldSchema = fieldConfigSchema.extend({
    type: external_zod_namespaceObject.z.literal('timezone'),
    validateTimezone: external_zod_namespaceObject.z.boolean().prefault(true),
    suggestedValues: external_zod_namespaceObject.z.array(external_zod_namespaceObject.z.string()).optional(),
    restrictToSuggestedValues: external_zod_namespaceObject.z.boolean().prefault(false)
});
const jsonFieldSchema = fieldConfigSchema.extend({
    type: external_zod_namespaceObject.z.literal('json'),
    validateJson: external_zod_namespaceObject.z.boolean().prefault(true)
});
const stringArrayFieldSchema = fieldConfigSchema.extend({
    type: external_zod_namespaceObject.z.literal('string[]')
});
const numberArrayFieldSchema = fieldConfigSchema.extend({
    type: external_zod_namespaceObject.z.literal('number[]')
});
external_zod_namespaceObject.z.discriminatedUnion('type', [
    stringFieldSchema,
    numberFieldSchema,
    booleanFieldSchema,
    dateFieldSchema,
    timezoneFieldSchema,
    jsonFieldSchema,
    stringArrayFieldSchema,
    numberArrayFieldSchema
]);
require("neverthrow");
const error_codes_ERROR_CODES = Object.freeze({
    NOT_FOUND: 'Resource not found',
    BAD_REQUEST: 'Bad request',
    CONFLICT: 'Conflict with current state',
    MISSING_REQUIRED_PARAMETER: 'Missing required parameter',
    UNAUTHORIZED: 'Unauthorized',
    FORBIDDEN: 'Forbidden',
    INTERNAL_SERVER_ERROR: 'Internal server error',
    INITIALIZATION_FAILED: 'Initialization failed',
    DATABASE_CONNECTION_ERROR: 'Database connection error',
    DATABASE_QUERY_ERROR: 'Database query error',
    INVALID_CONFIGURATION: 'Invalid configuration',
    REQUEST_HANDLER_ERROR: 'Request handler error',
    INVALID_REQUEST: 'Invalid request',
    UNKNOWN_ERROR: 'Unknown error',
    NETWORK_ERROR: 'Network error',
    PLUGIN_INITIALIZATION_FAILED: 'Plugin initialization failed',
    API_RETRIEVAL_ERROR: 'API retrieval error',
    VALIDATION_ERROR: 'Validation error',
    UNEXPECTED: 'Unexpected error'
});
const ERROR_CATEGORIES = Object.freeze({
    VALIDATION: 'validation',
    AUTHORIZATION: 'authorization',
    STORAGE: 'storage',
    NETWORK: 'network',
    PLUGIN: 'plugin',
    CONFIGURATION: 'configuration',
    UNEXPECTED: 'unexpected'
});
const api_namespaceObject = require("@opentelemetry/api");
api_namespaceObject.trace.getTracer('@doubletie/results');
class error_class_DoubleTieError extends server_namespaceObject.ORPCError {
    category;
    meta;
    statusCode;
    constructor(message, options = {
        code: error_codes_ERROR_CODES.UNKNOWN_ERROR,
        status: 500,
        category: ERROR_CATEGORIES.UNEXPECTED,
        cause: void 0,
        meta: {}
    }){
        super(options.code ?? error_codes_ERROR_CODES.UNKNOWN_ERROR, {
            message,
            cause: options.cause,
            data: options.meta ?? {}
        });
        this.name = 'DoubleTieError';
        this.category = options.category ?? ERROR_CATEGORIES.UNEXPECTED;
        this.meta = options.meta ?? {};
        this.statusCode = options.status ?? 500;
        tracing_withSpan('create_doubletie_error', async (span)=>{
            span.setAttributes({
                'error.name': this.constructor.name,
                'error.message': message,
                'error.code': this.code,
                'error.status': this.statusCode,
                'error.category': this.category,
                'error.has_cause': !!this.cause,
                'error.cause_type': this.cause instanceof Error ? this.cause.constructor.name : typeof this.cause,
                'error.has_meta': !!this.meta
            });
            if (this.cause instanceof Error) span.recordException(this.cause);
        });
        if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
    }
    static isDoubleTieError(error) {
        return error instanceof error_class_DoubleTieError;
    }
    toJSON() {
        const validationErrorMessage = this.meta?.validationErrors ? String(this.meta.validationErrors) : void 0;
        const stackTrace = this.stack ? this.stack.split('\n').map((line)=>line.trim()).filter((line)=>line && !line.includes('Error: ')) : [];
        return {
            code: this.code,
            message: validationErrorMessage || this.message,
            status: this.statusCode,
            defined: true,
            data: {
                category: this.category,
                meta: this.meta,
                ...'production' === process.env.NODE_ENV ? {} : {
                    stack: stackTrace
                },
                ...validationErrorMessage && this.message ? {
                    originalMessage: this.message
                } : {},
                ...this.cause ? {
                    cause: this.cause instanceof Error ? {
                        name: this.cause.name,
                        message: this.cause.message,
                        stack: this.cause.stack ? this.cause.stack.split('\n').map((line)=>line.trim()) : void 0
                    } : this.cause
                } : {}
            }
        };
    }
    static fromResponse(response, data) {
        let message = `HTTP error ${response.status}`;
        let errorCode = `HTTP ${response.status}`;
        let errorMeta = {};
        if (data && 'object' == typeof data && null !== data) {
            const errorObj = data;
            if ('string' == typeof errorObj.message) message = errorObj.message;
            if ('string' == typeof errorObj.code) errorCode = errorObj.code;
            if ('object' == typeof errorObj.data && null !== errorObj.data) errorMeta = errorObj.data;
        }
        return new error_class_DoubleTieError(message, {
            code: errorCode,
            status: response.status,
            meta: errorMeta
        });
    }
    withMeta(additionalMeta) {
        return new error_class_DoubleTieError(this.message, {
            code: this.code,
            status: this.statusCode,
            category: this.category,
            cause: this.cause instanceof Error ? this.cause : void 0,
            meta: {
                ...this.meta,
                ...additionalMeta
            }
        });
    }
    static createSubclass(name) {
        const ErrorSubclass = class extends error_class_DoubleTieError {
            constructor(message, options){
                super(message, options);
                Object.defineProperty(this, 'name', {
                    value: name
                });
            }
        };
        Object.defineProperty(ErrorSubclass, 'name', {
            value: name
        });
        return ErrorSubclass;
    }
    static formatValidationError(error) {
        if (!error.meta) return error.message;
        let formattedMessage = `${error.message} (${error.code})`;
        if (error.meta.validationErrors) formattedMessage += `\nValidation Errors: ${JSON.stringify(error.meta.validationErrors, null, 2)}`;
        const otherMeta = Object.fromEntries(Object.entries(error.meta).filter(([key])=>'validationErrors' !== key));
        if (Object.keys(otherMeta).length > 0) formattedMessage += `\nAdditional Context: ${JSON.stringify(otherMeta, null, 2)}`;
        return formattedMessage;
    }
}
const logger_namespaceObject = require("@c15t/logger");
const schema_auditLogSchema = external_zod_namespaceObject.z.object({
    id: external_zod_namespaceObject.z.string(),
    entityType: external_zod_namespaceObject.z.string(),
    entityId: external_zod_namespaceObject.z.string(),
    actionType: external_zod_namespaceObject.z.string(),
    subjectId: external_zod_namespaceObject.z.string().optional(),
    ipAddress: external_zod_namespaceObject.z.string().optional(),
    userAgent: external_zod_namespaceObject.z.string().optional(),
    changes: external_zod_namespaceObject.z.record(external_zod_namespaceObject.z.string(), external_zod_namespaceObject.z.unknown()).optional(),
    metadata: external_zod_namespaceObject.z.record(external_zod_namespaceObject.z.string(), external_zod_namespaceObject.z.unknown()).optional(),
    createdAt: external_zod_namespaceObject.z.date().prefault(()=>new Date())
});
function getAuditLogTable(options, auditLogFields) {
    const auditLogConfig = options.tables?.auditLog;
    const subjectConfig = options.tables?.subject;
    return {
        entityName: auditLogConfig?.entityName || 'auditLog',
        entityPrefix: auditLogConfig?.entityPrefix || 'log',
        schema: schema_auditLogSchema,
        fields: {
            entityType: {
                type: 'string',
                required: true,
                fieldName: auditLogConfig?.fields?.entityType || 'entityType'
            },
            entityId: {
                type: 'string',
                required: true,
                fieldName: auditLogConfig?.fields?.entityId || 'entityId'
            },
            actionType: {
                type: 'string',
                required: true,
                fieldName: auditLogConfig?.fields?.actionType || 'actionType'
            },
            subjectId: {
                type: 'string',
                required: false,
                fieldName: auditLogConfig?.fields?.subjectId || 'subjectId',
                references: {
                    model: subjectConfig?.entityName || 'subject',
                    field: 'id'
                }
            },
            ipAddress: {
                type: 'string',
                required: false,
                fieldName: auditLogConfig?.fields?.ipAddress || 'ipAddress'
            },
            userAgent: {
                type: 'string',
                required: false,
                fieldName: auditLogConfig?.fields?.userAgent || 'userAgent'
            },
            changes: {
                type: 'json',
                required: false,
                fieldName: auditLogConfig?.fields?.changes || 'changes'
            },
            metadata: {
                type: 'json',
                required: false,
                fieldName: auditLogConfig?.fields?.metadata || 'metadata'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: auditLogConfig?.fields?.createdAt || 'createdAt'
            },
            eventTimezone: {
                type: 'timezone',
                required: true,
                defaultValue: COMMON_TIMEZONES.UTC,
                fieldName: auditLogConfig?.fields?.eventTimezone || 'eventTimezone'
            },
            ...auditLogFields || {},
            ...auditLogConfig?.additionalFields || {}
        },
        indexes: [
            {
                name: 'entity_index',
                fields: [
                    'entityType',
                    'entityId'
                ]
            },
            {
                name: 'action_type_index',
                fields: [
                    'actionType'
                ]
            },
            {
                name: 'subject_id_index',
                fields: [
                    'subjectId'
                ]
            },
            {
                name: 'created_at_index',
                fields: [
                    'createdAt'
                ]
            }
        ],
        order: 5
    };
}
const schema_consentSchema = external_zod_namespaceObject.z.object({
    id: external_zod_namespaceObject.z.string(),
    subjectId: external_zod_namespaceObject.z.string(),
    domainId: external_zod_namespaceObject.z.string(),
    purposeIds: external_zod_namespaceObject.z.array(external_zod_namespaceObject.z.string()),
    metadata: external_zod_namespaceObject.z.record(external_zod_namespaceObject.z.string(), external_zod_namespaceObject.z.unknown()).nullable().optional(),
    policyId: external_zod_namespaceObject.z.string().optional(),
    ipAddress: external_zod_namespaceObject.z.string().nullable().optional(),
    userAgent: external_zod_namespaceObject.z.string().nullable().optional(),
    status: external_zod_namespaceObject.z["enum"]([
        'active',
        'withdrawn',
        'expired'
    ]).prefault('active'),
    withdrawalReason: external_zod_namespaceObject.z.string().nullable().optional(),
    givenAt: external_zod_namespaceObject.z.date().prefault(()=>new Date()),
    validUntil: external_zod_namespaceObject.z.date().nullable().optional(),
    isActive: external_zod_namespaceObject.z.boolean().prefault(true)
});
function getConsentTable(options, consentFields) {
    const consentConfig = options.tables?.consent;
    const subjectConfig = options.tables?.subject;
    const domainConfig = options.tables?.domain;
    const policyConfig = options.tables?.consentPolicy;
    return {
        entityName: consentConfig?.entityName || 'consent',
        entityPrefix: consentConfig?.entityPrefix || 'cns',
        schema: schema_consentSchema,
        fields: {
            subjectId: {
                type: 'string',
                required: true,
                fieldName: consentConfig?.fields?.subjectId || 'subjectId',
                references: {
                    model: subjectConfig?.entityName || 'subject',
                    field: 'id'
                }
            },
            domainId: {
                type: 'string',
                required: true,
                fieldName: consentConfig?.fields?.domainId || 'domainId',
                references: {
                    model: domainConfig?.entityName || 'domain',
                    field: 'id'
                }
            },
            purposeIds: {
                type: 'json',
                required: false,
                fieldName: consentConfig?.fields?.purposeIds || 'purposeIds'
            },
            metadata: {
                type: 'json',
                required: false,
                fieldName: consentConfig?.fields?.metadata || 'metadata'
            },
            policyId: {
                type: 'string',
                required: false,
                fieldName: consentConfig?.fields?.policyId || 'policyId',
                references: {
                    model: policyConfig?.entityName || 'consentPolicy',
                    field: 'id'
                }
            },
            ipAddress: {
                type: 'string',
                required: false,
                fieldName: consentConfig?.fields?.ipAddress || 'ipAddress'
            },
            userAgent: {
                type: 'string',
                required: false,
                fieldName: consentConfig?.fields?.userAgent || 'userAgent'
            },
            status: {
                type: 'string',
                defaultValue: ()=>'active',
                required: true,
                fieldName: consentConfig?.fields?.status || 'status'
            },
            withdrawalReason: {
                type: 'string',
                required: false,
                fieldName: consentConfig?.fields?.withdrawalReason || 'withdrawalReason'
            },
            givenAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: consentConfig?.fields?.givenAt || 'givenAt'
            },
            validUntil: {
                type: 'date',
                required: false,
                fieldName: consentConfig?.fields?.validUntil || 'validUntil',
                transform: {
                    input: (val, data)=>{
                        if (val) return val;
                        const expiresIn = consentConfig?.expiresIn || 31536000;
                        const givenAt = data.givenAt instanceof Date ? data.givenAt : new Date();
                        if (expiresIn > 0) {
                            const validUntil = new Date(givenAt);
                            validUntil.setSeconds(validUntil.getSeconds() + expiresIn);
                            return validUntil;
                        }
                    }
                }
            },
            isActive: {
                type: 'boolean',
                defaultValue: true,
                required: true,
                fieldName: consentConfig?.fields?.isActive || 'isActive'
            },
            ...consentFields || {},
            ...consentConfig?.additionalFields || {}
        },
        order: 3
    };
}
const PolicyTypeSchema = external_zod_namespaceObject.z["enum"]([
    'cookie_banner',
    'privacy_policy',
    'dpa',
    'terms_and_conditions',
    'marketing_communications',
    'age_verification',
    'other'
]);
const schema_consentPolicySchema = external_zod_namespaceObject.z.object({
    id: external_zod_namespaceObject.z.string(),
    version: external_zod_namespaceObject.z.string(),
    type: PolicyTypeSchema,
    name: external_zod_namespaceObject.z.string(),
    effectiveDate: external_zod_namespaceObject.z.date(),
    expirationDate: external_zod_namespaceObject.z.date().nullable().optional(),
    content: external_zod_namespaceObject.z.string(),
    contentHash: external_zod_namespaceObject.z.string(),
    isActive: external_zod_namespaceObject.z.boolean().prefault(true),
    createdAt: external_zod_namespaceObject.z.date().prefault(()=>new Date()),
    updatedAt: external_zod_namespaceObject.z.date().prefault(()=>new Date())
});
function getConsentPolicyTable(options, policyFields) {
    const consentPolicyConfig = options.tables?.consentPolicy;
    return {
        entityName: consentPolicyConfig?.entityName || 'consentPolicy',
        entityPrefix: consentPolicyConfig?.entityPrefix || 'pol',
        schema: schema_consentPolicySchema,
        fields: {
            version: {
                type: 'string',
                required: true,
                fieldName: consentPolicyConfig?.fields?.version || 'version'
            },
            type: {
                type: 'string',
                required: true,
                fieldName: consentPolicyConfig?.fields?.type || 'type'
            },
            name: {
                type: 'string',
                required: true,
                fieldName: consentPolicyConfig?.fields?.name || 'name'
            },
            effectiveDate: {
                type: 'date',
                required: true,
                fieldName: consentPolicyConfig?.fields?.effectiveDate || 'effectiveDate'
            },
            expirationDate: {
                type: 'date',
                required: false,
                fieldName: consentPolicyConfig?.fields?.expirationDate || 'expirationDate'
            },
            content: {
                type: 'string',
                required: true,
                fieldName: consentPolicyConfig?.fields?.content || 'content'
            },
            contentHash: {
                type: 'string',
                required: true,
                fieldName: consentPolicyConfig?.fields?.contentHash || 'contentHash'
            },
            isActive: {
                type: 'boolean',
                defaultValue: true,
                required: true,
                fieldName: consentPolicyConfig?.fields?.isActive || 'isActive'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: consentPolicyConfig?.fields?.createdAt || 'createdAt'
            },
            ...policyFields || {},
            ...consentPolicyConfig?.additionalFields || {}
        },
        order: 2
    };
}
const schema_purposeSchema = external_zod_namespaceObject.z.object({
    id: external_zod_namespaceObject.z.string(),
    code: external_zod_namespaceObject.z.string(),
    name: external_zod_namespaceObject.z.string(),
    description: external_zod_namespaceObject.z.string(),
    isEssential: external_zod_namespaceObject.z.boolean().prefault(false),
    dataCategory: external_zod_namespaceObject.z.string().nullish(),
    legalBasis: external_zod_namespaceObject.z.string().nullish(),
    isActive: external_zod_namespaceObject.z.boolean().prefault(true),
    createdAt: external_zod_namespaceObject.z.date().prefault(()=>new Date()),
    updatedAt: external_zod_namespaceObject.z.date().prefault(()=>new Date())
});
function getPurposeTable(options, purposeFields) {
    const purposeConfig = options.tables?.consentPurpose;
    return {
        entityName: purposeConfig?.entityName || 'consentPurpose',
        entityPrefix: purposeConfig?.entityPrefix || 'pur',
        schema: schema_purposeSchema,
        fields: {
            code: {
                type: 'string',
                required: true,
                fieldName: purposeConfig?.fields?.code || 'code'
            },
            name: {
                type: 'string',
                required: true,
                fieldName: purposeConfig?.fields?.name || 'name'
            },
            description: {
                type: 'string',
                required: true,
                fieldName: purposeConfig?.fields?.description || "description"
            },
            isEssential: {
                type: 'boolean',
                defaultValue: ()=>false,
                required: true,
                fieldName: purposeConfig?.fields?.isEssential || 'isEssential'
            },
            dataCategory: {
                type: 'string',
                required: false,
                fieldName: purposeConfig?.fields?.dataCategory || 'dataCategory'
            },
            legalBasis: {
                type: 'string',
                required: false,
                fieldName: purposeConfig?.fields?.legalBasis || 'legalBasis'
            },
            isActive: {
                type: 'boolean',
                defaultValue: true,
                required: true,
                fieldName: purposeConfig?.fields?.isActive || 'isActive'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: purposeConfig?.fields?.createdAt || 'createdAt'
            },
            updatedAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: purposeConfig?.fields?.updatedAt || 'updatedAt'
            },
            ...purposeFields || {},
            ...purposeConfig?.additionalFields || {}
        },
        order: 1
    };
}
const schema_consentRecordSchema = external_zod_namespaceObject.z.object({
    id: external_zod_namespaceObject.z.string(),
    subjectId: external_zod_namespaceObject.z.string(),
    consentId: external_zod_namespaceObject.z.string().optional(),
    actionType: external_zod_namespaceObject.z.string(),
    details: external_zod_namespaceObject.z.record(external_zod_namespaceObject.z.string(), external_zod_namespaceObject.z.unknown()).optional(),
    createdAt: external_zod_namespaceObject.z.date().prefault(()=>new Date()),
    updatedAt: external_zod_namespaceObject.z.date().prefault(()=>new Date())
});
function getConsentRecordTable(options, recordFields) {
    const recordConfig = options.tables?.record;
    const subjectConfig = options.tables?.subject;
    const consentConfig = options.tables?.consent;
    return {
        entityName: recordConfig?.entityName || 'consentRecord',
        entityPrefix: recordConfig?.entityPrefix || 'rec',
        schema: schema_consentRecordSchema,
        fields: {
            subjectId: {
                type: 'string',
                required: true,
                fieldName: recordConfig?.fields?.subjectId || 'subjectId',
                references: {
                    model: subjectConfig?.entityName || 'subject',
                    field: 'id'
                }
            },
            consentId: {
                type: 'string',
                required: false,
                fieldName: recordConfig?.fields?.consentId || 'consentId',
                references: {
                    model: consentConfig?.entityName || 'consent',
                    field: 'id'
                }
            },
            actionType: {
                type: 'string',
                required: true,
                fieldName: recordConfig?.fields?.actionType || 'actionType'
            },
            details: {
                type: 'json',
                required: false,
                fieldName: recordConfig?.fields?.details || 'details'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: recordConfig?.fields?.createdAt || 'createdAt'
            },
            ...recordFields || {},
            ...recordConfig?.additionalFields || {}
        },
        order: 4
    };
}
const schema_domainSchema = external_zod_namespaceObject.z.object({
    id: external_zod_namespaceObject.z.string(),
    name: external_zod_namespaceObject.z.string().min(1),
    description: external_zod_namespaceObject.z.string().optional(),
    allowedOrigins: external_zod_namespaceObject.z.array(external_zod_namespaceObject.z.string()).optional().prefault([]),
    isVerified: external_zod_namespaceObject.z.boolean().prefault(true),
    isActive: external_zod_namespaceObject.z.boolean().prefault(true),
    createdAt: external_zod_namespaceObject.z.date().prefault(()=>new Date()),
    updatedAt: external_zod_namespaceObject.z.date().prefault(()=>new Date())
});
function getDomainTable(options, domainFields) {
    const domainConfig = options.tables?.domain;
    return {
        entityName: domainConfig?.entityName || 'domain',
        entityPrefix: domainConfig?.entityPrefix || 'dom',
        schema: schema_domainSchema,
        fields: {
            name: {
                type: 'string',
                required: true,
                unique: true,
                fieldName: domainConfig?.fields?.name || 'name'
            },
            description: {
                type: 'string',
                required: false,
                fieldName: domainConfig?.fields?.description || "description"
            },
            allowedOrigins: {
                type: 'json',
                defaultValue: ()=>[],
                required: false,
                fieldName: domainConfig?.fields?.allowedOrigins || 'allowedOrigins'
            },
            isVerified: {
                type: 'boolean',
                defaultValue: true,
                required: true,
                fieldName: domainConfig?.fields?.isVerified || 'isVerified'
            },
            isActive: {
                type: 'boolean',
                defaultValue: true,
                required: true,
                fieldName: domainConfig?.fields?.isActive || 'isActive'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: domainConfig?.fields?.createdAt || 'createdAt'
            },
            updatedAt: {
                type: 'date',
                required: false,
                fieldName: domainConfig?.fields?.updatedAt || 'updatedAt'
            },
            ...domainFields || {},
            ...domainConfig?.additionalFields || {}
        },
        order: 1
    };
}
const schema_subjectSchema = external_zod_namespaceObject.z.object({
    id: external_zod_namespaceObject.z.string(),
    isIdentified: external_zod_namespaceObject.z.boolean().prefault(false),
    externalId: external_zod_namespaceObject.z.string().nullable().optional(),
    identityProvider: external_zod_namespaceObject.z.string().optional(),
    lastIpAddress: external_zod_namespaceObject.z.string().optional(),
    createdAt: external_zod_namespaceObject.z.date().prefault(()=>new Date()),
    updatedAt: external_zod_namespaceObject.z.date().prefault(()=>new Date())
});
function getSubjectTable(options, subjectFields) {
    const subjectConfig = options.tables?.subject;
    return {
        entityName: subjectConfig?.entityName || 'subject',
        entityPrefix: subjectConfig?.entityPrefix || 'sub',
        schema: schema_subjectSchema,
        fields: {
            isIdentified: {
                type: 'boolean',
                defaultValue: ()=>false,
                required: true,
                fieldName: subjectConfig?.fields?.isIdentified || 'isIdentified'
            },
            externalId: {
                type: 'string',
                required: false,
                fieldName: subjectConfig?.fields?.externalId || 'externalId'
            },
            identityProvider: {
                type: 'string',
                required: false,
                fieldName: subjectConfig?.fields?.identityProvider || 'identityProvider'
            },
            lastIpAddress: {
                type: 'string',
                required: false,
                fieldName: subjectConfig?.fields?.lastIpAddress || 'lastIpAddress'
            },
            createdAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: subjectConfig?.fields?.createdAt || 'createdAt'
            },
            updatedAt: {
                type: 'date',
                defaultValue: ()=>new Date(),
                required: true,
                fieldName: subjectConfig?.fields?.updatedAt || 'updatedAt'
            },
            subjectTimezone: {
                type: 'timezone',
                required: false,
                defaultValue: COMMON_TIMEZONES.UTC,
                fieldName: subjectConfig?.fields?.subjectTimezone || 'subjectTimezone'
            },
            ...subjectFields || {},
            ...subjectConfig?.additionalFields || {}
        },
        order: 1
    };
}
const getConsentTables = (options)=>{
    const pluginSchema = options.plugins?.reduce((acc, plugin)=>{
        const schema = plugin.schema;
        if (!schema) return acc;
        for (const [key, value] of Object.entries(schema))acc[key] = {
            fields: {
                ...acc[key]?.fields,
                ...value.fields
            },
            entityName: key
        };
        return acc;
    }, {});
    const { subject, consentPurpose, consentPolicy, domain, geoLocation, consent, consentPurposeJunction, record, consentGeoLocation, consentWithdrawal, auditLog, ...pluginTables } = pluginSchema || {};
    return {
        subject: getSubjectTable(options, subject?.fields),
        consentPurpose: getPurposeTable(options, consentPurpose?.fields),
        consentPolicy: getConsentPolicyTable(options, consentPolicy?.fields),
        domain: getDomainTable(options, domain?.fields),
        consent: getConsentTable(options, consent?.fields),
        consentRecord: getConsentRecordTable(options, record?.fields),
        auditLog: getAuditLogTable(options, auditLog?.fields),
        ...pluginTables
    };
};
function definition_validateEntityOutput(tableName, data, options) {
    const tables = getConsentTables(options);
    const table = tables[tableName];
    if (!table) throw new Error(`Table ${tableName} not found`);
    const processedData = {
        ...data
    };
    for (const [field, def] of Object.entries(table.fields))if ('date' === def.type && 'string' == typeof processedData[field]) processedData[field] = new Date(processedData[field]);
    try {
        return table.schema.parse(processedData);
    } catch (error) {
        if (error instanceof external_zod_namespaceObject.ZodError) logger_namespaceObject.logger.error(`[validateEntityOutput] Validation failed for table ${String(tableName)}`, {
            table,
            issues: error.issues
        });
        throw error;
    }
}
const baseConsentSchema = external_zod_namespaceObject.z.object({
    subjectId: external_zod_namespaceObject.z.string().optional(),
    externalSubjectId: external_zod_namespaceObject.z.string().optional(),
    identityProvider: external_zod_namespaceObject.z.string().optional(),
    domain: external_zod_namespaceObject.z.string(),
    type: PolicyTypeSchema,
    metadata: external_zod_namespaceObject.z.record(external_zod_namespaceObject.z.string(), external_zod_namespaceObject.z.unknown()).optional()
});
const cookieBannerSchema = baseConsentSchema.extend({
    type: external_zod_namespaceObject.z.literal('cookie_banner'),
    preferences: external_zod_namespaceObject.z.record(external_zod_namespaceObject.z.string(), external_zod_namespaceObject.z.boolean())
});
const policyBasedSchema = baseConsentSchema.extend({
    type: external_zod_namespaceObject.z["enum"]([
        'privacy_policy',
        'dpa',
        'terms_and_conditions'
    ]),
    policyId: external_zod_namespaceObject.z.string().optional(),
    preferences: external_zod_namespaceObject.z.record(external_zod_namespaceObject.z.string(), external_zod_namespaceObject.z.boolean()).optional()
});
const otherConsentSchema = baseConsentSchema.extend({
    type: external_zod_namespaceObject.z["enum"]([
        'marketing_communications',
        'age_verification',
        'other'
    ]),
    preferences: external_zod_namespaceObject.z.record(external_zod_namespaceObject.z.string(), external_zod_namespaceObject.z.boolean()).optional()
});
const postConsentContract = contract_namespaceObject.oc.route({
    method: 'POST',
    path: '/consent/set',
    description: `Records a user's consent preferences and creates necessary consent records.
This endpoint handles various types of consent submissions:

1. Cookie Banner Consent:
   - Records granular cookie preferences
   - Supports multiple consent purposes
   - Creates audit trail for compliance

2. Policy-Based Consent:
   - Privacy Policy acceptance
   - Data Processing Agreement (DPA) consent
   - Terms and Conditions acceptance
   - Links consent to specific policy versions

3. Other Consent Types:
   - Marketing communications preferences
   - Age verification consent
   - Custom consent types

The endpoint performs the following operations:
- Creates or retrieves subject records
- Validates domain and policy information
- Creates consent records with audit trails
- Records consent purposes and preferences
- Generates audit logs for compliance

Use this endpoint to record user consent and maintain a compliant consent management system.`,
    tags: [
        'consent',
        'cookie-banner'
    ]
}).errors({
    INPUT_VALIDATION_FAILED: {
        status: 422,
        data: external_zod_namespaceObject.z.object({
            formErrors: external_zod_namespaceObject.z.array(external_zod_namespaceObject.z.string()),
            fieldErrors: external_zod_namespaceObject.z.record(external_zod_namespaceObject.z.string(), external_zod_namespaceObject.z.array(external_zod_namespaceObject.z.string()))
        }),
        error: 'Invalid input parameters'
    },
    SUBJECT_CREATION_FAILED: {
        status: 400,
        data: external_zod_namespaceObject.z.object({
            subjectId: external_zod_namespaceObject.z.string().optional(),
            externalSubjectId: external_zod_namespaceObject.z.string().optional()
        }),
        error: 'Failed to create or find subject'
    },
    DOMAIN_CREATION_FAILED: {
        status: 500,
        data: external_zod_namespaceObject.z.object({
            domain: external_zod_namespaceObject.z.string()
        }),
        error: 'Failed to create or find domain'
    },
    POLICY_NOT_FOUND: {
        status: 404,
        data: external_zod_namespaceObject.z.object({
            policyId: external_zod_namespaceObject.z.string(),
            type: external_zod_namespaceObject.z.string()
        }),
        error: 'Policy not found'
    },
    POLICY_INACTIVE: {
        status: 409,
        data: external_zod_namespaceObject.z.object({
            policyId: external_zod_namespaceObject.z.string(),
            type: external_zod_namespaceObject.z.string()
        }),
        error: 'Policy is not active'
    },
    POLICY_CREATION_FAILED: {
        status: 500,
        data: external_zod_namespaceObject.z.object({
            type: external_zod_namespaceObject.z.string()
        }),
        error: 'Failed to create or find policy'
    },
    PURPOSE_CREATION_FAILED: {
        status: 500,
        data: external_zod_namespaceObject.z.object({
            purposeCode: external_zod_namespaceObject.z.string()
        }),
        error: 'Failed to create consent purpose'
    },
    CONSENT_CREATION_FAILED: {
        status: 500,
        data: external_zod_namespaceObject.z.object({
            subjectId: external_zod_namespaceObject.z.string(),
            domain: external_zod_namespaceObject.z.string()
        }),
        error: 'Failed to create consent record'
    }
}).input(external_zod_namespaceObject.z.discriminatedUnion('type', [
    cookieBannerSchema,
    policyBasedSchema,
    otherConsentSchema
])).output(external_zod_namespaceObject.z.object({
    id: external_zod_namespaceObject.z.string(),
    subjectId: external_zod_namespaceObject.z.string().optional(),
    externalSubjectId: external_zod_namespaceObject.z.string().optional(),
    domainId: external_zod_namespaceObject.z.string(),
    domain: external_zod_namespaceObject.z.string(),
    type: PolicyTypeSchema,
    status: external_zod_namespaceObject.z.string(),
    recordId: external_zod_namespaceObject.z.string(),
    metadata: external_zod_namespaceObject.z.record(external_zod_namespaceObject.z.string(), external_zod_namespaceObject.z.unknown()).optional(),
    givenAt: external_zod_namespaceObject.z.date()
}));
const types_branding = [
    'c15t',
    'consent',
    'none'
];
const JurisdictionMessages = {
    GDPR: 'GDPR or equivalent regulations require a cookie banner.',
    CH: 'Switzerland requires similar data protection measures.',
    BR: "Brazil's LGPD requires consent for cookies.",
    PIPEDA: 'PIPEDA requires consent for data collection.',
    AU: "Australia's Privacy Act mandates transparency about data collection.",
    APPI: "Japan's APPI requires consent for data collection.",
    PIPA: "South Korea's PIPA requires consent for data collection.",
    NONE: 'No specific requirements'
};
const JurisdictionCodeSchema = external_zod_namespaceObject.z["enum"]([
    'GDPR',
    'CH',
    'BR',
    'PIPEDA',
    'AU',
    'APPI',
    'PIPA',
    'NONE'
]);
const JurisdictionInfoSchema = external_zod_namespaceObject.z.object({
    code: JurisdictionCodeSchema,
    message: external_zod_namespaceObject.z.string()
});
const TitleDescriptionSchema = external_zod_namespaceObject.z.object({
    title: external_zod_namespaceObject.z.string(),
    description: external_zod_namespaceObject.z.string()
});
const CompleteTranslationsSchema = external_zod_namespaceObject.z.object({
    common: external_zod_namespaceObject.z.object({
        acceptAll: external_zod_namespaceObject.z.string(),
        rejectAll: external_zod_namespaceObject.z.string(),
        customize: external_zod_namespaceObject.z.string(),
        save: external_zod_namespaceObject.z.string()
    }),
    cookieBanner: TitleDescriptionSchema,
    consentManagerDialog: TitleDescriptionSchema,
    consentTypes: external_zod_namespaceObject.z.object({
        experience: TitleDescriptionSchema,
        functionality: TitleDescriptionSchema,
        marketing: TitleDescriptionSchema,
        measurement: TitleDescriptionSchema,
        necessary: TitleDescriptionSchema
    }),
    frame: external_zod_namespaceObject.z.object({
        title: external_zod_namespaceObject.z.string(),
        actionButton: external_zod_namespaceObject.z.string()
    }),
    legalLinks: external_zod_namespaceObject.z.object({
        privacyPolicy: external_zod_namespaceObject.z.string(),
        termsOfService: external_zod_namespaceObject.z.string(),
        cookiePolicy: external_zod_namespaceObject.z.string()
    })
});
const PartialTranslationsSchema = external_zod_namespaceObject.z.object({
    common: external_zod_namespaceObject.z.object({
        acceptAll: external_zod_namespaceObject.z.string().optional(),
        rejectAll: external_zod_namespaceObject.z.string().optional(),
        customize: external_zod_namespaceObject.z.string().optional(),
        save: external_zod_namespaceObject.z.string().optional()
    }).partial(),
    cookieBanner: TitleDescriptionSchema.partial(),
    consentManagerDialog: TitleDescriptionSchema.partial(),
    consentTypes: external_zod_namespaceObject.z.object({
        experience: TitleDescriptionSchema.partial(),
        functionality: TitleDescriptionSchema.partial(),
        marketing: TitleDescriptionSchema.partial(),
        measurement: TitleDescriptionSchema.partial(),
        necessary: TitleDescriptionSchema.partial()
    }).partial(),
    frame: external_zod_namespaceObject.z.object({
        title: external_zod_namespaceObject.z.string().optional(),
        actionButton: external_zod_namespaceObject.z.string().optional()
    }).partial().optional(),
    legalLinks: external_zod_namespaceObject.z.object({
        privacyPolicy: external_zod_namespaceObject.z.string().optional(),
        termsOfService: external_zod_namespaceObject.z.string().optional(),
        cookiePolicy: external_zod_namespaceObject.z.string().optional()
    }).partial().optional()
});
const TranslationsSchema = external_zod_namespaceObject.z.union([
    CompleteTranslationsSchema,
    PartialTranslationsSchema
]);
const showConsentBannerContract = contract_namespaceObject.oc.route({
    method: 'GET',
    path: '/show-consent-banner',
    description: `Determines if a user should see a consent banner based on their location and applicable privacy regulations.
This endpoint performs the following checks:

1. Detects the user's location using various header information:
   - Cloudflare country headers
   - Vercel IP country headers
   - AWS CloudFront headers
   - Custom country code headers

2. Determines the applicable jurisdiction based on the location:
   - GDPR (EU/EEA/UK)
   - Swiss Data Protection Act
   - LGPD (Brazil)
   - PIPEDA (Canada)
   - Australian Privacy Principles
   - APPI (Japan)
   - PIPA (South Korea)

3. Returns detailed information about:
   - Whether to show the consent banner
   - The applicable jurisdiction and its requirements
   - The user's detected location (country and region)

Use this endpoint to implement geo-targeted consent banners and ensure compliance with regional privacy regulations.`,
    tags: [
        'cookie-banner'
    ]
}).output(external_zod_namespaceObject.z.object({
    showConsentBanner: external_zod_namespaceObject.z.boolean(),
    jurisdiction: JurisdictionInfoSchema,
    location: external_zod_namespaceObject.z.object({
        countryCode: external_zod_namespaceObject.z.string().nullable(),
        regionCode: external_zod_namespaceObject.z.string().nullable()
    }),
    translations: external_zod_namespaceObject.z.object({
        language: external_zod_namespaceObject.z.string(),
        translations: TranslationsSchema
    }),
    branding: external_zod_namespaceObject.z["enum"](types_branding)
}));
const verifyConsentInputSchema = external_zod_namespaceObject.z.strictObject({
    subjectId: external_zod_namespaceObject.z.string().optional(),
    externalSubjectId: external_zod_namespaceObject.z.string().optional(),
    domain: external_zod_namespaceObject.z.string(),
    type: PolicyTypeSchema,
    policyId: external_zod_namespaceObject.z.string().optional(),
    preferences: external_zod_namespaceObject.z.array(external_zod_namespaceObject.z.string()).optional()
});
const verify_contract_consentSchema = external_zod_namespaceObject.z.looseObject({
    id: external_zod_namespaceObject.z.string(),
    purposeIds: external_zod_namespaceObject.z.array(external_zod_namespaceObject.z.string())
});
const verifyConsentContract = contract_namespaceObject.oc.route({
    method: 'POST',
    path: '/consent/verify',
    description: `Verifies if a user has given valid consent for a specific policy and domain.
This endpoint performs comprehensive consent verification by:

1. Validating the subject's identity (using subjectId or externalSubjectId)
2. Verifying the domain's existence and validity
3. Checking if the specified policy exists and is active
4. Validating that all required purposes have been consented to
5. Ensuring the consent record is current and valid

The endpoint supports different types of consent verification:
- Cookie banner consent verification
- Privacy policy consent verification
- Terms and conditions verification
- Marketing communications consent verification
- Age verification
- Custom consent types

Use this endpoint to ensure compliance with privacy regulations and to verify user consent before processing personal data.`,
    tags: [
        'consent'
    ]
}).errors({
    INPUT_VALIDATION_FAILED: {
        status: 422,
        data: external_zod_namespaceObject.z.object({
            formErrors: external_zod_namespaceObject.z.array(external_zod_namespaceObject.z.string()),
            fieldErrors: external_zod_namespaceObject.z.record(external_zod_namespaceObject.z.string(), external_zod_namespaceObject.z.array(external_zod_namespaceObject.z.string()).optional())
        }),
        error: 'Invalid input parameters'
    },
    SUBJECT_NOT_FOUND: {
        status: 404,
        data: external_zod_namespaceObject.z.object({
            subjectId: external_zod_namespaceObject.z.string().optional(),
            externalSubjectId: external_zod_namespaceObject.z.string().optional()
        }),
        error: 'Subject not found'
    },
    DOMAIN_NOT_FOUND: {
        status: 404,
        data: external_zod_namespaceObject.z.object({
            domain: external_zod_namespaceObject.z.string()
        }),
        error: 'Domain not found'
    },
    POLICY_NOT_FOUND: {
        status: 404,
        data: external_zod_namespaceObject.z.object({
            policyId: external_zod_namespaceObject.z.string(),
            type: external_zod_namespaceObject.z.string()
        }),
        error: 'Policy not found or invalid'
    },
    PURPOSES_NOT_FOUND: {
        status: 404,
        data: external_zod_namespaceObject.z.object({
            preferences: external_zod_namespaceObject.z.array(external_zod_namespaceObject.z.string()),
            foundPurposes: external_zod_namespaceObject.z.array(external_zod_namespaceObject.z.string())
        }),
        error: 'Could not find all specified purposes'
    },
    COOKIE_BANNER_PREFERENCES_REQUIRED: {
        status: 400,
        data: external_zod_namespaceObject.z.object({
            type: external_zod_namespaceObject.z.literal('cookie_banner')
        }),
        error: 'Preferences are required for cookie banner consent'
    },
    NO_CONSENT_FOUND: {
        status: 404,
        data: external_zod_namespaceObject.z.object({
            policyId: external_zod_namespaceObject.z.string(),
            subjectId: external_zod_namespaceObject.z.string(),
            domainId: external_zod_namespaceObject.z.string()
        }),
        error: 'No consent found for the given policy'
    }
}).input(verifyConsentInputSchema).output(external_zod_namespaceObject.z.object({
    isValid: external_zod_namespaceObject.z.boolean(),
    reasons: external_zod_namespaceObject.z.array(external_zod_namespaceObject.z.string()).optional(),
    consent: verify_contract_consentSchema.optional()
}));
const consentContracts = {
    post: postConsentContract,
    showBanner: showConsentBannerContract,
    verify: verifyConsentContract,
    identify: identifyUserContract
};
const statusContract = contract_namespaceObject.oc.route({
    method: 'GET',
    path: '/status',
    description: `Returns the current operational status and health metrics of the service.
This endpoint provides real-time information about:
- Overall service status (ok/error)
- Current API version
- Server timestamp
- Storage system status and availability
- Client information (IP, User Agent, Region)

Use this endpoint for health checks, monitoring, and service status verification.`,
    tags: [
        'meta'
    ]
}).output(external_zod_namespaceObject.z.object({
    status: external_zod_namespaceObject.z["enum"]([
        'ok',
        'error'
    ]),
    version: external_zod_namespaceObject.z.string(),
    timestamp: external_zod_namespaceObject.z.date(),
    storage: external_zod_namespaceObject.z.object({
        type: external_zod_namespaceObject.z.string(),
        available: external_zod_namespaceObject.z.boolean()
    }),
    client: external_zod_namespaceObject.z.object({
        ip: external_zod_namespaceObject.z.string().nullable(),
        userAgent: external_zod_namespaceObject.z.string().nullable(),
        region: external_zod_namespaceObject.z.object({
            countryCode: external_zod_namespaceObject.z.string().nullable(),
            regionCode: external_zod_namespaceObject.z.string().nullable()
        })
    })
}));
const metaContracts = {
    status: statusContract
};
const config = {
    consent: consentContracts,
    meta: metaContracts
};
const os = (0, server_namespaceObject.implement)(config);
const identifyUser = os.consent.identify.handler(async ({ input, context })=>{
    const typedContext = context;
    const { adapter, logger } = typedContext;
    logger.info('Handling identify-user request');
    const rawConsent = await adapter.findOne({
        model: 'consent',
        where: [
            {
                field: 'id',
                value: input.consentId
            }
        ]
    });
    const consent = rawConsent ? definition_validateEntityOutput('consent', rawConsent, typedContext.options) : null;
    if (!consent) throw new server_namespaceObject.ORPCError('CONSENT_NOT_FOUND', {
        data: {
            consentId: input.consentId
        }
    });
    await typedContext.adapter.transaction({
        callback: async (tx)=>{
            const existingSubject = await tx.findOne({
                model: 'subject',
                where: [
                    {
                        field: 'externalId',
                        value: input.externalId
                    },
                    {
                        field: 'id',
                        value: consent.subjectId,
                        connector: 'AND',
                        operator: 'ne'
                    }
                ]
            });
            if (existingSubject && 'id' in existingSubject) {
                const currentSubjectId = consent.subjectId;
                const oldSubjectId = existingSubject.id;
                logger.info('Merging subjects', {
                    currentSubjectId,
                    oldSubjectId,
                    externalId: input.externalId
                });
                await tx.updateMany({
                    model: 'consent',
                    where: [
                        {
                            field: 'subjectId',
                            value: currentSubjectId
                        }
                    ],
                    update: {
                        subjectId: oldSubjectId
                    }
                });
                await tx.updateMany({
                    model: 'consentRecord',
                    where: [
                        {
                            field: 'subjectId',
                            value: currentSubjectId
                        }
                    ],
                    update: {
                        subjectId: oldSubjectId
                    }
                });
                await tx.updateMany({
                    model: 'auditLog',
                    where: [
                        {
                            field: 'subjectId',
                            value: currentSubjectId
                        }
                    ],
                    update: {
                        subjectId: oldSubjectId
                    }
                });
                await tx.deleteMany({
                    model: 'subject',
                    where: [
                        {
                            field: 'id',
                            value: currentSubjectId
                        }
                    ]
                });
                await tx.create({
                    model: 'auditLog',
                    data: {
                        subjectId: oldSubjectId,
                        entityType: 'consent',
                        entityId: consent.id,
                        actionType: 'identify_user',
                        ipAddress: typedContext.ipAddress || null,
                        userAgent: typedContext.userAgent || null,
                        eventTimezone: 'UTC',
                        metadata: {
                            externalId: input.externalId,
                            mergedFrom: currentSubjectId
                        }
                    }
                });
            } else {
                await tx.update({
                    model: 'subject',
                    where: [
                        {
                            field: 'id',
                            value: consent.subjectId
                        }
                    ],
                    update: {
                        externalId: input.externalId,
                        identityProvider: input.identityProvider || 'external',
                        isIdentified: true,
                        updatedAt: new Date()
                    }
                });
                await tx.create({
                    model: 'auditLog',
                    data: {
                        subjectId: consent.subjectId,
                        entityType: 'consent',
                        entityId: consent.id,
                        actionType: 'identify_user',
                        ipAddress: typedContext.ipAddress || null,
                        userAgent: typedContext.userAgent || null,
                        eventTimezone: 'UTC',
                        metadata: {
                            externalId: input.externalId,
                            identityProvider: input.identityProvider || 'external'
                        }
                    }
                });
            }
        }
    });
    return {
        success: true
    };
});
const postConsent = os.consent.post.handler(async ({ input, context })=>{
    const typedContext = context;
    const logger = typedContext.logger;
    logger.info('Handling post-consent request');
    const { type, subjectId, externalSubjectId, identityProvider, domain, metadata, preferences } = input;
    logger.debug('Request parameters', {
        type,
        subjectId,
        externalSubjectId,
        identityProvider,
        domain
    });
    try {
        const subject = await typedContext.registry.findOrCreateSubject({
            subjectId,
            externalSubjectId,
            identityProvider,
            ipAddress: typedContext.ipAddress || 'unknown'
        });
        if (!subject) throw new server_namespaceObject.ORPCError('SUBJECT_CREATION_FAILED', {
            data: {
                subjectId,
                externalSubjectId
            }
        });
        logger.debug('Subject found/created', {
            subjectId: subject.id
        });
        const domainRecord = await typedContext.registry.findOrCreateDomain(domain);
        if (!domainRecord) throw new server_namespaceObject.ORPCError('DOMAIN_CREATION_FAILED', {
            data: {
                domain
            }
        });
        const now = new Date();
        let policyId;
        let purposeIds = [];
        if ('policyId' in input && input.policyId) {
            policyId = input.policyId;
            const policy = await typedContext.registry.findConsentPolicyById(policyId);
            if (!policy) throw new server_namespaceObject.ORPCError('POLICY_NOT_FOUND', {
                data: {
                    policyId,
                    type
                }
            });
            if (!policy.isActive) throw new server_namespaceObject.ORPCError('POLICY_INACTIVE', {
                data: {
                    policyId,
                    type
                }
            });
        } else {
            const policy = await typedContext.registry.findOrCreatePolicy(type);
            if (!policy) throw new server_namespaceObject.ORPCError('POLICY_CREATION_FAILED', {
                data: {
                    type
                }
            });
            policyId = policy.id;
        }
        if (preferences) {
            const consentedPurposes = Object.entries(preferences).filter(([_, isConsented])=>isConsented).map(([purposeCode])=>purposeCode);
            const existingPurposes = await Promise.all(consentedPurposes.map((purposeCode)=>typedContext.registry.findConsentPurposeByCode(purposeCode)));
            const purposesToCreate = consentedPurposes.filter((_purposeCode, index)=>!existingPurposes[index]);
            const createdPurposes = await Promise.all(purposesToCreate.map((purposeCode)=>typedContext.registry.createConsentPurpose({
                    code: purposeCode,
                    name: purposeCode,
                    description: `Auto-created consentPurpose for ${purposeCode}`,
                    isActive: true,
                    isEssential: false,
                    legalBasis: 'consent',
                    createdAt: now,
                    updatedAt: now
                })));
            purposeIds = [
                ...existingPurposes.filter((p)=>null !== p).map((p)=>p.id),
                ...createdPurposes.filter((p)=>null !== p).map((p)=>p.id)
            ];
            if (purposeIds.length !== consentedPurposes.length) throw new server_namespaceObject.ORPCError('PURPOSE_CREATION_FAILED', {
                data: {
                    purposeCode: purposesToCreate[purposeIds.length - consentedPurposes.length]
                }
            });
        }
        const result = await typedContext.adapter.transaction({
            callback: async (tx)=>{
                const consentRecord = await tx.create({
                    model: 'consent',
                    data: {
                        subjectId: subject.id,
                        domainId: domainRecord.id,
                        policyId,
                        purposeIds,
                        status: 'active',
                        isActive: true,
                        givenAt: now,
                        ipAddress: typedContext.ipAddress || null,
                        userAgent: typedContext.userAgent || null,
                        history: []
                    }
                });
                const record = await tx.create({
                    model: 'consentRecord',
                    data: {
                        subjectId: subject.id,
                        consentId: consentRecord.id,
                        actionType: 'consent_given',
                        details: metadata,
                        createdAt: now
                    }
                });
                await tx.create({
                    model: 'auditLog',
                    data: {
                        subjectId: subject.id,
                        entityType: 'consent',
                        entityId: consentRecord.id,
                        actionType: 'consent_given',
                        details: {
                            consentId: consentRecord.id,
                            type
                        },
                        timestamp: now,
                        ipAddress: typedContext.ipAddress || null,
                        userAgent: typedContext.userAgent || null
                    }
                });
                return {
                    consent: consentRecord,
                    record
                };
            }
        });
        if (!result || !result.consent || !result.record) throw new server_namespaceObject.ORPCError('CONSENT_CREATION_FAILED', {
            data: {
                subjectId: subject.id,
                domain
            }
        });
        return {
            id: result.consent.id,
            subjectId: subject.id,
            externalSubjectId: subject.externalId ?? void 0,
            identityProvider: subject.identityProvider ?? void 0,
            domainId: domainRecord.id,
            domain: domainRecord.name,
            type,
            status: result.consent.status,
            recordId: result.record.id,
            metadata,
            givenAt: result.consent.givenAt
        };
    } catch (error) {
        logger.error('Error in post-consent handler', {
            error: error instanceof Error ? error.message : String(error),
            errorType: error instanceof Error ? error.constructor.name : typeof error
        });
        if (error instanceof server_namespaceObject.ORPCError) throw error;
        throw new server_namespaceObject.ORPCError('INTERNAL_SERVER_ERROR', {
            message: error instanceof Error ? error.message : String(error)
        });
    }
});
function checkJurisdiction(countryCode) {
    const jurisdictions = {
        EU: new Set([
            'AT',
            'BE',
            'BG',
            'HR',
            'CY',
            'CZ',
            'DK',
            'EE',
            'FI',
            'FR',
            'DE',
            'GR',
            'HU',
            'IE',
            'IT',
            'LV',
            'LT',
            'LU',
            'MT',
            'NL',
            'PL',
            'PT',
            'RO',
            'SK',
            'SI',
            'ES',
            'SE'
        ]),
        EEA: new Set([
            'IS',
            'NO',
            'LI'
        ]),
        UK: new Set([
            'GB'
        ]),
        CH: new Set([
            'CH'
        ]),
        BR: new Set([
            'BR'
        ]),
        CA: new Set([
            'CA'
        ]),
        AU: new Set([
            'AU'
        ]),
        JP: new Set([
            'JP'
        ]),
        KR: new Set([
            'KR'
        ])
    };
    let showConsentBanner = true;
    let jurisdictionCode = 'NONE';
    if (countryCode) {
        const normalizedCountryCode = countryCode.toUpperCase();
        showConsentBanner = false;
        const jurisdictionMap = [
            {
                sets: [
                    jurisdictions.EU,
                    jurisdictions.EEA,
                    jurisdictions.UK
                ],
                code: 'GDPR'
            },
            {
                sets: [
                    jurisdictions.CH
                ],
                code: 'CH'
            },
            {
                sets: [
                    jurisdictions.BR
                ],
                code: 'BR'
            },
            {
                sets: [
                    jurisdictions.CA
                ],
                code: 'PIPEDA'
            },
            {
                sets: [
                    jurisdictions.AU
                ],
                code: 'AU'
            },
            {
                sets: [
                    jurisdictions.JP
                ],
                code: 'APPI'
            },
            {
                sets: [
                    jurisdictions.KR
                ],
                code: 'PIPA'
            }
        ];
        for (const { sets, code } of jurisdictionMap)if (sets.some((set)=>set.has(normalizedCountryCode))) {
            jurisdictionCode = code;
            showConsentBanner = true;
            break;
        }
    }
    const message = JurisdictionMessages[jurisdictionCode];
    return {
        showConsentBanner,
        jurisdictionCode,
        message
    };
}
const translations_namespaceObject = require("@c15t/translations");
function isSupportedBaseLanguage(lang) {
    return lang in translations_namespaceObject.baseTranslations;
}
function getPreferredLanguage(acceptLanguage, supportedLanguages) {
    if (!acceptLanguage) return 'en';
    const primaryLang = acceptLanguage.split(',')[0]?.split(';')[0]?.split('-')[0]?.toLowerCase();
    if (primaryLang && supportedLanguages.includes(primaryLang)) return primaryLang;
    return 'en';
}
function getTranslations(acceptLanguage, customTranslations) {
    const supportedDefaultLanguages = Object.keys(translations_namespaceObject.baseTranslations);
    const supportedCustomLanguages = Object.keys(customTranslations || {});
    const supportedLanguages = [
        ...supportedDefaultLanguages,
        ...supportedCustomLanguages
    ];
    const preferredLanguage = getPreferredLanguage(acceptLanguage, supportedLanguages);
    const base = isSupportedBaseLanguage(preferredLanguage) ? translations_namespaceObject.baseTranslations[preferredLanguage] : translations_namespaceObject.baseTranslations.en;
    const custom = supportedCustomLanguages.includes(preferredLanguage) ? customTranslations?.[preferredLanguage] : {};
    const translations = custom ? (0, translations_namespaceObject.deepMergeTranslations)(base, custom) : base;
    return {
        translations: translations,
        language: preferredLanguage
    };
}
function getHeaders(headers) {
    if (!headers) return {
        countryCode: null,
        regionCode: null,
        acceptLanguage: null
    };
    const normalizeHeader = (value)=>{
        if (!value) return null;
        return Array.isArray(value) ? value[0] ?? null : value;
    };
    const countryCode = normalizeHeader(headers.get('x-c15t-country')) ?? normalizeHeader(headers.get('cf-ipcountry')) ?? normalizeHeader(headers.get('x-vercel-ip-country')) ?? normalizeHeader(headers.get('x-amz-cf-ipcountry')) ?? normalizeHeader(headers.get('x-country-code'));
    const regionCode = normalizeHeader(headers.get('x-c15t-region')) ?? normalizeHeader(headers.get('x-vercel-ip-country-region')) ?? normalizeHeader(headers.get('x-region-code'));
    const acceptLanguage = normalizeHeader(headers.get('accept-language'));
    return {
        countryCode,
        regionCode,
        acceptLanguage
    };
}
function buildResponse({ shouldShowBanner, jurisdiction, location, acceptLanguage, customTranslations, branding = 'c15t' }) {
    return {
        showConsentBanner: shouldShowBanner,
        jurisdiction,
        location,
        translations: getTranslations(acceptLanguage, customTranslations),
        branding
    };
}
const handler_showConsentBanner = os.consent.showBanner.handler(({ context })=>{
    const typedContext = context;
    const { customTranslations, disableGeoLocation, branding } = typedContext.options.advanced ?? {};
    const { countryCode, regionCode, acceptLanguage } = getHeaders(typedContext.headers);
    if (disableGeoLocation) return buildResponse({
        shouldShowBanner: true,
        jurisdiction: {
            code: 'NONE',
            message: JurisdictionMessages.NONE
        },
        location: {
            countryCode: null,
            regionCode: null
        },
        acceptLanguage,
        customTranslations,
        branding
    });
    const { showConsentBanner, jurisdictionCode, message } = checkJurisdiction(countryCode);
    return buildResponse({
        shouldShowBanner: showConsentBanner,
        jurisdiction: {
            code: jurisdictionCode,
            message
        },
        location: {
            countryCode,
            regionCode
        },
        acceptLanguage,
        customTranslations,
        branding
    });
});
const verifyConsent = os.consent.verify.handler(async ({ input, context })=>{
    const typedContext = context;
    const logger = typedContext.logger;
    logger.info('Handling verify-consent request');
    const { type, subjectId, externalSubjectId, domain, policyId, preferences } = input;
    logger.debug('Request parameters', {
        type,
        subjectId,
        externalSubjectId,
        domain,
        policyId,
        preferences
    });
    try {
        const subject = await typedContext.registry.findOrCreateSubject({
            subjectId,
            externalSubjectId,
            ipAddress: typedContext.ipAddress || 'unknown'
        });
        if (!subject) throw new server_namespaceObject.ORPCError('SUBJECT_NOT_FOUND', {
            data: {
                subjectId,
                externalSubjectId
            }
        });
        const domainRecord = await typedContext.registry.findDomain(domain);
        if (!domainRecord) throw new server_namespaceObject.ORPCError('DOMAIN_NOT_FOUND', {
            data: {
                domain
            }
        });
        if ('cookie_banner' === type && (!preferences || 0 === preferences.length)) throw new server_namespaceObject.ORPCError('COOKIE_BANNER_PREFERENCES_REQUIRED', {
            data: {
                type: 'cookie_banner'
            }
        });
        const purposePromises = preferences?.map((purpose)=>typedContext.registry.findConsentPurposeByCode(purpose));
        const rawPurposes = await Promise.all(purposePromises ?? []);
        const purposeIds = rawPurposes.filter((purpose)=>null !== purpose).map((purpose)=>purpose.id);
        if (purposeIds.length !== (preferences?.length ?? 0)) throw new server_namespaceObject.ORPCError('PURPOSES_NOT_FOUND', {
            data: {
                preferences: preferences ?? [],
                foundPurposes: rawPurposes.filter((p)=>null !== p).map((p)=>p.code)
            }
        });
        if (policyId) {
            const policy = await typedContext.registry.findConsentPolicyById(policyId);
            if (!policy || policy.type !== type) throw new server_namespaceObject.ORPCError('POLICY_NOT_FOUND', {
                data: {
                    policyId,
                    type
                }
            });
            return await checkPolicyConsent({
                policyId: policy.id,
                subjectId: subject.id,
                domainId: domainRecord.id,
                purposeIds,
                type,
                context: typedContext
            });
        }
        const latestPolicy = await typedContext.registry.findOrCreatePolicy(type);
        if (!latestPolicy) throw new server_namespaceObject.ORPCError('POLICY_NOT_FOUND', {
            data: {
                policyId: 'latest',
                type
            }
        });
        return await checkPolicyConsent({
            policyId: latestPolicy.id,
            subjectId: subject.id,
            domainId: domainRecord.id,
            purposeIds,
            type,
            context: typedContext
        });
    } catch (error) {
        logger.error('Error in verify-consent handler', {
            error: error instanceof Error ? error.message : String(error),
            errorType: error instanceof Error ? error.constructor.name : typeof error
        });
        if (error instanceof server_namespaceObject.ORPCError) throw error;
        throw new server_namespaceObject.ORPCError('INTERNAL_SERVER_ERROR', {
            message: error instanceof Error ? error.message : String(error)
        });
    }
});
async function checkPolicyConsent({ policyId, subjectId, domainId, purposeIds, type, context }) {
    const { registry, adapter } = context;
    const rawConsents = await adapter.findMany({
        model: 'consent',
        where: [
            {
                field: 'subjectId',
                value: subjectId
            },
            {
                field: 'policyId',
                value: policyId
            },
            {
                field: 'domainId',
                value: domainId
            }
        ],
        sortBy: {
            field: 'givenAt',
            direction: 'desc'
        }
    });
    const filteredConsents = rawConsents.filter((consent)=>{
        if (!purposeIds) return true;
        return purposeIds.every((id)=>consent.purposeIds.some((purposeId)=>purposeId === id));
    });
    await registry.createAuditLog({
        subjectId,
        entityType: 'consent_policy',
        entityId: policyId,
        actionType: 'verify_consent',
        metadata: {
            type,
            policyId,
            purposeIds,
            success: 0 !== filteredConsents.length,
            ...filteredConsents.length > 0 ? {
                consentId: filteredConsents[0]?.id
            } : {}
        }
    });
    if (0 === rawConsents.length) throw new server_namespaceObject.ORPCError('NO_CONSENT_FOUND', {
        data: {
            policyId,
            subjectId,
            domainId
        }
    });
    if (0 === filteredConsents.length) throw new server_namespaceObject.ORPCError('NO_CONSENT_FOUND', {
        data: {
            policyId,
            subjectId,
            domainId
        }
    });
    return {
        isValid: true,
        consent: filteredConsents[0]
    };
}
const consentHandlers = {
    post: postConsent,
    showBanner: handler_showConsentBanner,
    verify: verifyConsent,
    identify: identifyUser
};
const statusHandler = os.meta.status.handler(({ context })=>{
    const typedContext = context;
    const headers = typedContext.headers;
    const normalizeHeader = (value)=>{
        if (!value) return null;
        return Array.isArray(value) ? value[0] ?? null : value;
    };
    const countryCode = normalizeHeader(headers?.get('cf-ipcountry')) ?? normalizeHeader(headers?.get('x-vercel-ip-country')) ?? normalizeHeader(headers?.get('x-amz-cf-ipcountry')) ?? normalizeHeader(headers?.get('x-country-code'));
    const regionCode = normalizeHeader(headers?.get('x-vercel-ip-country-region')) ?? normalizeHeader(headers?.get('x-region-code'));
    return {
        status: 'ok',
        version: "1.8.0",
        timestamp: new Date(),
        storage: {
            type: typedContext.adapter?.id ?? 'MemoryAdapter',
            available: !!typedContext.adapter
        },
        client: {
            ip: typedContext.ipAddress ?? null,
            userAgent: typedContext.userAgent ?? null,
            region: {
                countryCode,
                regionCode
            }
        }
    };
});
const metaHandlers = {
    status: statusHandler
};
const router = os.router({
    consent: consentHandlers,
    meta: metaHandlers
});
exports.router = __webpack_exports__.router;
for(var __webpack_i__ in __webpack_exports__)if (-1 === [
    "router"
].indexOf(__webpack_i__)) exports[__webpack_i__] = __webpack_exports__[__webpack_i__];
Object.defineProperty(exports, '__esModule', {
    value: true
});
