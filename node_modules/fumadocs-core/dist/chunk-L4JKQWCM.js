// src/page-tree/utils.ts
function flattenTree(nodes) {
  const out = [];
  for (const node of nodes) {
    if (node.type === "folder") {
      if (node.index) out.push(node.index);
      out.push(...flattenTree(node.children));
    } else if (node.type === "page") {
      out.push(node);
    }
  }
  return out;
}
function findNeighbour(tree, url, options) {
  const { separateRoot = true } = options ?? {};
  const roots = separateRoot ? getPageTreeRoots(tree) : [tree];
  if (tree.fallback) roots.push(tree.fallback);
  for (const root of roots) {
    const list = flattenTree(root.children);
    const idx = list.findIndex((item) => item.url === url);
    if (idx === -1) continue;
    return {
      previous: list[idx - 1],
      next: list[idx + 1]
    };
  }
  return {};
}
function getPageTreeRoots(pageTree) {
  const result = pageTree.children.flatMap((child) => {
    if (child.type !== "folder") return [];
    const roots = getPageTreeRoots(child);
    if (child.root) roots.push(child);
    return roots;
  });
  if (!("type" in pageTree)) result.push(pageTree);
  return result;
}
function getPageTreePeers(treeOrTrees, url) {
  if ("children" in treeOrTrees) {
    const tree = treeOrTrees;
    const parent = findParentFromTree(tree, url);
    if (!parent) return [];
    return parent.children.filter(
      (item) => item.type === "page" && item.url !== url
    );
  }
  for (const lang in treeOrTrees) {
    const result = getPageTreePeers(treeOrTrees[lang], url);
    if (result) return result;
  }
  return [];
}
function findParentFromTree(from, url) {
  let result;
  visit(from, (node, parent) => {
    if ("type" in node && node.type === "page" && node.url === url) {
      result = parent;
      return "break";
    }
  });
  return result;
}
function findPath(nodes, matcher, options = {}) {
  const { includeSeparator = true } = options;
  function run(nodes2) {
    let separator;
    for (const node of nodes2) {
      if (matcher(node)) {
        const items = [];
        if (separator) items.push(separator);
        items.push(node);
        return items;
      }
      if (node.type === "separator" && includeSeparator) {
        separator = node;
        continue;
      }
      if (node.type === "folder") {
        const items = node.index && matcher(node.index) ? [node.index] : run(node.children);
        if (items) {
          items.unshift(node);
          if (separator) items.unshift(separator);
          return items;
        }
      }
    }
  }
  return run(nodes) ?? null;
}
var VisitBreak = /* @__PURE__ */ Symbol("VisitBreak");
function visit(root, visitor) {
  function onNode(node, parent) {
    const result = visitor(node, parent);
    switch (result) {
      case "skip":
        return node;
      case "break":
        throw VisitBreak;
      default:
        if (result) node = result;
    }
    if ("index" in node && node.index) {
      node.index = onNode(node.index, node);
    }
    if ("fallback" in node && node.fallback) {
      node.fallback = onNode(node.fallback, node);
    }
    if ("children" in node) {
      for (let i = 0; i < node.children.length; i++) {
        node.children[i] = onNode(node.children[i], node);
      }
    }
    return node;
  }
  try {
    return onNode(root);
  } catch (e) {
    if (e === VisitBreak) return root;
    throw e;
  }
}

export {
  flattenTree,
  findNeighbour,
  getPageTreeRoots,
  getPageTreePeers,
  findPath,
  visit
};
