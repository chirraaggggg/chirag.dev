import { R as Root, I as Item, F as Folder, S as Separator } from './definitions-pJ7PybYY.js';
import { I18nConfig } from './i18n/index.js';
import { ReactNode } from 'react';

interface Source<Config extends SourceConfig = SourceConfig> {
    files: VirtualFile<Config>[];
}
interface SourceConfig {
    pageData: PageData;
    metaData: MetaData;
}
interface MetaData {
    icon?: string | undefined;
    title?: string | undefined;
    root?: boolean | undefined;
    pages?: string[] | undefined;
    defaultOpen?: boolean | undefined;
    collapsible?: boolean | undefined;
    description?: string | undefined;
}
interface PageData {
    icon?: string | undefined;
    title?: string;
    description?: string | undefined;
}
type VirtualFile<Config extends SourceConfig = SourceConfig> = VirtualPage<Config['pageData']> | VirtualMeta<Config['metaData']>;
interface BaseVirtualFile {
    /**
     * Virtualized path (relative to content directory)
     *
     * @example `docs/page.mdx`
     */
    path: string;
    /**
     * Absolute path of the file
     */
    absolutePath?: string;
}
interface VirtualPage<Data extends PageData> extends BaseVirtualFile {
    type: 'page';
    /**
     * Specified Slugs for page
     */
    slugs?: string[];
    data: Data;
}
interface VirtualMeta<Data extends MetaData> extends BaseVirtualFile {
    type: 'meta';
    data: Data;
}
type _ConfigUnion_<T extends Record<string, Source>> = {
    [K in keyof T]: T[K] extends Source<infer Config> ? {
        pageData: Config['pageData'] & {
            type: K;
        };
        metaData: Config['metaData'] & {
            type: K;
        };
    } : never;
}[keyof T];
declare function multiple<T extends Record<string, Source>>(sources: T): Source<_ConfigUnion_<T>>;
declare function source<Page extends PageData, Meta extends MetaData>(config: {
    pages: VirtualPage<Page>[];
    metas: VirtualMeta<Meta>[];
}): Source<{
    pageData: Page;
    metaData: Meta;
}>;
/**
 * update a source object in-place.
 */
declare function update<Config extends SourceConfig>(source: Source<Config>): {
    files<Page extends PageData, Meta extends MetaData>(fn: (files: VirtualFile<Config>[]) => (VirtualPage<Page> | VirtualMeta<Meta>)[]): typeof update<{
        pageData: Page;
        metaData: Meta;
    }>;
    page<V extends PageData>(fn: (page: VirtualPage<Config["pageData"]>) => VirtualPage<V>): typeof update<{
        pageData: V;
        metaData: Config["metaData"];
    }>;
    meta<V extends MetaData>(fn: (meta: VirtualMeta<Config["metaData"]>) => VirtualMeta<V>): typeof update<{
        pageData: Config["pageData"];
        metaData: V;
    }>;
    build(): Source<Config>;
};

/**
 * In memory file system.
 */
declare class FileSystem<File> {
    files: Map<string, File>;
    folders: Map<string, string[]>;
    constructor(inherit?: FileSystem<File>);
    read(path: string): File | undefined;
    /**
     * get the direct children of folder (in virtual file path)
     */
    readDir(path: string): string[] | undefined;
    write(path: string, file: File): void;
    /**
     * Delete files at specified path.
     *
     * @param path - the target path.
     * @param [recursive=false] - if set to `true`, it will also delete directories.
     */
    delete(path: string, recursive?: boolean): boolean;
    getFiles(): string[];
    makeDir(path: string): void;
}

type ContentStorage<Config extends SourceConfig = SourceConfig> = FileSystem<ContentStorageFile<Config>>;
type ContentStorageFile<Config extends SourceConfig = SourceConfig> = {
    path: string;
    absolutePath?: string;
    format: 'meta';
    data: Config['metaData'];
} | {
    path: string;
    absolutePath?: string;
    format: 'page';
    slugs: string[];
    data: Config['pageData'];
};
/**
 * @param defaultLanguage - language to use when i18n is not configured.
 * @returns a map of locale and its content storage.
 *
 * in the storage, locale codes are removed from file paths, hence the same file will have same file paths in every storage.
 */
declare function buildContentStorage(loaderConfig: ResolvedLoaderConfig, defaultLanguage: string): Record<string, ContentStorage>;

interface PageTreeBuilderContext<Config extends SourceConfig = SourceConfig> {
    rootId: string;
    generateNodeId: () => string;
    options: PageTreeOptions;
    transformers: PageTreeTransformer<Config>[];
    builder: PageTreeBuilder;
    storage: ContentStorage<Config>;
    getUrl: ResolvedLoaderConfig['url'];
    storages?: Record<string, ContentStorage<Config>>;
    locale?: string;
}
interface PageTreeTransformer<Config extends SourceConfig = SourceConfig> {
    file?: (this: PageTreeBuilderContext<Config>, node: Item, filePath?: string) => Item;
    folder?: (this: PageTreeBuilderContext<Config>, node: Folder, folderPath: string, metaPath?: string) => Folder;
    separator?: (this: PageTreeBuilderContext<Config>, node: Separator) => Separator;
    root?: (this: PageTreeBuilderContext<Config>, node: Root) => Root;
}
interface PageTreeOptions<Config extends LoaderConfig = LoaderConfig> {
    id?: string;
    /**
     * Remove references to the file path of original nodes (`$ref`)
     *
     * @defaultValue false
     */
    noRef?: boolean;
    /**
     * generate fallback page tree
     *
     * @defaultValue true
     */
    generateFallback?: boolean;
    /**
     * Additional page tree transformers to apply
     */
    transformers?: PageTreeTransformer<Config['source']>[];
}
interface PageTreeBuilder {
    build: (storage: ContentStorage, options?: PageTreeOptions) => Root;
    buildI18n: (storages: Record<string, ContentStorage>, options?: PageTreeOptions) => Record<string, Root>;
}
declare function createPageTreeBuilder(loaderConfig: ResolvedLoaderConfig): PageTreeBuilder;

interface LoaderPlugin<Config extends LoaderConfig = LoaderConfig> {
    name?: string;
    /**
     * Change the order of plugin:
     * - `pre`: before normal plugins
     * - `post`: after normal plugins
     */
    enforce?: 'pre' | 'post';
    /**
     * receive & replace loader options
     */
    config?: (config: ResolvedLoaderConfig) => ResolvedLoaderConfig | void | undefined;
    /**
     * transform the storage after loading
     */
    transformStorage?: (context: {
        storage: ContentStorage<Config['source']>;
    }) => void;
    /**
     * transform the generated page tree
     */
    transformPageTree?: PageTreeTransformer<Config['source']>;
}
type LoaderPluginOption<Config extends LoaderConfig = LoaderConfig> = LoaderPlugin<Config> | LoaderPluginOption<Config>[] | undefined;
declare function buildPlugins(plugins: LoaderPluginOption[], sort?: boolean): LoaderPlugin[];

type IconResolver = (icon: string | undefined) => ReactNode;

interface LoaderConfig {
    source: SourceConfig;
    i18n: I18nConfig | undefined;
}
interface LoaderOptions<C extends LoaderConfig = LoaderConfig> {
    baseUrl: string;
    i18n?: C['i18n'];
    url?: (slugs: string[], locale?: string) => string;
    /**
     * Additional options for page tree builder
     */
    pageTree?: PageTreeOptions<C>;
    plugins?: LoaderPluginOption[] | ((context: {
        typedPlugin: (plugin: LoaderPlugin<C>) => LoaderPlugin;
    }) => LoaderPluginOption[]);
    icon?: IconResolver;
    slugs?: (info: {
        path: string;
    }) => string[];
}
interface ResolvedLoaderConfig {
    source: Source;
    url: (slugs: string[], locale?: string) => string;
    plugins?: LoaderPlugin[];
    pageTree?: PageTreeOptions;
    i18n?: I18nConfig | undefined;
}
interface SharedFileInfo {
    /**
     * Virtualized file path (relative to content directory)
     *
     * @example `docs/page.mdx`
     */
    path: string;
    /**
     * Absolute path of the file
     */
    absolutePath?: string;
}
interface Page<Data = PageData> extends SharedFileInfo {
    slugs: string[];
    url: string;
    data: Data;
    locale?: string | undefined;
}
interface Meta<Data = MetaData> extends SharedFileInfo {
    data: Data;
}
interface LoaderOutput<Config extends LoaderConfig> {
    pageTree: Config['i18n'] extends I18nConfig ? Record<string, Root> : Root;
    getPageTree: (locale?: string) => Root;
    /**
     * get referenced page from href, supported:
     *
     * - relative file paths, like `./my/page.mdx`.
     * - generated page pathname, like `/docs/my/page`.
     */
    getPageByHref: (href: string, options?: {
        language?: string;
        /**
         * resolve relative file paths in `href` from specified dirname, must be a virtual path.
         */
        dir?: string;
    }) => {
        page: Page<Config['source']['pageData']>;
        hash?: string;
    } | undefined;
    /**
     * resolve special hrefs in a page, including:
     *
     * - relative file paths, like `./my/page.mdx`.
     */
    resolveHref: (href: string, parent: Page<Config['source']['pageData']>) => string;
    /**
     * @internal
     */
    _i18n?: I18nConfig;
    /**
     * Get a list of pages from specified language
     *
     * @param language - If empty, list pages from all languages.
     */
    getPages: (language?: string) => Page<Config['source']['pageData']>[];
    /**
     * get each language and its pages, empty if i18n is not enabled.
     */
    getLanguages: () => {
        language: string;
        pages: Page<Config['source']['pageData']>[];
    }[];
    /**
     * Get page with slugs, the slugs can also be URI encoded.
     *
     * @param language - If empty, the default language will be used
     */
    getPage: (slugs: string[] | undefined, language?: string) => Page<Config['source']['pageData']> | undefined;
    getNodePage: (node: Item, language?: string) => Page<Config['source']['pageData']> | undefined;
    getNodeMeta: (node: Folder, language?: string) => Meta<Config['source']['metaData']> | undefined;
    /**
     * generate static params for Next.js SSG
     *
     * @param slug - customise parameter name for slugs
     * @param lang - customise parameter name for lang
     */
    generateParams: <TSlug extends string = 'slug', TLang extends string = 'lang'>(slug?: TSlug, lang?: TLang) => (Record<TSlug, string[]> & Record<TLang, string>)[];
    /**
     * serialize page tree for non-RSC environments
     */
    serializePageTree: (tree: Root) => Promise<object>;
}
declare function createGetUrl(baseUrl: string, i18n?: I18nConfig): ResolvedLoaderConfig['url'];
declare function loader<Config extends SourceConfig, I18n extends I18nConfig | undefined = undefined>(source: Source<Config>, options: LoaderOptions<{
    source: NoInfer<Config>;
    i18n: I18n;
}>): LoaderOutput<{
    source: Config;
    i18n: I18n;
}>;
declare function loader<Config extends SourceConfig, I18n extends I18nConfig | undefined = undefined>(options: LoaderOptions<{
    source: NoInfer<Config>;
    i18n: I18n;
}> & {
    source: Source<Config>;
}): LoaderOutput<{
    source: Config;
    i18n: I18n;
}>;
type InferPageType<Utils extends LoaderOutput<any>> = Utils extends LoaderOutput<infer Config> ? Page<Config['source']['pageData']> : never;
type InferMetaType<Utils extends LoaderOutput<any>> = Utils extends LoaderOutput<infer Config> ? Meta<Config['source']['metaData']> : never;

export { type ContentStorage as C, FileSystem as F, type InferPageType as I, type LoaderPlugin as L, type MetaData as M, type PageData as P, type ResolvedLoaderConfig as R, type Source as S, type VirtualFile as V, type _ConfigUnion_ as _, type SourceConfig as a, type LoaderConfig as b, type LoaderOptions as c, type Page as d, type Meta as e, type LoaderOutput as f, createGetUrl as g, type InferMetaType as h, type PageTreeBuilderContext as i, type PageTreeTransformer as j, type PageTreeOptions as k, loader as l, multiple as m, type PageTreeBuilder as n, createPageTreeBuilder as o, type ContentStorageFile as p, buildContentStorage as q, type LoaderPluginOption as r, source as s, buildPlugins as t, update as u };
