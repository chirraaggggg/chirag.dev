import {
  dbToSchemaType,
  deserialize,
  schemaToDBType,
  serialize
} from "./chunk-46SBL45L.js";
import {
  createMigrator,
  exportNameVariants,
  generateMigrationFromSchema,
  isUpdated
} from "./chunk-CAEEQPOK.js";
import {
  createSoftForeignKey
} from "./chunk-ZOCGSAWS.js";
import {
  applyNameVariants
} from "./chunk-IVWNQO5P.js";
import {
  toORM
} from "./chunk-PK2W2SQ7.js";
import {
  Column,
  IdColumn,
  column,
  compileForeignKey,
  idColumn,
  schema,
  table
} from "./chunk-N6RQRWGA.js";

// src/adapters/kysely/query.ts
import {
  sql
} from "kysely";
function fullSQLName(column2) {
  return `${column2.table.names.sql}.${column2.names.sql}`;
}
function buildWhere(condition, eb, provider) {
  if (condition.type === 2 /* Compare */) {
    const left = condition.a;
    const op = condition.operator;
    let val = condition.b;
    if (!(val instanceof Column)) {
      val = serialize(val, left, provider);
    }
    let v;
    let rhs;
    switch (op) {
      case "contains":
        v = "like";
      case "not contains":
        v ??= "not like";
        rhs = val instanceof Column ? sql`concat('%', ${eb.ref(fullSQLName(val))}, '%')` : `%${val}%`;
        break;
      case "starts with":
        v = "like";
      case "not starts with":
        v ??= "not like";
        rhs = val instanceof Column ? sql`concat(${eb.ref(fullSQLName(val))}, '%')` : `${val}%`;
        break;
      case "ends with":
        v = "like";
      case "not ends with":
        v ??= "not like";
        rhs = val instanceof Column ? sql`concat('%', ${eb.ref(fullSQLName(val))})` : `%${val}`;
        break;
      default:
        v = op;
        rhs = val instanceof Column ? eb.ref(fullSQLName(val)) : val;
    }
    return eb(fullSQLName(left), v, rhs);
  }
  if (condition.type === 0 /* And */) {
    return eb.and(condition.items.map((v) => buildWhere(v, eb, provider)));
  }
  if (condition.type === 3 /* Not */) {
    return eb.not(buildWhere(condition.item, eb, provider));
  }
  return eb.or(condition.items.map((v) => buildWhere(v, eb, provider)));
}
function mapSelect(select, table2, options = {}) {
  const { relation, tableName = table2.names.sql } = options;
  const out = [];
  const keys = Array.isArray(select) ? select : Object.keys(table2.columns);
  for (const key of keys) {
    const name = relation ? `${relation}:${key}` : key;
    out.push(`${tableName}.${table2.columns[key].names.sql} as ${name}`);
  }
  return out;
}
function extendSelect(original) {
  const select = Array.isArray(original) ? new Set(original) : true;
  const extendedKeys = [];
  return {
    extend(key) {
      if (select === true || select.has(key)) return;
      select.add(key);
      extendedKeys.push(key);
    },
    compile() {
      return {
        result: select instanceof Set ? Array.from(select) : true,
        extendedKeys,
        removeExtendedKeys(record) {
          for (const key of extendedKeys) {
            delete record[key];
          }
          return record;
        }
      };
    }
  };
}
function fromKysely(schema2, config) {
  const {
    db: kysely,
    provider,
    relationMode = provider === "mssql" ? "fumadb" : "foreign-keys"
  } = config;
  function encodeValues(values, table2, generateDefault) {
    const result = {};
    for (const k in table2.columns) {
      const col = table2.columns[k];
      let value = values[k];
      if (generateDefault && value === void 0) {
        value = col.generateDefaultValue();
      }
      if (value !== void 0)
        result[col.names.sql] = serialize(value, col, provider);
    }
    return result;
  }
  function decodeResult(result, table2) {
    const output = {};
    for (const k in result) {
      const segs = k.split(":", 2);
      const value = result[k];
      if (segs.length === 1) {
        output[k] = deserialize(value, table2.columns[k], provider);
      }
      if (segs.length === 2) {
        const [relationName, colName] = segs;
        const relation = table2.relations[relationName];
        if (relation === void 0) continue;
        const col = relation.table.columns[colName];
        if (col === void 0) continue;
        output[relationName] ??= {};
        const obj = output[relationName];
        obj[colName] = deserialize(value, col, provider);
      }
    }
    return output;
  }
  async function runSubQueryJoin(records, join) {
    const { relation, options: joinOptions } = join;
    if (joinOptions === false) return;
    const selectBuilder = extendSelect(joinOptions.select);
    const root = {
      type: 1 /* Or */,
      items: []
    };
    for (const record of records) {
      const condition = {
        type: 0 /* And */,
        items: []
      };
      for (const [left, right] of relation.on) {
        selectBuilder.extend(right);
        condition.items.push({
          type: 2 /* Compare */,
          a: relation.table.columns[right],
          operator: "=",
          b: record[left]
        });
      }
      root.items.push(condition);
    }
    const compiledSelect = selectBuilder.compile();
    const subRecords = await findMany(relation.table, {
      ...joinOptions,
      select: compiledSelect.result,
      where: joinOptions.where ? {
        type: 0 /* And */,
        items: [root, joinOptions.where]
      } : root
    });
    for (const record of records) {
      const filtered = subRecords.filter((subRecord) => {
        for (const [left, right] of relation.on) {
          if (record[left] !== subRecord[right]) return false;
        }
        compiledSelect.removeExtendedKeys(subRecord);
        return true;
      });
      record[relation.name] = relation.type === "one" ? filtered[0] ?? null : filtered;
    }
  }
  async function findMany(table2, v) {
    let query = kysely.selectFrom(table2.names.sql);
    const where = v.where;
    if (where) {
      query = query.where((eb) => buildWhere(where, eb, provider));
    }
    if (v.offset !== void 0) {
      query = query.offset(v.offset);
    }
    if (v.limit !== void 0) {
      query = provider === "mssql" ? query.top(v.limit) : query.limit(v.limit);
    }
    if (v.orderBy) {
      for (const [col, mode] of v.orderBy) {
        query = query.orderBy(fullSQLName(col), mode);
      }
    }
    const selectBuilder = extendSelect(v.select);
    const mappedSelect = [];
    const subqueryJoins = [];
    for (const join of v.join ?? []) {
      const { options: joinOptions, relation } = join;
      if (joinOptions === false) continue;
      if (relation.type === "many" || joinOptions.join) {
        subqueryJoins.push(join);
        for (const [left] of relation.on) {
          selectBuilder.extend(left);
        }
        continue;
      }
      const targetTable = relation.table;
      const joinName = relation.name;
      mappedSelect.push(
        ...mapSelect(joinOptions.select, targetTable, {
          relation: relation.name,
          tableName: joinName
        })
      );
      query = query.leftJoin(
        `${targetTable.names.sql} as ${joinName}`,
        (b) => b.on((eb) => {
          const conditions = [];
          for (const [left, right] of relation.on) {
            conditions.push(
              eb(
                `${table2.names.sql}.${table2.columns[left].names.sql}`,
                "=",
                eb.ref(`${joinName}.${targetTable.columns[right].names.sql}`)
              )
            );
          }
          if (joinOptions.where) {
            conditions.push(buildWhere(joinOptions.where, eb, provider));
          }
          return eb.and(conditions);
        })
      );
    }
    const compiledSelect = selectBuilder.compile();
    mappedSelect.push(...mapSelect(compiledSelect.result, table2));
    const records = (await query.select(mappedSelect).execute()).map(
      (v2) => decodeResult(v2, table2)
    );
    await Promise.all(
      subqueryJoins.map((join) => runSubQueryJoin(records, join))
    );
    for (const record of records) {
      compiledSelect.removeExtendedKeys(record);
    }
    return records;
  }
  let adapter = {
    tables: schema2.tables,
    async count(table2, { where }) {
      let query = await kysely.selectFrom(table2.names.sql).select(kysely.fn.countAll().as("count"));
      if (where) query = query.where((b) => buildWhere(where, b, provider));
      const result = await query.executeTakeFirstOrThrow();
      const count = Number(result.count);
      if (Number.isNaN(count))
        throw new Error(`Unexpected result for count, received: ${count}`);
      return count;
    },
    async create(table2, values) {
      const rawTable = table2;
      const insertValues = encodeValues(values, rawTable, true);
      const insert = kysely.insertInto(rawTable.names.sql).values(insertValues);
      if (provider === "mssql") {
        return decodeResult(
          await insert.output(
            mapSelect(true, rawTable, { tableName: "inserted" })
          ).executeTakeFirstOrThrow(),
          rawTable
        );
      }
      if (provider === "postgresql" || provider === "sqlite") {
        return decodeResult(
          await insert.returning(mapSelect(true, rawTable)).executeTakeFirstOrThrow(),
          rawTable
        );
      }
      const idColumn2 = rawTable.getIdColumn();
      const idValue = insertValues[idColumn2.names.sql];
      if (idValue == null)
        throw new Error(
          "cannot find value of id column, which is required for `create()`."
        );
      await insert.execute();
      return decodeResult(
        await kysely.selectFrom(rawTable.names.sql).select(mapSelect(true, rawTable)).where(idColumn2.names.sql, "=", idValue).limit(1).executeTakeFirstOrThrow(),
        rawTable
      );
    },
    async findFirst(table2, v) {
      const records = await this.findMany(table2, {
        ...v,
        limit: 1
      });
      if (records.length === 0) return null;
      return records[0];
    },
    async findMany(table2, v) {
      return findMany(table2, v);
    },
    async updateMany(table2, v) {
      let query = kysely.updateTable(table2.names.sql).set(encodeValues(v.set, table2, false));
      if (v.where) {
        query = query.where((eb) => buildWhere(v.where, eb, provider));
      }
      await query.execute();
    },
    async upsert(table2, { where, update, create }) {
      if (provider === "mssql") {
        let query2 = kysely.updateTable(table2.names.sql).top(1).set(encodeValues(update, table2, false));
        if (where) query2 = query2.where((b) => buildWhere(where, b, provider));
        const result2 = await query2.executeTakeFirstOrThrow();
        if (result2.numUpdatedRows === 0n)
          await this.createMany(table2, [create]);
        return;
      }
      const idColumn2 = table2.getIdColumn();
      let query = kysely.selectFrom(table2.names.sql).select([`${idColumn2.names.sql} as id`]);
      if (where) query = query.where((b) => buildWhere(where, b, provider));
      const result = await query.limit(1).executeTakeFirst();
      if (result) {
        await kysely.updateTable(table2.names.sql).set(encodeValues(update, table2, false)).where(idColumn2.names.sql, "=", result.id).execute();
      } else {
        await this.createMany(table2, [create]);
      }
    },
    async createMany(table2, values) {
      const encodedValues = values.map((v) => encodeValues(v, table2, true));
      await kysely.insertInto(table2.names.sql).values(encodedValues).execute();
      return encodedValues.map((value) => ({
        _id: value[table2.getIdColumn().names.sql]
      }));
    },
    async deleteMany(table2, { where }) {
      let query = kysely.deleteFrom(table2.names.sql);
      if (where) {
        query = query.where((eb) => buildWhere(where, eb, provider));
      }
      await query.execute();
    },
    transaction(run) {
      return kysely.transaction().execute((ctx) => {
        const tx = fromKysely(schema2, {
          ...config,
          db: ctx
        });
        return run(tx);
      });
    }
  };
  if (relationMode === "fumadb")
    adapter = createSoftForeignKey(schema2, {
      ...adapter,
      generateInsertValuesDefault(table2, values) {
        const result = {};
        for (const k in table2.columns) {
          const col = table2.columns[k];
          if (values[k] === void 0) {
            result[k] = col.generateDefaultValue();
          } else {
            result[k] = values[k];
          }
        }
        return result;
      }
    });
  return toORM(adapter);
}

// src/adapters/kysely/index.ts
import { sql as sql5 } from "kysely";

// src/adapters/kysely/migration/introspect.ts
import {
  sql as sql3
} from "kysely";

// src/adapters/kysely/migration/cockroach-inspector.ts
import {
  DEFAULT_MIGRATION_LOCK_TABLE,
  DEFAULT_MIGRATION_TABLE,
  sql as sql2
} from "kysely";
var CockroachIntrospector = class {
  #db;
  constructor(db) {
    this.#db = db;
  }
  async getSchemas() {
    const rawSchemas = await this.#db.selectFrom("pg_catalog.pg_namespace").select("nspname").$castTo().execute();
    return rawSchemas.map((it) => ({ name: it.nspname }));
  }
  async getTables(options = { withInternalKyselyTables: false }) {
    let query = this.#db.selectFrom("pg_catalog.pg_attribute as a").innerJoin("pg_catalog.pg_class as c", "a.attrelid", "c.oid").innerJoin("pg_catalog.pg_namespace as ns", "c.relnamespace", "ns.oid").innerJoin("pg_catalog.pg_type as typ", "a.atttypid", "typ.oid").innerJoin(
      "pg_catalog.pg_namespace as dtns",
      "typ.typnamespace",
      "dtns.oid"
    ).select([
      "a.attname as column",
      "a.attnotnull as not_null",
      "a.atthasdef as has_default",
      "c.relname as table",
      "c.relkind as table_type",
      "ns.nspname as schema",
      "typ.typname as type",
      "dtns.nspname as type_schema",
      sql2`col_description(a.attrelid, a.attnum)`.as(
        "column_description"
      ),
      sql2`pg_get_serial_sequence(quote_ident(ns.nspname) || '.' || quote_ident(c.relname), a.attname)`.as(
        "auto_incrementing"
      )
    ]).where("c.relkind", "in", [
      "r",
      "v",
      "p"
    ]).where("ns.nspname", "!~", "^pg_").where("ns.nspname", "!=", "information_schema").where("ns.nspname", "!=", "crdb_internal").where("a.attnum", ">=", 0).where("a.attisdropped", "!=", true).orderBy("ns.nspname").orderBy("c.relname").orderBy("a.attnum").$castTo();
    if (!options.withInternalKyselyTables) {
      query = query.where("c.relname", "!=", DEFAULT_MIGRATION_TABLE).where("c.relname", "!=", DEFAULT_MIGRATION_LOCK_TABLE);
    }
    const rawColumns = await query.execute();
    return this.#parseTableMetadata(rawColumns);
  }
  async getMetadata(options) {
    return {
      tables: await this.getTables(options)
    };
  }
  #parseTableMetadata(columns) {
    return columns.reduce((tables, it) => {
      let table2 = tables.find(
        (tbl) => tbl.name === it.table && tbl.schema === it.schema
      );
      if (!table2) {
        table2 = {
          name: it.table,
          isView: it.table_type === "v",
          schema: it.schema,
          columns: []
        };
        tables.push(table2);
      }
      table2.columns.push({
        name: it.column,
        dataType: it.type,
        dataTypeSchema: it.type_schema,
        isNullable: !it.not_null,
        isAutoIncrementing: it.auto_incrementing !== null,
        hasDefaultValue: it.has_default,
        comment: it.column_description ?? void 0
      });
      return tables;
    }, []);
  }
};

// src/adapters/kysely/migration/introspect.ts
async function getUserTables(db, internalTables, provider) {
  const allTables = provider === "cockroachdb" ? await new CockroachIntrospector(db).getTables() : await db.introspection.getTables();
  const excludedSchemas = [
    "mysql",
    "information_schema",
    "performance_schema",
    "sys",
    "pg_catalog",
    "pg_toast",
    "sqlite_master",
    "sqlite_temp_master"
  ];
  return allTables.filter(
    (table2) => !table2.isView && (!table2.schema || !excludedSchemas.includes(table2.schema)) && !internalTables.includes(table2.name)
  );
}
async function introspectSchema(options) {
  const {
    db,
    provider,
    version = "1.0.0",
    internalTables = [],
    tableNameMapping = (t) => t,
    columnNameMapping = (_, c) => c,
    columnTypeMapping = (type, options2) => dbToSchemaType(type, provider, options2.metadata)[0],
    includeRelations = true
  } = options;
  const dbTables = await getUserTables(db, internalTables, provider);
  const tables = {};
  const relations = {};
  async function buildColumn(dbTable, dbColumn, isPrimaryKey) {
    const metadata = await getColumnMetadata(
      db,
      provider,
      dbTable.name,
      dbColumn.name
    );
    const columnType = columnTypeMapping(dbColumn.dataType, {
      isPrimaryKey,
      metadata: { ...dbColumn, ...metadata },
      tableMetadata: dbTable
    });
    if (!columnType)
      throw new Error(
        `Failed to detect data type of ${dbColumn.dataType}, note that FumaDB doesn't support advanced data types in schema.`
      );
    let rawDefault;
    try {
      rawDefault = await getColumnDefaultValue(
        db,
        provider,
        dbTable.name,
        dbColumn.name
      );
    } catch {
    }
    let col;
    if (isPrimaryKey) {
      if (!columnType.startsWith("varchar"))
        throw new Error(
          `ID column only supports varchar at the moment, found ${columnType}.`
        );
      col = idColumn(dbColumn.name, columnType);
    } else {
      col = column(dbColumn.name, columnType).nullable(dbColumn.isNullable);
    }
    const addDefault = normalizeColumnDefault(rawDefault, columnType);
    if (addDefault) col = addDefault(col);
    return col;
  }
  async function buildRelation(table2) {
    const foreignKeys = await introspectTableForeignKeys(
      db,
      provider,
      table2.names.sql
    );
    return (b) => {
      const output = {};
      for (const key of foreignKeys) {
        let relationName = key.name;
        const RemoveSuffix = "_fk";
        if (relationName.endsWith(RemoveSuffix))
          relationName = relationName.slice(0, -RemoveSuffix.length);
        output[relationName] = buildRelationDefinition(
          b,
          table2,
          key,
          (name) => Object.values(tables).find((t) => t.names.sql === name)
        );
      }
      return output;
    };
  }
  for (const dbTable of dbTables) {
    const columns = {};
    const primaryKeys = await introspectPrimaryKeys(db, dbTable.name, provider);
    const uniqueConsts = await introspectUniqueConstraints(
      db,
      dbTable.name,
      provider
    );
    for (const index of await introspectUniqueIndexes(
      db,
      dbTable.name,
      provider
    )) {
      if (uniqueConsts.some((con) => con.name === index.name)) continue;
      uniqueConsts.push(index);
    }
    if (primaryKeys.length !== 1)
      throw new Error(
        `FumaDB only supports 1 primary key (ID column), received: ${primaryKeys.length}.`
      );
    for (const dbColumn of dbTable.columns) {
      const isPrimaryKey = primaryKeys.includes(dbColumn.name);
      columns[columnNameMapping(dbTable.name, dbColumn.name)] = await buildColumn(dbTable, dbColumn, isPrimaryKey);
    }
    const t = table(dbTable.name, columns);
    for (const con of uniqueConsts) {
      t.unique(
        con.name,
        con.columns.map((col) => columnNameMapping(dbTable.name, col))
      );
    }
    tables[tableNameMapping(dbTable.name)] = t;
  }
  if (includeRelations) {
    for (const k in tables) {
      const table2 = tables[k];
      relations[k] = await buildRelation(table2);
    }
  }
  const generatedSchema = schema({
    version,
    tables,
    relations
  });
  return {
    schema: generatedSchema
  };
}
async function getColumnMetadata(db, provider, tableName, columnName) {
  function num(v) {
    if (v == null) return;
    const converted = Number(v);
    if (Number.isNaN(converted) || converted === -1) return;
    return converted;
  }
  switch (provider) {
    case "cockroachdb":
    case "postgresql": {
      const result = await db.selectFrom("information_schema.columns").select([
        "character_maximum_length as length",
        "numeric_precision as precision",
        "numeric_scale as scale"
      ]).where("table_name", "=", tableName).where("column_name", "=", columnName).executeTakeFirst();
      return {
        length: num(result?.length),
        precision: num(result?.precision),
        scale: num(result?.scale)
      };
    }
    case "mysql": {
      const result = await db.selectFrom("information_schema.columns").select([
        "CHARACTER_MAXIMUM_LENGTH as length",
        "NUMERIC_PRECISION as precision",
        "NUMERIC_SCALE as scale"
      ]).where("table_name", "=", tableName).where("column_name", "=", columnName).executeTakeFirst();
      return {
        length: num(result?.length),
        precision: num(result?.precision),
        scale: num(result?.scale)
      };
    }
    // SQLite doesn't have length/precision/scale
    case "sqlite": {
      return {};
    }
    case "mssql": {
      const result = await db.selectFrom("sys.columns as c").innerJoin("sys.tables as t", "c.object_id", "t.object_id").select([
        "c.max_length as length",
        "c.precision as precision",
        "c.scale as scale"
      ]).where("t.name", "=", tableName).where("c.name", "=", columnName).executeTakeFirst();
      return {
        length: num(result?.length),
        precision: num(result?.precision),
        scale: num(result?.scale)
      };
    }
  }
}
async function getColumnDefaultValue(db, provider, tableName, columnName) {
  switch (provider) {
    case "cockroachdb":
    case "postgresql":
      return await db.selectFrom("information_schema.columns").select("column_default").where("table_name", "=", tableName).where("column_name", "=", columnName).executeTakeFirst().then((result) => result?.column_default ?? null);
    case "mysql": {
      const result = await db.selectFrom("information_schema.columns").select("COLUMN_DEFAULT as column_default").where("table_name", "=", tableName).where("column_name", "=", columnName).executeTakeFirst();
      return result?.column_default ?? null;
    }
    case "sqlite": {
      const { sql: sql6 } = await import("kysely");
      const pragmaRows = await sql6.raw(`PRAGMA table_info(${tableName})`).execute(db);
      const row = Array.isArray(pragmaRows) ? pragmaRows.find((r) => r.name === columnName) : void 0;
      return row?.dflt_value ?? null;
    }
    case "mssql": {
      const result = await db.selectFrom("sys.columns as c").innerJoin("sys.tables as t", "c.object_id", "t.object_id").leftJoin(
        "sys.default_constraints as d",
        (join) => join.on("c.default_object_id", "=", "d.object_id")
      ).select("d.definition as column_default").where("t.name", "=", tableName).where("c.name", "=", columnName).executeTakeFirst();
      return result?.column_default ?? null;
    }
    default:
      throw new Error(
        `Provider ${provider} not supported for default value introspection`
      );
  }
}
function normalizeColumnDefault(raw, type) {
  if (raw == null) return;
  let str = String(raw).trim();
  if (/^(CURRENT_TIMESTAMP|now\(\)|datetime\('now'\)|getdate\(\))/i.test(str) && (type === "date" || type === "timestamp")) {
    return (col) => col.defaultTo$("now");
  }
  str = str.replace(/::[\w\s[\]."]+$/, "");
  if (str.startsWith("E'") || str.startsWith("N'")) {
    str = str.slice(2, -1);
  } else if (str.startsWith("'") && str.endsWith("'") || str.startsWith('"') && str.endsWith('"')) {
    str = str.slice(1, -1);
  }
  if (type === "bool") {
    if (str === "true" || str === "1")
      return (col) => col.defaultTo(true);
    if (str === "false" || str === "0")
      return (col) => col.defaultTo(false);
  }
  if ((type === "integer" || type === "decimal") && str.length > 0) {
    const parsed = Number(str);
    if (Number.isNaN(parsed))
      throw new Error(
        `Failed to parse number from database default column value: ${str}`
      );
    return (col) => col.defaultTo(parsed);
  }
  if (type === "json") {
    return (col) => col.defaultTo(JSON.parse(str));
  }
  if (type === "bigint" && str.length > 0) {
    return (col) => col.defaultTo(BigInt(str));
  }
  if (type === "timestamp" || type === "date") {
    return (col) => col.defaultTo(new Date(str));
  }
  if (str.toLowerCase() === "null") return;
  if (type === "string" || type.startsWith("varchar"))
    return (col) => col.defaultTo(str);
}
function buildRelationDefinition(builder, table2, fk, dbNameToTable) {
  const targetTable = dbNameToTable(fk.referencedTable);
  if (!targetTable)
    throw new Error(
      `Failed to resolve referenced table in a foreign key: ${fk.referencedTable}`
    );
  const on = [];
  for (let i = 0; i < fk.columns.length; i++) {
    const col = fk.columns[i];
    const refCol = fk.referencedColumns[i];
    on.push([
      table2.getColumnByName(col).ormName,
      targetTable.getColumnByName(refCol).ormName
    ]);
  }
  return builder.one(targetTable.ormName, ...on).foreignKey({
    name: fk.name,
    onDelete: fk.onDelete,
    onUpdate: fk.onUpdate
  });
}
async function introspectPrimaryKeys(db, tableName, provider) {
  if (provider === "sqlite") {
    const columns = await db.selectFrom(sql3.raw(`pragma_table_info('${tableName}')`).as("t")).select(["name", "pk"]).execute();
    return columns.filter((col) => col.pk).map((col) => col.name);
  }
  if (provider === "postgresql" || provider === "cockroachdb") {
    const pkRows = await db.selectFrom("pg_constraint").innerJoin("pg_class", "pg_constraint.conrelid", "pg_class.oid").innerJoin("pg_namespace", "pg_class.relnamespace", "pg_namespace.oid").where("pg_class.relname", "=", tableName).where("pg_constraint.contype", "=", "p").select(["pg_constraint.conname", "pg_constraint.conkey"]).execute();
    const attnumToName = await postgresqlIntrospectAttnumToName(db, tableName);
    const primaryKeys = [];
    for (const pk of pkRows) {
      const attnums = postgresqlParseConName(pk.conkey);
      for (const attnum of attnums) {
        const colName = attnumToName.get(attnum);
        if (colName !== void 0) {
          primaryKeys.push(colName);
        }
      }
    }
    return primaryKeys;
  }
  if (provider === "mysql") {
    const keyRows = await db.selectFrom("information_schema.KEY_COLUMN_USAGE").where("TABLE_NAME", "=", tableName).select(["CONSTRAINT_NAME", "COLUMN_NAME"]).execute();
    const constraints = {};
    for (const row of keyRows) {
      if (row.CONSTRAINT_NAME && row.COLUMN_NAME) {
        constraints[row.CONSTRAINT_NAME] ??= [];
        constraints[row.CONSTRAINT_NAME]?.push(row.COLUMN_NAME);
      }
    }
    const pkRow = await db.selectFrom("information_schema.TABLE_CONSTRAINTS").where("TABLE_NAME", "=", tableName).where("CONSTRAINT_TYPE", "=", "PRIMARY KEY").select(["CONSTRAINT_NAME"]).executeTakeFirstOrThrow();
    const pkName = pkRow.CONSTRAINT_NAME;
    return constraints[pkName] ?? [];
  }
  if (provider === "mssql") {
    const result = await db.selectFrom("sys.key_constraints as kc").select("c.name as column_name").innerJoin(
      "sys.index_columns as ic",
      (v) => v.onRef("kc.parent_object_id", "=", "ic.object_id").onRef("kc.unique_index_id", "=", "ic.index_id")
    ).innerJoin(
      "sys.columns as c",
      (v) => v.onRef("ic.object_id", "=", "c.object_id").onRef("ic.column_id", "=", "c.column_id")
    ).innerJoin("sys.tables as t", "kc.parent_object_id", "t.object_id").innerJoin("sys.schemas as s", "t.schema_id", "s.schema_id").where("kc.type", "=", "PK").where("s.name", "=", "dbo").where("t.name", "=", tableName).orderBy("ic.key_ordinal").execute();
    return result.map((row) => row.column_name);
  }
  return [];
}
async function postgresqlIntrospectAttnumToName(db, tableName) {
  const colRows = await db.selectFrom("pg_attribute").innerJoin("pg_class", "pg_attribute.attrelid", "pg_class.oid").where("pg_class.relname", "=", tableName).where("pg_attribute.attnum", ">", 0).select(["pg_attribute.attnum", "pg_attribute.attname"]).execute();
  const attnumToName = /* @__PURE__ */ new Map();
  for (const row of colRows) {
    attnumToName.set(Number(row.attnum), row.attname);
  }
  return attnumToName;
}
function postgresqlParseConName(conName) {
  if (Array.isArray(conName)) return conName.map(Number);
  if (typeof conName === "string") {
    return conName.substring(1, conName.length - 1).split(",").map(Number);
  }
  return [];
}
function mapToUniqueConstraints(from) {
  const map = /* @__PURE__ */ new Map();
  for (const item of from) {
    const value = map.get(item.constraint_name) ?? {
      name: item.constraint_name,
      columns: []
    };
    value.columns.push(item.column_name);
    map.set(item.constraint_name, value);
  }
  return Array.from(map.values());
}
async function introspectUniqueIndexes(db, tableName, provider) {
  if (provider === "mssql") {
    const indexes = await db.selectFrom("sys.indexes as i").innerJoin(
      "sys.index_columns as ic",
      (join) => join.onRef("i.object_id", "=", "ic.object_id").onRef("i.index_id", "=", "ic.index_id")
    ).innerJoin(
      "sys.columns as c",
      (join) => join.onRef("ic.object_id", "=", "c.object_id").onRef("ic.column_id", "=", "c.column_id")
    ).innerJoin("sys.tables as t", "i.object_id", "t.object_id").where("i.is_unique", "=", 1).where(
      "i.index_id",
      "not in",
      db.selectFrom("sys.key_constraints").select("unique_index_id").whereRef("parent_object_id", "=", "t.object_id")
    ).where("t.name", "=", tableName).select([
      "i.name as constraint_name",
      "c.name as column_name",
      "ic.key_ordinal"
    ]).orderBy("constraint_name").orderBy("ic.key_ordinal").execute();
    return mapToUniqueConstraints(indexes);
  }
  if (provider === "sqlite") {
    const indexes = await db.selectFrom(sql3.raw(`pragma_index_list('${tableName}')`).as("i")).select(["name", "unique"]).execute();
    const uniqueConstraints = [];
    for (const idx of indexes) {
      if (!idx.unique) continue;
      const idxCols = await db.selectFrom(sql3.raw(`pragma_index_info('${idx.name}')`).as("ii")).select(["name"]).execute();
      uniqueConstraints.push({
        name: idx.name,
        columns: idxCols.map((c) => c.name)
      });
    }
    return uniqueConstraints;
  }
  return [];
}
async function introspectUniqueConstraints(db, tableName, provider) {
  if (provider === "postgresql" || provider === "cockroachdb") {
    const uniqueRows = await db.selectFrom("pg_constraint").innerJoin("pg_class", "pg_constraint.conrelid", "pg_class.oid").innerJoin("pg_namespace", "pg_class.relnamespace", "pg_namespace.oid").where("pg_class.relname", "=", tableName).where("pg_constraint.contype", "=", "u").select(["pg_constraint.conname", "pg_constraint.conkey"]).execute();
    const attnumToName = await postgresqlIntrospectAttnumToName(db, tableName);
    const uniqueConstraints = [];
    for (const uq of uniqueRows) {
      const attnums = postgresqlParseConName(uq.conkey);
      uniqueConstraints.push({
        name: uq.conname,
        columns: attnums.flatMap((a) => attnumToName.get(a) ?? [])
      });
    }
    return uniqueConstraints;
  }
  if (provider === "mysql") {
    const keyRows = await db.selectFrom("information_schema.KEY_COLUMN_USAGE").where("TABLE_NAME", "=", tableName).select(["CONSTRAINT_NAME", "COLUMN_NAME"]).execute();
    const constraints = {};
    for (const row of keyRows) {
      if (row.CONSTRAINT_NAME && row.COLUMN_NAME) {
        constraints[row.CONSTRAINT_NAME] ??= [];
        constraints[row.CONSTRAINT_NAME]?.push(row.COLUMN_NAME);
      }
    }
    const uniqueRows = await db.selectFrom("information_schema.TABLE_CONSTRAINTS").where("TABLE_NAME", "=", tableName).where("CONSTRAINT_TYPE", "=", "UNIQUE").select(["CONSTRAINT_NAME"]).execute();
    const uniqueConstraints = [];
    for (const uq of uniqueRows) {
      uniqueConstraints.push({
        name: uq.CONSTRAINT_NAME,
        columns: constraints[uq.CONSTRAINT_NAME] ?? []
      });
    }
    return uniqueConstraints;
  }
  if (provider === "mssql") {
    const constraints = await db.selectFrom("sys.key_constraints as kc").innerJoin(
      "sys.index_columns as ic",
      (join) => join.onRef("kc.parent_object_id", "=", "ic.object_id").onRef("kc.unique_index_id", "=", "ic.index_id")
    ).innerJoin(
      "sys.columns as c",
      (join) => join.onRef("ic.object_id", "=", "c.object_id").onRef("ic.column_id", "=", "c.column_id")
    ).innerJoin("sys.tables as t", "kc.parent_object_id", "t.object_id").where("kc.type", "=", "UQ").where("t.name", "=", tableName).select([
      "kc.name as constraint_name",
      "c.name as column_name",
      "ic.key_ordinal"
    ]).orderBy("constraint_name").orderBy("ic.key_ordinal").execute();
    return mapToUniqueConstraints(constraints);
  }
  return [];
}
async function introspectTableForeignKeys(db, provider, tableName) {
  if (provider === "postgresql" || provider === "cockroachdb") {
    const constraints = await db.selectFrom("information_schema.table_constraints as tc").innerJoin(
      "information_schema.key_column_usage as kcu",
      (join) => join.onRef("tc.constraint_name", "=", "kcu.constraint_name").onRef("tc.table_name", "=", "kcu.table_name")
    ).innerJoin(
      "information_schema.referential_constraints as rc",
      (join) => join.onRef("tc.constraint_name", "=", "rc.constraint_name")
    ).innerJoin(
      "information_schema.table_constraints as tc_ref",
      (join) => join.onRef("rc.unique_constraint_name", "=", "tc_ref.constraint_name").onRef("rc.unique_constraint_schema", "=", "tc_ref.constraint_schema")
    ).select([
      "tc.constraint_name as name",
      "kcu.column_name as column_name",
      "kcu.ordinal_position as ordinal_position",
      "tc_ref.table_name as referenced_table",
      "rc.unique_constraint_name as referenced_constraint_name",
      "rc.update_rule as on_update",
      "rc.delete_rule as on_delete"
    ]).where("tc.table_name", "=", tableName).where("tc.constraint_type", "=", "FOREIGN KEY").orderBy("name", "asc").orderBy("ordinal_position", "asc").execute();
    const map = /* @__PURE__ */ new Map();
    for (const row of constraints) {
      let fk = map.get(row.name);
      if (!fk) {
        fk = {
          name: row.name,
          columns: [],
          referencedTable: row.referenced_table,
          referencedColumns: [],
          onUpdate: mapAction(row.on_update),
          onDelete: mapAction(row.on_delete),
          referencedConstraintName: row.referenced_constraint_name
        };
        map.set(row.name, fk);
      }
      fk.columns.push(row.column_name);
    }
    for (const fk of map.values()) {
      const refCols = await db.selectFrom("information_schema.key_column_usage").select(["column_name"]).where("constraint_name", "=", fk.referencedConstraintName).where("table_name", "=", fk.referencedTable).orderBy("ordinal_position", "asc").execute();
      fk.referencedColumns = refCols.map((r) => r.column_name);
      delete fk.referencedConstraintName;
    }
    return Array.from(map.values());
  }
  if (provider === "mysql") {
    const constraints = await db.selectFrom("information_schema.key_column_usage as kcu").innerJoin(
      "information_schema.referential_constraints as rc",
      (join) => join.onRef("kcu.constraint_name", "=", "rc.constraint_name").onRef("kcu.table_name", "=", "rc.table_name")
    ).select([
      "kcu.constraint_name as name",
      "kcu.column_name as column_name",
      "kcu.ordinal_position as ordinal_position",
      "kcu.referenced_table_name as referenced_table",
      "kcu.referenced_column_name as referenced_column",
      "rc.update_rule as on_update",
      "rc.delete_rule as on_delete"
    ]).where("kcu.table_name", "=", tableName).where("kcu.referenced_table_name", "is not", null).orderBy("name", "asc").orderBy("ordinal_position", "asc").execute();
    const map = /* @__PURE__ */ new Map();
    for (const row of constraints) {
      let fk = map.get(row.name);
      if (!fk) {
        fk = {
          name: row.name,
          columns: [],
          referencedTable: row.referenced_table,
          referencedColumns: [],
          onUpdate: mapAction(row.on_update),
          onDelete: mapAction(row.on_delete)
        };
        map.set(row.name, fk);
      }
      fk.columns.push(row.column_name);
      fk.referencedColumns.push(row.referenced_column);
    }
    return Array.from(map.values());
  }
  if (provider === "sqlite") {
    const pragmaRows = await sql3.raw(`PRAGMA foreign_key_list(${tableName})`).execute(db);
    const map = /* @__PURE__ */ new Map();
    for (const row of pragmaRows.rows) {
      let fk = map.get(row.id);
      if (!fk) {
        fk = {
          name: `fk_${tableName}_${row.id}`,
          columns: [],
          referencedTable: row.table,
          referencedColumns: [],
          onUpdate: mapAction(row.on_update),
          onDelete: mapAction(row.on_delete)
        };
        map.set(row.id, fk);
      }
      fk.columns.push(row.from);
      fk.referencedColumns.push(row.to);
    }
    return Array.from(map.values());
  }
  if (provider === "mssql") {
    const constraints = await db.selectFrom("sys.foreign_keys as fk").innerJoin(
      "sys.foreign_key_columns as fkc",
      "fk.object_id",
      "fkc.constraint_object_id"
    ).innerJoin("sys.tables as t", "fk.parent_object_id", "t.object_id").innerJoin(
      "sys.columns as c",
      (join) => join.onRef("fkc.parent_object_id", "=", "c.object_id").onRef("fkc.parent_column_id", "=", "c.column_id")
    ).innerJoin("sys.tables as rt", "fk.referenced_object_id", "rt.object_id").innerJoin(
      "sys.columns as rc",
      (join) => join.onRef("fkc.referenced_object_id", "=", "rc.object_id").onRef("fkc.referenced_column_id", "=", "rc.column_id")
    ).select([
      "fk.name as name",
      "c.name as column_name",
      "rc.name as referenced_column",
      "rt.name as referenced_table",
      "fkc.constraint_column_id as ordinal_position",
      "fk.delete_referential_action_desc as on_delete",
      "fk.update_referential_action_desc as on_update"
    ]).where("t.name", "=", tableName).orderBy("name", "asc").orderBy("ordinal_position", "asc").execute();
    const map = /* @__PURE__ */ new Map();
    for (const row of constraints) {
      let fk = map.get(row.name);
      if (!fk) {
        fk = {
          name: row.name,
          columns: [],
          referencedTable: row.referenced_table,
          referencedColumns: [],
          onUpdate: mapAction(row.on_update),
          onDelete: mapAction(row.on_delete)
        };
        map.set(row.name, fk);
      }
      fk.columns.push(row.column_name);
      fk.referencedColumns.push(row.referenced_column);
    }
    return Array.from(map.values());
  }
  throw new Error(
    `Provider ${provider} not supported for foreign key introspection`
  );
}
function mapAction(action) {
  switch (action?.toUpperCase()) {
    case "CASCADE":
      return "CASCADE";
    case "SET NULL":
      return "SET NULL";
    case "RESTRICT":
    case "NO ACTION":
    case "NONE":
      return "RESTRICT";
    default:
      return "RESTRICT";
  }
}

// src/adapters/kysely/migration/auto-from-database.ts
async function generateMigration(schema2, config, options) {
  const { db, provider } = config;
  const { dropUnusedColumns = true, internalTables, nameVariants } = options;
  const schemaWithVariant = nameVariants ? applyNameVariants(schema2, nameVariants) : schema2;
  const tables = Object.values(schemaWithVariant.tables);
  const tableNameMapping = /* @__PURE__ */ new Map();
  for (const t of tables) {
    tableNameMapping.set(t.names.sql, t.ormName);
  }
  const introspected = await introspectSchema({
    db,
    provider,
    columnNameMapping(tableName, columnName) {
      const name = tableNameMapping.get(tableName);
      if (!name) return columnName;
      const col = schemaWithVariant.tables[name].getColumnByName(columnName);
      if (!col) return columnName;
      return col.ormName;
    },
    columnTypeMapping(dataType, options2) {
      const predicted = dbToSchemaType(dataType, provider, options2.metadata);
      function fallback() {
        for (let item of predicted) {
          if (item === "varchar(n)") item = "varchar(255)";
          if (!options2.isPrimaryKey) return item;
          if (item.startsWith("varchar")) return item;
        }
        throw new Error("failed to predict");
      }
      const col = schemaWithVariant.tables[tableNameMapping.get(options2.tableMetadata.name) ?? options2.tableMetadata.name]?.getColumnByName(options2.metadata.name);
      if (!col) return fallback();
      for (const item of predicted) {
        if (item === col.type) return item;
        if (item === "varchar(n)" && col.type.startsWith("varchar"))
          return col.type;
      }
      return fallback();
    },
    tableNameMapping(tableName) {
      return tableNameMapping.get(tableName) ?? tableName;
    },
    internalTables
  });
  return generateMigrationFromSchema(introspected.schema, schema2, {
    ...config,
    dropUnusedColumns,
    dropUnusedTables: false
  });
}

// src/adapters/kysely/migration/execute.ts
import {
  sql as sql4
} from "kysely";
function getColumnBuilderCallback(col, provider) {
  return (build) => {
    if (!col.isNullable) {
      build = build.notNull();
    }
    if (col instanceof IdColumn) build = build.primaryKey();
    const defaultValue = defaultValueToDB(col, provider);
    if (defaultValue) build = build.defaultTo(defaultValue);
    return build;
  };
}
var errors = {
  IdColumnUpdate: "ID columns must not be updated, not every database supports updating primary keys and often requires workarounds.",
  SQLiteUpdateForeignKeys: "In SQLite, you cannot modify foreign keys directly, use `recreate-table` instead."
};
function createUniqueIndex(db, name, tableName, cols, provider) {
  const query = db.schema.createIndex(name).on(tableName).columns(cols).unique();
  if (provider === "mssql") {
    return query.where((b) => {
      return b.and(cols.map((col) => b(col, "is not", null)));
    });
  }
  return query;
}
function createUniqueIndexOrConstraint(db, name, tableName, cols, provider) {
  if (provider === "sqlite" || provider === "mssql") {
    return createUniqueIndex(db, name, tableName, cols, provider);
  }
  return db.schema.alterTable(tableName).addUniqueConstraint(name, cols);
}
function dropUniqueIndexOrConstraint(db, name, tableName, provider) {
  if (provider === "cockroachdb" || provider === "sqlite" || provider === "mssql") {
    let query = db.schema.dropIndex(name).ifExists();
    if (provider === "cockroachdb") query = query.cascade();
    if (provider === "mssql") query = query.on(tableName);
    return query;
  }
  return db.schema.alterTable(tableName).dropConstraint(name);
}
function executeColumn(tableName, operation, config) {
  const { db, provider } = config;
  const next = () => db.schema.alterTable(tableName);
  const results = [];
  switch (operation.type) {
    case "rename-column":
      results.push(next().renameColumn(operation.from, operation.to));
      return results;
    case "drop-column":
      results.push(next().dropColumn(operation.name));
      return results;
    case "create-column": {
      const col = operation.value;
      results.push(
        next().addColumn(
          col.names.sql,
          sql4.raw(schemaToDBType(col, provider)),
          getColumnBuilderCallback(col, provider)
        )
      );
      return results;
    }
    case "update-column": {
      const col = operation.value;
      if (col instanceof IdColumn) throw new Error(errors.IdColumnUpdate);
      if (provider === "sqlite") {
        throw new Error(
          "SQLite doesn't support updating column, recreate the table instead."
        );
      }
      if (!isUpdated(operation)) return results;
      if (provider === "mysql") {
        results.push(
          next().modifyColumn(
            operation.name,
            sql4.raw(schemaToDBType(col, provider)),
            getColumnBuilderCallback(col, provider)
          )
        );
        return results;
      }
      const mssqlRecreateDefaultConstraint = operation.updateDataType || operation.updateDefault;
      if (provider === "mssql" && mssqlRecreateDefaultConstraint) {
        results.push(
          rawToNode(db, mssqlDropDefaultConstraint(tableName, col.names.sql))
        );
      }
      if (operation.updateDataType) {
        const dbType = sql4.raw(schemaToDBType(col, provider));
        results.push(
          provider === "postgresql" || provider === "cockroachdb" ? rawToNode(
            db,
            sql4`ALTER TABLE ${sql4.ref(tableName)} ALTER COLUMN ${sql4.ref(operation.name)} TYPE ${dbType} USING (${sql4.ref(operation.name)}::${dbType})`
          ) : next().alterColumn(operation.name, (b) => b.setDataType(dbType))
        );
      }
      if (operation.updateNullable) {
        results.push(
          next().alterColumn(
            operation.name,
            (build) => col.isNullable ? build.dropNotNull() : build.setNotNull()
          )
        );
      }
      if (provider === "mssql" && mssqlRecreateDefaultConstraint) {
        const defaultValue = defaultValueToDB(col, provider);
        if (defaultValue) {
          const name = `DF_${tableName}_${col.names.sql}`;
          results.push(
            rawToNode(
              db,
              sql4`ALTER TABLE ${sql4.ref(tableName)} ADD CONSTRAINT ${sql4.ref(name)} DEFAULT ${defaultValue} FOR ${sql4.ref(col.names.sql)}`
            )
          );
        }
      } else if (provider !== "mssql" && operation.updateDefault) {
        const defaultValue = defaultValueToDB(col, provider);
        results.push(
          next().alterColumn(operation.name, (build) => {
            if (!defaultValue) return build.dropDefault();
            return build.setDefault(defaultValue);
          })
        );
      }
      return results;
    }
  }
}
function execute(operation, config, onCustomNode) {
  const {
    db,
    provider,
    relationMode = provider === "mssql" ? "fumadb" : "foreign-keys"
  } = config;
  function createTable(table2, tableName = table2.names.sql, sqliteDeferChecks = false) {
    const results = [];
    let builder = db.schema.createTable(tableName);
    for (const col of Object.values(table2.columns)) {
      builder = builder.addColumn(
        col.names.sql,
        sql4.raw(schemaToDBType(col, provider)),
        getColumnBuilderCallback(col, provider)
      );
    }
    for (const foreignKey of table2.foreignKeys) {
      if (relationMode === "fumadb") break;
      const compiled = compileForeignKey(foreignKey, "sql");
      builder = builder.addForeignKeyConstraint(
        compiled.name,
        compiled.columns,
        compiled.referencedTable,
        compiled.referencedColumns,
        (b) => {
          const builder2 = b.onUpdate(mapForeignKeyAction(compiled.onUpdate, provider)).onDelete(mapForeignKeyAction(compiled.onDelete, provider));
          if (sqliteDeferChecks)
            return builder2.deferrable().initiallyDeferred();
          return builder2;
        }
      );
    }
    for (const con of table2.getUniqueConstraints()) {
      results.push(
        createUniqueIndexOrConstraint(
          db,
          con.name,
          table2.names.sql,
          con.columns.map((col) => col.names.sql),
          provider
        )
      );
    }
    results.unshift(builder);
    return results;
  }
  switch (operation.type) {
    case "create-table":
      return createTable(operation.value);
    case "rename-table":
      if (provider === "mssql") {
        return rawToNode(
          db,
          sql4.raw(`EXEC sp_rename ${operation.from}, ${operation.to}`)
        );
      }
      return db.schema.alterTable(operation.from).renameTo(operation.to);
    case "update-table": {
      const results = [];
      for (const op of operation.value) {
        results.push(...executeColumn(operation.name, op, config));
      }
      return results;
    }
    case "drop-table":
      return db.schema.dropTable(operation.name);
    case "custom":
      return onCustomNode(operation);
    case "add-foreign-key": {
      if (provider === "sqlite")
        throw new Error(errors.SQLiteUpdateForeignKeys);
      const { table: table2, value } = operation;
      return db.schema.alterTable(table2).addForeignKeyConstraint(
        value.name,
        value.columns,
        value.referencedTable,
        value.referencedColumns,
        (b) => b.onUpdate(mapForeignKeyAction(value.onUpdate, provider)).onDelete(mapForeignKeyAction(value.onDelete, provider))
      );
    }
    case "drop-foreign-key": {
      if (provider === "sqlite")
        throw new Error(errors.SQLiteUpdateForeignKeys);
      const { table: table2, name } = operation;
      let query = db.schema.alterTable(table2).dropConstraint(name);
      if (provider !== "mysql") query = query.ifExists();
      return query;
    }
    case "add-unique-constraint":
      return createUniqueIndexOrConstraint(
        db,
        operation.name,
        operation.table,
        operation.columns,
        provider
      );
    case "drop-unique-constraint":
      return dropUniqueIndexOrConstraint(
        db,
        operation.name,
        operation.table,
        provider
      );
  }
}
function mapForeignKeyAction(action, provider) {
  switch (action) {
    case "CASCADE":
      return "cascade";
    case "RESTRICT":
      return provider === "mssql" ? "no action" : "restrict";
    case "SET NULL":
      return "set null";
  }
}
function rawToNode(db, raw) {
  return {
    compile() {
      return raw.compile(db);
    },
    execute() {
      return raw.execute(db);
    }
  };
}
function mssqlDropDefaultConstraint(tableName, columnName) {
  const alter = sql4.lit(`ALTER TABLE "dbo"."${tableName}" DROP CONSTRAINT `);
  return sql4`DECLARE @ConstraintName NVARCHAR(200);

SELECT @ConstraintName = dc.name
FROM sys.default_constraints dc
JOIN sys.columns c ON dc.parent_object_id = c.object_id AND dc.parent_column_id = c.column_id
JOIN sys.tables t ON t.object_id = c.object_id
JOIN sys.schemas s ON t.schema_id = s.schema_id
WHERE s.name = 'dbo' AND t.name = ${sql4.lit(tableName)} AND c.name = ${sql4.lit(columnName)};

IF @ConstraintName IS NOT NULL
BEGIN
    EXEC(${alter} + @ConstraintName);
END`;
}
function defaultValueToDB(column2, provider) {
  const value = column2.default;
  if (!value) return;
  if (provider === "mysql" && column2.type === "string") return;
  if ("runtime" in value && value.runtime === "now") {
    return sql4`CURRENT_TIMESTAMP`;
  }
  if ("value" in value) return sql4.lit(value.value);
}

// src/adapters/kysely/migration/transformer-sqlite.ts
var SupportedColumnOperations = [
  "create-column",
  "rename-column"
];
var transformerSQLite = {
  afterAuto(operations, { prev, next }) {
    const operationTables = [];
    const nameToTable = /* @__PURE__ */ new Map();
    const recreate = /* @__PURE__ */ new Set();
    for (const table2 of Object.values(prev.tables)) {
      nameToTable.set(table2.names.sql, table2);
    }
    for (const op of operations) {
      let table2 = void 0;
      switch (op.type) {
        case "create-table": {
          table2 = op.value;
          nameToTable.set(op.value.names.sql, table2);
          break;
        }
        case "rename-table": {
          table2 = nameToTable.get(op.from);
          if (!table2) break;
          nameToTable.set(op.to, table2);
          nameToTable.delete(op.from);
          break;
        }
        case "add-unique-constraint":
        case "drop-unique-constraint": {
          table2 = nameToTable.get(op.table);
          break;
        }
        case "add-foreign-key":
        case "drop-foreign-key": {
          table2 = nameToTable.get(op.table);
          if (!table2) break;
          recreate.add(table2);
          break;
        }
        case "update-table": {
          table2 = nameToTable.get(op.name);
          if (!table2 || op.value.every(
            (action) => SupportedColumnOperations.includes(action.type)
          ))
            break;
          recreate.add(table2);
          break;
        }
        case "drop-table": {
          table2 = nameToTable.get(op.name);
          if (!table2) break;
          nameToTable.delete(op.name);
          recreate.delete(table2);
        }
      }
      operationTables.push(table2 ?? null);
    }
    operations = operations.filter((_, i) => {
      const table2 = operationTables[i];
      return !table2 || !recreate.has(table2);
    });
    const post = [];
    for (const prevTable of recreate) {
      const nextTable = next.tables[prevTable.ormName];
      if (!nextTable) continue;
      for (const con of prevTable.getUniqueConstraints()) {
        operations.push({
          type: "drop-unique-constraint",
          table: prevTable.names.sql,
          name: con.name
        });
      }
      const tempTable = nextTable.names.sql === prevTable.names.sql ? {
        ...nextTable,
        names: {
          ...nextTable.names,
          sql: `_temp_${nextTable.names.sql}`
        }
      } : nextTable;
      operations.push({
        type: "create-table",
        value: tempTable
      });
      post.push(() => {
        operations.push(...transferTable(prevTable, tempTable));
        if (tempTable !== nextTable)
          operations.push({
            type: "rename-table",
            from: tempTable.names.sql,
            to: nextTable.names.sql
          });
      });
    }
    for (const item of post) item();
    return operations;
  }
};
function transferTable(from, to) {
  const tempName = to.names.sql === from.names.sql ? `_temp_${to.names.sql}` : to.names.sql;
  const colNames = [];
  const values = [];
  for (const prevCol of Object.values(from.columns)) {
    const nextCol = to.columns[prevCol.ormName];
    if (!nextCol) continue;
    colNames.push(`"${nextCol.names.sql}"`);
    values.push(`"${prevCol.names.sql}" as "${nextCol.names.sql}"`);
  }
  return [
    {
      type: "custom",
      sql: `INSERT INTO "${tempName}" (${colNames.join(", ")}) SELECT ${values.join(", ")} FROM "${from.names.sql}"`
    },
    {
      type: "drop-table",
      name: from.names.sql
    }
  ];
}

// src/adapters/kysely/index.ts
function kyselyAdapter(config) {
  return {
    name: "kysely",
    createORM(schema2) {
      return fromKysely(schema2, config);
    },
    getSchemaVersion() {
      const manager = createSettingsManager(config.db, config.provider, {
        settings: `private_${this.namespace}_settings`
      });
      return manager.get("version");
    },
    createMigrationEngine() {
      return createSQLMigrator(this, config, {
        settings: `private_${this.namespace}_settings`
      });
    }
  };
}
function createSQLMigrator(lib, config, modelNames) {
  const manager = createSettingsManager(config.db, config.provider, modelNames);
  function onCustomNode(node, db) {
    const statement = sql5.raw(node.sql);
    return {
      compile() {
        return statement.compile(db);
      },
      execute() {
        return statement.execute(db);
      }
    };
  }
  async function getNameVariants() {
    const currentVariants = await manager.get("name-variants");
    if (!currentVariants) return;
    try {
      return JSON.parse(currentVariants);
    } catch (e) {
      console.warn("failed to parse stored name variants, skipping for now", e);
    }
  }
  function preprocess(operations, db) {
    if (config.provider === "mysql") {
      operations.unshift({ type: "custom", sql: "SET FOREIGN_KEY_CHECKS = 0" });
      operations.push({ type: "custom", sql: "SET FOREIGN_KEY_CHECKS = 1" });
    } else if (config.provider === "sqlite") {
      operations.unshift({
        type: "custom",
        sql: "PRAGMA defer_foreign_keys = ON"
      });
    }
    const tsConfig = {
      ...config,
      db
    };
    return operations.flatMap(
      (op) => execute(op, tsConfig, (node) => onCustomNode(node, db))
    );
  }
  return createMigrator({
    libConfig: lib,
    userConfig: config,
    async generateMigrationFromDatabase(options) {
      return generateMigration(options.target, config, {
        nameVariants: await getNameVariants(),
        internalTables: Object.values(modelNames),
        dropUnusedColumns: options.dropUnusedColumns
      });
    },
    async executor(operations) {
      await config.db.transaction().execute(async (tx) => {
        for (const node of preprocess(operations, tx)) {
          try {
            await node.execute();
          } catch (e) {
            console.error("failed at", node.compile(), e);
            throw e;
          }
        }
      });
    },
    settings: {
      getVersion: () => manager.get("version"),
      getNameVariants,
      async updateSettingsInMigration(schema2) {
        const settings = {
          version: schema2.version,
          "name-variants": JSON.stringify(exportNameVariants(schema2))
        };
        const init = await manager.initIfNeeded();
        const statements = [];
        if (init) statements.push(init);
        for (const [k, v] of Object.entries(settings)) {
          if (init || !await manager.get(k)) {
            statements.push(manager.insert(k, v));
            continue;
          }
          statements.push(manager.update(k, v));
        }
        return statements.map((statement) => ({
          type: "custom",
          sql: statement
        }));
      }
    },
    sql: {
      toSql(operations) {
        const compiled = preprocess(operations, config.db).map(
          (m) => `${m.compile().sql};`
        );
        return compiled.join("\n\n");
      }
    },
    transformers: config.provider === "sqlite" ? [transformerSQLite] : []
  });
}
function createSettingsManager(db, provider, modelNames) {
  const { settings } = modelNames;
  function initTable() {
    return db.schema.createTable(settings).addColumn(
      "key",
      provider === "sqlite" ? "text" : "varchar(255)",
      (col) => col.primaryKey()
    ).addColumn(
      "value",
      sql5.raw(schemaToDBType({ type: "string" }, provider)),
      (col) => col.notNull()
    );
  }
  return {
    async get(key) {
      try {
        const result = await db.selectFrom(settings).where("key", "=", key).select(["value"]).executeTakeFirstOrThrow();
        return result.value;
      } catch {
        return;
      }
    },
    async initIfNeeded() {
      const tables = await db.introspection.getTables();
      if (tables.some((table2) => table2.name === settings)) return;
      return initTable().compile().sql;
    },
    insert(key, value) {
      return db.insertInto(settings).values({
        key: sql5.lit(key),
        value: sql5.lit(value)
      }).compile().sql;
    },
    update(key, value) {
      return db.updateTable(settings).set({
        value: sql5.lit(value)
      }).where("key", "=", sql5.lit(key)).compile().sql;
    }
  };
}

export {
  kyselyAdapter
};
