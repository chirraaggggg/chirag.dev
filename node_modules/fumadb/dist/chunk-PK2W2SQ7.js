// src/query/condition-builder.ts
var stringOperators = [
  "contains",
  "starts with",
  "ends with",
  "not contains",
  "not starts with",
  "not ends with"
  // excluded `regexp` since MSSQL doesn't support it, may re-consider
];
var arrayOperators = ["in", "not in"];
var valueOperators = [
  "=",
  "!=",
  ">",
  ">=",
  "<",
  "<=",
  "is",
  "is not"
];
var operators = [
  ...valueOperators,
  ...arrayOperators,
  ...stringOperators
];
function createBuilder(columns) {
  function col(name) {
    const out = columns[name];
    if (!out) throw new Error(`[FumaDB] Invalid column name ${String(name)}`);
    return out;
  }
  const builder = (...args) => {
    if (args.length === 3) {
      const [a, operator, b] = args;
      if (!operators.includes(operator))
        throw new Error(`Unsupported operator: ${operator}`);
      return {
        type: 2 /* Compare */,
        a: col(a),
        b,
        operator
      };
    }
    return {
      type: 2 /* Compare */,
      a: col(args[0]),
      operator: "=",
      b: true
    };
  };
  builder.isNull = (a) => builder(a, "is", null);
  builder.isNotNull = (a) => builder(a, "is not", null);
  builder.not = (condition) => {
    if (typeof condition === "boolean") return !condition;
    return {
      type: 3 /* Not */,
      item: condition
    };
  };
  builder.or = (...conditions) => {
    const out = {
      type: 1 /* Or */,
      items: []
    };
    for (const item of conditions) {
      if (item === true) return true;
      if (item === false) continue;
      out.items.push(item);
    }
    if (out.items.length === 0) return false;
    return out;
  };
  builder.and = (...conditions) => {
    const out = {
      type: 0 /* And */,
      items: []
    };
    for (const item of conditions) {
      if (item === true) continue;
      if (item === false) return false;
      out.items.push(item);
    }
    if (out.items.length === 0) return true;
    return out;
  };
  return builder;
}
function buildCondition(columns, input) {
  return input(createBuilder(columns));
}

// src/query/orm/index.ts
function isOrderByArray(v) {
  return Array.isArray(v) && Array.isArray(v[0]);
}
function simplifyOrderBy(columns, orderBy) {
  if (!orderBy || orderBy.length === 0) return;
  if (!isOrderByArray(orderBy)) orderBy = [orderBy];
  return orderBy.map(([name, value]) => {
    const col = columns[name];
    if (!col) throw new Error(`[FumaDB] unknown column name ${name}.`);
    return [col, value];
  });
}
function buildFindOptions(table, { select = true, where, orderBy, join, ...options }) {
  let conditions = where ? buildCondition(table.columns, where) : void 0;
  if (conditions === true) conditions = void 0;
  if (conditions === false) return false;
  return {
    select,
    where: conditions,
    orderBy: simplifyOrderBy(table.columns, orderBy),
    join: join ? buildJoin(table, join) : void 0,
    ...options
  };
}
function buildJoin(table, fn) {
  const compiled = [];
  const builder = {};
  for (const name in table.relations) {
    const relation = table.relations[name];
    builder[name] = (options = {}) => {
      compiled.push({
        relation,
        options: buildFindOptions(relation.table, options)
      });
      delete builder[name];
      return builder;
    };
  }
  fn(builder);
  return compiled;
}
function toORM(adapter) {
  function toTable(name) {
    const table = adapter.tables[name];
    if (!table) throw new Error(`[FumaDB] Invalid table name ${name}.`);
    return table;
  }
  return {
    internal: adapter,
    async count(name, { where } = {}) {
      const table = toTable(name);
      let conditions = where ? buildCondition(table.columns, where) : void 0;
      if (conditions === true) conditions = void 0;
      if (conditions === false) return 0;
      return await adapter.count(table, {
        where: conditions
      });
    },
    async upsert(name, { where, ...options }) {
      const table = toTable(name);
      const conditions = where ? buildCondition(table.columns, where) : void 0;
      if (conditions === false) return;
      await adapter.upsert(table, {
        where: conditions === true ? void 0 : conditions,
        ...options
      });
    },
    async create(name, values) {
      const table = toTable(name);
      return await adapter.create(table, values);
    },
    async createMany(name, values) {
      const table = toTable(name);
      return await adapter.createMany(table, values);
    },
    async deleteMany(name, { where }) {
      const table = toTable(name);
      let conditions = where ? buildCondition(table.columns, where) : void 0;
      if (conditions === true) conditions = void 0;
      if (conditions === false) return;
      await adapter.deleteMany(table, { where: conditions });
    },
    async findMany(name, options = {}) {
      const table = toTable(name);
      const compiledOptions = buildFindOptions(
        table,
        options
      );
      if (compiledOptions === false) return [];
      return await adapter.findMany(table, compiledOptions);
    },
    async findFirst(name, options) {
      const table = toTable(name);
      const compiledOptions = buildFindOptions(
        table,
        options
      );
      if (compiledOptions === false) return null;
      return await adapter.findFirst(table, compiledOptions);
    },
    async updateMany(name, { set, where }) {
      const table = toTable(name);
      let conditions = where ? buildCondition(table.columns, where) : void 0;
      if (conditions === true) conditions = void 0;
      if (conditions === false) return;
      return adapter.updateMany(table, { set, where: conditions });
    },
    async transaction(run) {
      return adapter.transaction(run);
    }
  };
}

export {
  toORM
};
