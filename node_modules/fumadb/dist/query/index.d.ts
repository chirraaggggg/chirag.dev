import { a as AnyColumn, b as AnyTable, c as AnyRelation, A as AnySchema, R as Relation, I as IdColumn } from '../index-DHGqocp-.js';

declare enum ConditionType {
    And = 0,
    Or = 1,
    Compare = 2,
    Not = 3
}
type Condition = {
    type: ConditionType.Compare;
    a: AnyColumn;
    operator: Operator;
    b: AnyColumn | unknown | null;
} | {
    type: ConditionType.Or | ConditionType.And;
    items: Condition[];
} | {
    type: ConditionType.Not;
    item: Condition;
};
type ConditionBuilder<Columns extends Record<string, AnyColumn>> = {
    <ColName extends keyof Columns>(a: ColName, operator: (typeof valueOperators)[number] | (typeof stringOperators)[number], b: Columns[ColName]["$in"] | null): Condition;
    <ColName extends keyof Columns>(a: ColName, operator: (typeof arrayOperators)[number], b: Columns[ColName]["$in"][]): Condition;
    /**
     * Boolean values
     */
    <ColName extends keyof Columns>(a: ColName): Condition;
    and: (...v: (Condition | boolean)[]) => Condition | boolean;
    or: (...v: (Condition | boolean)[]) => Condition | boolean;
    not: (v: Condition | boolean) => Condition | boolean;
    isNull: (a: keyof Columns) => Condition;
    isNotNull: (a: keyof Columns) => Condition;
};
declare const stringOperators: readonly ["contains", "starts with", "ends with", "not contains", "not starts with", "not ends with"];
declare const arrayOperators: readonly ["in", "not in"];
declare const valueOperators: readonly ["=", "!=", ">", ">=", "<", "<=", "is", "is not"];
declare const operators: readonly ["=", "!=", ">", ">=", "<", "<=", "is", "is not", "in", "not in", "contains", "starts with", "ends with", "not contains", "not starts with", "not ends with"];
type Operator = (typeof operators)[number];

interface CompiledJoin {
    relation: AnyRelation;
    options: SimplifyFindOptions<FindManyOptions> | false;
}
interface SimplifiedCountOptions {
    where?: Condition | undefined;
}
type SimplifyFindOptions<O> = Omit<O, "where" | "orderBy" | "select" | "join"> & {
    select: AnySelectClause;
    where?: Condition | undefined;
    orderBy?: OrderBy<AnyColumn>[];
    join?: CompiledJoin[];
};
interface ORMAdapter {
    tables: Record<string, AnyTable>;
    count: (table: AnyTable, v: SimplifiedCountOptions) => Promise<number>;
    findFirst: (table: AnyTable, v: SimplifyFindOptions<FindFirstOptions>) => Promise<Record<string, unknown> | null>;
    findMany: (table: AnyTable, v: SimplifyFindOptions<FindManyOptions>) => Promise<Record<string, unknown>[]>;
    updateMany: (table: AnyTable, v: {
        where?: Condition;
        set: Record<string, unknown>;
    }) => Promise<void>;
    upsert: (table: AnyTable, v: {
        where: Condition | undefined;
        update: Record<string, unknown>;
        create: Record<string, unknown>;
    }) => Promise<void>;
    create: (table: AnyTable, values: Record<string, unknown>) => Promise<Record<string, unknown>>;
    createMany: (table: AnyTable, values: Record<string, unknown>[]) => Promise<{
        _id: unknown;
    }[]>;
    deleteMany: (table: AnyTable, v: {
        where?: Condition;
    }) => Promise<void>;
    /**
     * Override this to support native transaction, otherwise use soft transaction.
     */
    transaction: <T>(run: (transactionInstance: AbstractQuery<AnySchema>) => Promise<T>) => Promise<T>;
}

type AnySelectClause = SelectClause<AnyTable>;
type SelectClause<T extends AnyTable> = true | (keyof T["columns"])[];
type TableToColumnValues<T extends AnyTable> = {
    [K in keyof T["columns"]]: T["columns"][K]["$out"];
};
type PickNullable<T> = {
    [P in keyof T as null extends T[P] ? P : never]: T[P];
};
type PickNotNullable<T> = {
    [P in keyof T as null extends T[P] ? never : P]: T[P];
};
type TableToInsertValues<T extends AnyTable> = Partial<PickNullable<{
    [K in keyof T["columns"]]: T["columns"][K]["$in"];
}>> & PickNotNullable<{
    [K in keyof T["columns"]]: T["columns"][K]["$in"];
}>;
type TableToUpdateValues<T extends AnyTable> = {
    [K in keyof T["columns"]]?: T["columns"][K] extends IdColumn ? never : T["columns"][K]["$in"];
};
type MainSelectResult<S extends SelectClause<T>, T extends AnyTable> = S extends true ? TableToColumnValues<T> : S extends (keyof T["columns"])[] ? Pick<TableToColumnValues<T>, S[number]> : never;
type JoinBuilder<T extends AnyTable, Out = {}> = {
    [K in keyof T["relations"]]: T["relations"][K] extends Relation<infer Type, infer Target> ? <Select extends SelectClause<Target> = true, JoinOut = {}>(options?: Type extends "many" ? FindManyOptions<Target, Select, JoinOut, false> : FindFirstOptions<Target, Select, JoinOut, false>) => JoinBuilder<T, Out & {
        [$K in K]: MapRelationType<SelectResult<Target, JoinOut, Select>, T["relations"][K]["implied"]>[Type];
    }> : never;
};
type SelectResult<T extends AnyTable, JoinOut, Select extends SelectClause<T>> = MainSelectResult<Select, T> & JoinOut;
type OrderBy<Column = string> = [columnName: Column, "asc" | "desc"];
type FindFirstOptions<T extends AnyTable = AnyTable, Select extends SelectClause<T> = SelectClause<T>, JoinOut = {}, IsRoot extends boolean = true> = Omit<FindManyOptions<T, Select, JoinOut, IsRoot>, IsRoot extends true ? "limit" : "limit" | "offset" | "orderBy">;
interface MapRelationType<Type, Implied extends boolean> {
    one: Implied extends true ? Type | null : Type;
    many: Type[];
}
type FindManyOptions<T extends AnyTable = AnyTable, Select extends SelectClause<T> = SelectClause<T>, JoinOut = {}, IsRoot extends boolean = true> = {
    select?: Select;
    where?: (eb: ConditionBuilder<T["columns"]>) => Condition | boolean;
    limit?: number;
    orderBy?: OrderBy<keyof T["columns"]> | OrderBy<keyof T["columns"]>[];
    join?: (builder: JoinBuilder<T, {}>) => JoinBuilder<T, JoinOut>;
} & (IsRoot extends true ? {
    offset?: number;
} : {});
interface AbstractQuery<S extends AnySchema> {
    internal: ORMAdapter;
    /**
     * The code in the transaction will receive a transaction query instance.
     *
     * If you use that instance to write the database (e.g. insert) and an error is thrown, FumaDB will automatically rollback the changes + rethrow the error.
     *
     * It works by using the transaction API that's natively available for the database/ORM, or falling back to the soft transaction layer built by FumaDB.
     */
    transaction: <T>(run: (orm: AbstractQuery<S>) => Promise<T>) => Promise<T>;
    /**
     * Count (all)
     */
    count: <TableName extends keyof S["tables"]>(table: TableName, v?: {
        where?: (eb: ConditionBuilder<S["tables"][TableName]["columns"]>) => Condition | boolean;
    }) => Promise<number>;
    findFirst: <TableName extends keyof S["tables"], JoinOut = {}, Select extends SelectClause<S["tables"][TableName]> = true>(table: TableName, v: FindFirstOptions<S["tables"][TableName], Select, JoinOut>) => Promise<SelectResult<S["tables"][TableName], JoinOut, Select> | null>;
    findMany: <TableName extends keyof S["tables"], JoinOut = {}, Select extends SelectClause<S["tables"][TableName]> = true>(table: TableName, v?: FindManyOptions<S["tables"][TableName], Select, JoinOut>) => Promise<SelectResult<S["tables"][TableName], JoinOut, Select>[]>;
    /**
     * Upsert a **single row**.
     *
     * For ORMs:
     * - use built-in method whenever possible.
     *
     * Otherwise:
     * - run `update`.
     * - if updated zero rows, run `create`.
     */
    upsert: <TableName extends keyof S["tables"]>(table: TableName, v: {
        where: (eb: ConditionBuilder<S["tables"][TableName]["columns"]>) => Condition | boolean;
        update: TableToUpdateValues<S["tables"][TableName]>;
        create: TableToInsertValues<S["tables"][TableName]>;
    }) => Promise<void>;
    /**
     * Note: you cannot update the id of a row, some databases don't support that (including MongoDB).
     */
    updateMany: <TableName extends keyof S["tables"]>(table: TableName, v: {
        where?: (eb: ConditionBuilder<S["tables"][TableName]["columns"]>) => Condition | boolean;
        set: TableToUpdateValues<S["tables"][TableName]>;
    }) => Promise<void>;
    createMany: <TableName extends keyof S["tables"]>(table: TableName, values: TableToInsertValues<S["tables"][TableName]>[]) => Promise<{
        _id: string;
    }[]>;
    /**
     * Note: when you don't need to receive the result, always use `createMany` for better performance.
     */
    create: <TableName extends keyof S["tables"]>(table: TableName, values: TableToInsertValues<S["tables"][TableName]>) => Promise<TableToColumnValues<S["tables"][TableName]>>;
    deleteMany: <TableName extends keyof S["tables"]>(table: TableName, v: {
        where?: (eb: ConditionBuilder<S["tables"][TableName]["columns"]>) => Condition | boolean;
    }) => Promise<void>;
}

export type { AbstractQuery, AnySelectClause, FindFirstOptions, FindManyOptions, JoinBuilder, OrderBy, SelectClause };
