import {
  applyNameVariants
} from "./chunk-IVWNQO5P.js";
import {
  compileForeignKey,
  deepEqual,
  schema
} from "./chunk-N6RQRWGA.js";

// src/migration-engine/shared.ts
function isUpdated(op) {
  return op.updateDataType || op.updateDefault || op.updateNullable;
}

// src/migration-engine/auto-from-schema.ts
function generateMigrationFromSchema(old, schema2, options) {
  const {
    provider,
    relationMode = provider === "mssql" || provider === "mongodb" ? "fumadb" : "foreign-keys",
    dropUnusedTables = true,
    dropUnusedColumns = true
  } = options;
  function getName(names) {
    return provider === "mongodb" ? names.mongodb : names.sql;
  }
  function columnActionToOperation(tableName, actions) {
    if (actions.length === 0) return [];
    if (provider === "mysql" || provider === "postgresql" || provider === "mongodb") {
      return [
        {
          type: "update-table",
          name: tableName,
          value: actions
        }
      ];
    }
    return actions.map((action) => ({
      type: "update-table",
      name: tableName,
      value: [action]
    }));
  }
  function onUniqueConstraintCheck(prev, next) {
    const operations = [];
    const newConstraints = next.getUniqueConstraints();
    const oldConstraints = prev.getUniqueConstraints();
    for (const con of newConstraints) {
      const oldCon = oldConstraints.find((item) => item.name === con.name);
      const columnNames = con.columns.map((col) => getName(col.names));
      if (!oldCon) {
        operations.push({
          type: "add-unique-constraint",
          name: con.name,
          table: getName(next.names),
          columns: columnNames
        });
        continue;
      }
      if (deepEqual(
        columnNames,
        oldCon.columns.map((col) => getName(col.names))
      ))
        continue;
      operations.push(
        {
          type: "drop-unique-constraint",
          table: getName(next.names),
          name: con.name
        },
        {
          type: "add-unique-constraint",
          table: getName(next.names),
          name: con.name,
          columns: columnNames
        }
      );
    }
    for (const con of oldConstraints) {
      const isUnused = newConstraints.every((item) => item.name !== con.name);
      if (isUnused)
        operations.push({
          type: "drop-unique-constraint",
          table: getName(next.names),
          name: con.name
        });
    }
    return operations;
  }
  function onTableRenameCheck(oldTable, newTable) {
    const operations = [];
    if (getName(newTable.names) !== getName(oldTable.names)) {
      operations.push({
        type: "rename-table",
        from: getName(oldTable.names),
        to: getName(newTable.names),
        enforce: "pre"
      });
    }
    return operations;
  }
  function onTableColumnsCheck(oldTable, newTable) {
    const colActions = [];
    for (const column of Object.values(newTable.columns)) {
      let hashDefaultValue2 = function(col) {
        if (!col.default || "runtime" in col.default) return;
        if (col.type === "string" && provider === "mysql") return;
        return col.default.value;
      };
      var hashDefaultValue = hashDefaultValue2;
      const oldColumn = oldTable.columns[column.ormName];
      if (!oldColumn) {
        colActions.push({
          type: "create-column",
          value: column
        });
        continue;
      }
      if (getName(column.names) !== getName(oldColumn.names)) {
        colActions.push({
          type: "rename-column",
          from: getName(oldColumn.names),
          to: getName(column.names)
        });
      }
      const action = {
        type: "update-column",
        name: getName(column.names),
        updateDataType: column.type !== oldColumn.type,
        updateDefault: !deepEqual(
          hashDefaultValue2(column),
          hashDefaultValue2(oldColumn)
        ),
        updateNullable: column.isNullable !== oldColumn.isNullable,
        value: column
      };
      if (isUpdated(action)) colActions.push(action);
    }
    return columnActionToOperation(getName(newTable.names), colActions);
  }
  function onTableForeignKeyCheck(oldTable, newTable) {
    const tableName = getName(newTable.names);
    const operations = [];
    if (relationMode === "fumadb") return operations;
    for (const foreignKey of newTable.foreignKeys) {
      const compiled = compileForeignKey(foreignKey, "sql");
      const oldKey = oldTable.foreignKeys.find(
        (key) => key.name === foreignKey.name
      );
      if (!oldKey) {
        operations.push({
          type: "add-foreign-key",
          table: tableName,
          value: compiled,
          enforce: "post"
        });
        continue;
      }
      const isUpdated2 = !deepEqual(compiled, compileForeignKey(oldKey, "sql"));
      if (isUpdated2) {
        operations.push(
          {
            type: "drop-foreign-key",
            name: oldKey.name,
            table: tableName,
            enforce: "post"
          },
          {
            type: "add-foreign-key",
            table: tableName,
            value: compiled,
            enforce: "post"
          }
        );
      }
    }
    return operations;
  }
  function onTableUnusedForeignKeyCheck(oldTable, newTable) {
    const operations = [];
    for (const oldKey of oldTable.foreignKeys) {
      const isUnused = newTable.foreignKeys.every(
        (key) => key.name !== oldKey.name
      );
      if (!isUnused) continue;
      operations.push({
        type: "drop-foreign-key",
        name: oldKey.name,
        table: getName(oldTable.names),
        enforce: "pre"
      });
    }
    return operations;
  }
  function onTableUnusedColumnsCheck(oldTable, newTable) {
    const constraints = newTable.getUniqueConstraints();
    const operations = [];
    for (const oldColumn of Object.values(oldTable.columns)) {
      const isUnused = !newTable.columns[oldColumn.ormName];
      const isRequired = !oldColumn.isNullable && !oldColumn.default;
      const shouldDrop = isUnused && (dropUnusedColumns || isRequired);
      if (!shouldDrop) continue;
      if (provider === "mssql" && oldColumn.isUnique) {
        for (const con of constraints) {
          if (con.columns.every((col) => col.ormName !== oldColumn.ormName))
            continue;
          operations.push({
            type: "drop-unique-constraint",
            name: con.name,
            table: getName(newTable.names)
          });
        }
      }
      operations.push({
        type: "update-table",
        name: getName(newTable.names),
        value: [{ type: "drop-column", name: getName(oldColumn.names) }],
        enforce: "post"
      });
    }
    return operations;
  }
  function reorder(operations) {
    const out = [];
    for (const item of operations) {
      if (item.enforce === "pre") out.push(item);
    }
    for (const item of operations) {
      if (!item.enforce) out.push(item);
    }
    for (const item of operations) {
      if (item.enforce === "post") out.push(item);
    }
    return out;
  }
  function generate() {
    const operations = [];
    for (const table of Object.values(schema2.tables)) {
      const oldTable = old.tables[table.ormName];
      if (!oldTable) {
        operations.push({
          type: "create-table",
          value: table
        });
        continue;
      }
      operations.push(
        ...onTableUnusedForeignKeyCheck(oldTable, table),
        ...onTableRenameCheck(oldTable, table),
        ...onTableColumnsCheck(oldTable, table),
        ...onUniqueConstraintCheck(oldTable, table),
        ...onTableForeignKeyCheck(oldTable, table),
        ...onTableUnusedColumnsCheck(oldTable, table)
      );
    }
    for (const oldTable of Object.values(old.tables)) {
      if (!schema2.tables[oldTable.ormName] && dropUnusedTables) {
        operations.push({
          type: "drop-table",
          name: getName(oldTable.names),
          enforce: "post"
        });
      }
    }
    return reorder(operations);
  }
  return generate();
}

// src/migration-engine/create.ts
import { parse } from "semver";
function createMigrator({
  settings,
  generateMigrationFromDatabase,
  generateMigrationFromSchema: generateMigrationFromSchema2 = generateMigrationFromSchema,
  libConfig: { schemas, initialVersion = "0.0.0" },
  userConfig,
  executor,
  sql: sqlConfig,
  transformers = []
}) {
  const indexedSchemas = /* @__PURE__ */ new Map();
  indexedSchemas.set(
    initialVersion,
    schema({
      version: initialVersion,
      tables: {}
    })
  );
  for (const schema2 of schemas) {
    if (indexedSchemas.has(schema2.version))
      throw new Error(`Duplicated version: ${schema2.version}`);
    indexedSchemas.set(schema2.version, schema2);
  }
  function getSchemaByVersion(version) {
    const schema2 = indexedSchemas.get(version);
    if (!schema2) throw new Error(`Invalid version ${version}`);
    return schema2;
  }
  async function getCurrentSchema() {
    const version = await settings.getVersion() ?? initialVersion;
    const nameVariants = await settings.getNameVariants();
    let schema2 = getSchemaByVersion(version);
    if (nameVariants) schema2 = applyNameVariants(schema2, nameVariants);
    return schema2;
  }
  function getSchemasOfVariant(variant) {
    return schemas.filter(
      (schema2) => deepEqual(parse(schema2.version).prerelease, variant)
    );
  }
  const instance = {
    getVersion() {
      return settings.getVersion();
    },
    getNameVariants() {
      return settings.getNameVariants();
    },
    async next() {
      const version = await settings.getVersion() ?? initialVersion;
      const list = getSchemasOfVariant(parse(version).prerelease);
      const index = list.findIndex((schema2) => schema2.version === version);
      return list[index + 1];
    },
    async previous() {
      const version = await settings.getVersion();
      if (!version) return;
      const list = getSchemasOfVariant(parse(version).prerelease);
      const index = list.findIndex((schema2) => schema2.version === version);
      return list[index - 1];
    },
    async up(options = {}) {
      const next = await this.next();
      if (!next) throw new Error("Already up to date.");
      return this.migrateTo(next.version, options);
    },
    async down(options = {}) {
      const prev = await this.previous();
      if (!prev) throw new Error("No previous schema to migrate to.");
      return this.migrateTo(prev.version, options);
    },
    async migrateTo(version, options = {}) {
      const {
        updateSettings: updateVersion = true,
        unsafe = false,
        mode = "from-schema"
      } = options;
      const targetSchema = getSchemaByVersion(version);
      const currentSchema = await getCurrentSchema();
      let run;
      const prevVariant = parse(targetSchema.version).prerelease;
      const variant = parse(currentSchema.version).prerelease;
      if (deepEqual(prevVariant, variant)) {
        const list = getSchemasOfVariant(variant);
        const targetIdx = list.indexOf(targetSchema);
        switch (currentSchema.version) {
          case list[targetIdx - 1]?.version:
            run = targetSchema.up;
            break;
          case list[targetIdx + 1]?.version:
            run = targetSchema.down;
            break;
        }
      }
      run ??= (context2) => context2.auto();
      const context = {
        async auto() {
          let generated;
          if (mode === "from-schema") {
            generated = generateMigrationFromSchema2(
              currentSchema,
              targetSchema,
              userConfig
            );
          } else {
            if (!generateMigrationFromDatabase)
              throw new Error(`${mode} is not supported for this adapter.`);
            generated = await generateMigrationFromDatabase({
              target: targetSchema,
              dropUnusedColumns: unsafe
            });
          }
          for (const transformer of transformers) {
            if (!transformer.afterAuto) continue;
            generated = transformer.afterAuto(generated, {
              prev: currentSchema,
              next: targetSchema,
              options
            });
          }
          return generated;
        }
      };
      let operations = await run(context);
      if (updateVersion) {
        operations.push(
          ...await settings.updateSettingsInMigration(targetSchema)
        );
      }
      for (const transformer of transformers) {
        if (!transformer.afterAll) continue;
        operations = transformer.afterAll(operations, {
          prev: currentSchema,
          next: targetSchema
        });
      }
      return {
        operations,
        getSQL: sqlConfig ? () => sqlConfig.toSql(operations) : void 0,
        execute: () => executor(operations)
      };
    },
    async migrateToLatest(options) {
      const version = await settings.getVersion() ?? initialVersion;
      const last = getSchemasOfVariant(parse(version).prerelease).at(-1);
      if (!last) throw new Error(`Cannot find other schemas`);
      return this.migrateTo(last.version, options);
    }
  };
  return instance;
}

// src/schema/export.ts
function exportNameVariants(schema2) {
  const out = {};
  for (const table of Object.values(schema2.tables)) {
    out[table.ormName] = table.names;
    for (const col of Object.values(table.columns)) {
      out[`${table.ormName}.${col.ormName}`] = col.names;
    }
  }
  return out;
}

export {
  isUpdated,
  generateMigrationFromSchema,
  createMigrator,
  exportNameVariants
};
