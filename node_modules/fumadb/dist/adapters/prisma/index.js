import {
  parseVarchar
} from "../../chunk-GUE4GMNC.js";
import {
  checkForeignKeyOnInsert
} from "../../chunk-ZOCGSAWS.js";
import {
  toORM
} from "../../chunk-PK2W2SQ7.js";
import {
  Column,
  IdColumn,
  column,
  idColumn,
  table
} from "../../chunk-N6RQRWGA.js";

// src/adapters/prisma/query.ts
function buildWhere(condition) {
  if (condition.type === 2 /* Compare */) {
    const column2 = condition.a;
    const value = condition.b;
    const name = column2.names.prisma;
    if (value instanceof Column) {
      throw new Error(
        "Prisma adapter does not support comparing against another column at the moment."
      );
    }
    switch (condition.operator) {
      case "=":
      case "is":
        return { [name]: value };
      case "!=":
      case "is not":
        return { [name]: { not: value } };
      case ">":
        return { [name]: { gt: value } };
      case ">=":
        return { [name]: { gte: value } };
      case "<":
        return { [name]: { lt: value } };
      case "<=":
        return { [name]: { lte: value } };
      case "in":
        return { [name]: { in: value } };
      case "not in":
        return { [name]: { notIn: value } };
      case "starts with":
        return { [name]: { startsWith: value } };
      case "not starts with":
        return { NOT: { [name]: { startsWith: value } } };
      case "contains":
        return { [name]: { contains: value } };
      case "not contains":
        return { NOT: { [name]: { contains: value } } };
      case "ends with":
        return { [name]: { endsWith: value } };
      case "not ends with":
        return { NOT: { [name]: { endsWith: value } } };
      default:
        throw new Error(`Unsupported operator: ${condition.operator}`);
    }
  }
  if (condition.type === 0 /* And */) {
    return {
      AND: condition.items.map(buildWhere)
    };
  }
  if (condition.type === 3 /* Not */) {
    return {
      NOT: condition
    };
  }
  return {
    OR: condition.items.map(buildWhere)
  };
}
function mapSelect(select, table2) {
  const out = {};
  if (select === true) {
    for (const col of Object.values(table2.columns)) {
      out[col.names.prisma] = true;
    }
  } else {
    for (const col of select) {
      out[table2.columns[col].names.prisma] = true;
    }
  }
  return out;
}
function mapOrderBy(orderBy) {
  const out = {};
  for (const [col, mode] of orderBy) {
    out[col.names.prisma] = mode;
  }
  return out;
}
function mapResult(result, table2) {
  const out = {};
  for (const k in result) {
    const value = result[k];
    if (k in table2.relations) {
      const relation = table2.relations[k];
      if (relation.type === "many") {
        out[k] = value.map(
          (v) => mapResult(v, relation.table)
        );
      } else {
        out[k] = value ? mapResult(value, relation.table) : null;
      }
      continue;
    }
    const col = table2.getColumnByName(k, "prisma");
    if (col) out[col.ormName] = value;
  }
  return out;
}
function fromPrisma(schema, config) {
  const {
    provider,
    prisma,
    relationMode = provider === "mongodb" ? "prisma" : "foreign-keys",
    db: internalClient,
    isTransaction = false
  } = config;
  async function initMongoDB() {
    if (!internalClient || isTransaction) return;
    const db = internalClient.db();
    async function initCollection(table2) {
      const collection = db.collection(table2.names.mongodb);
      const indexes = await collection.indexes();
      for (const index of indexes) {
        if (!index.unique || !index.name || index.sparse) continue;
        await collection.dropIndex(index.name);
        await collection.createIndex(index.key, {
          name: index.name,
          unique: true,
          sparse: true
        });
      }
    }
    await Promise.all(Object.values(schema.tables).map(initCollection));
  }
  const init = initMongoDB();
  function createFindOptions(table2, v) {
    const where = v.where ? buildWhere(v.where) : void 0;
    const select = mapSelect(v.select, table2);
    if (v.join) {
      for (const { relation, options: joinOptions } of v.join) {
        if (joinOptions === false) continue;
        select[relation.name] = createFindOptions(relation.table, joinOptions);
      }
    }
    return {
      where,
      select,
      skip: v.offset,
      take: v.limit,
      orderBy: v.orderBy ? mapOrderBy(v.orderBy) : void 0
    };
  }
  function mapValues(table2, values, generateDefault = false) {
    const out = {};
    for (const col of Object.values(table2.columns)) {
      let value = values[col.ormName];
      if (value === void 0 && generateDefault)
        value = col.generateDefaultValue();
      out[col.names.prisma] = value;
    }
    return out;
  }
  return toORM({
    tables: schema.tables,
    async count(table2, v) {
      await init;
      return (await prisma[table2.names.prisma].count({
        select: {
          _all: true
        },
        where: v.where ? buildWhere(v.where) : void 0
      }))._all;
    },
    async findFirst(table2, v) {
      await init;
      const options = createFindOptions(table2, v);
      delete options.take;
      const result = await prisma[table2.names.prisma].findFirst({
        ...options,
        where: options.where
      });
      if (result) return mapResult(result, table2);
      return null;
    },
    async findMany(table2, v) {
      await init;
      return (await prisma[table2.names.prisma].findMany(createFindOptions(table2, v))).map((v2) => mapResult(v2, table2));
    },
    async updateMany(table2, v) {
      await init;
      const where = v.where ? buildWhere(v.where) : void 0;
      await prisma[table2.names.prisma].updateMany({ where, data: v.set });
    },
    async create(table2, values) {
      await init;
      if (relationMode === "prisma") {
        await Promise.all(
          table2.foreignKeys.map(
            (key) => checkForeignKeyOnInsert(this, key, [values])
          )
        );
      }
      values = mapValues(table2, values, true);
      return mapResult(
        await prisma[table2.names.prisma].create({
          data: values
        }),
        table2
      );
    },
    async createMany(table2, values) {
      await init;
      const idField = table2.getIdColumn().names.prisma;
      if (relationMode === "prisma") {
        await Promise.all(
          table2.foreignKeys.map(
            (key) => checkForeignKeyOnInsert(this, key, values)
          )
        );
      }
      values = values.map((value) => mapValues(table2, value, true));
      await prisma[table2.names.prisma].createMany({ data: values });
      return values.map((value) => ({ _id: value[idField] }));
    },
    async deleteMany(table2, v) {
      await init;
      const where = v.where ? buildWhere(v.where) : void 0;
      await prisma[table2.names.prisma].deleteMany({ where });
    },
    async upsert(table2, { where, ...v }) {
      await init;
      await prisma[table2.names.prisma].upsert({
        where: where ? buildWhere(where) : {},
        create: mapValues(table2, v.create, true),
        update: mapValues(table2, v.update)
      });
    },
    async transaction(run) {
      await init;
      return prisma.$transaction(
        (tx) => run(
          fromPrisma(schema, {
            ...config,
            isTransaction: true,
            prisma: tx
          })
        )
      );
    }
  });
}

// src/adapters/prisma/generate.ts
var foreignKeyActionMap = {
  "SET NULL": "SetNull",
  CASCADE: "Cascade",
  RESTRICT: "Restrict"
};
function generateSchema(schema, provider) {
  function generateTable(table2) {
    const code = [`model ${table2.names.prisma} {`];
    for (const column2 of Object.values(table2.columns)) {
      let map2 = function(name) {
        if (column2.names.prisma === name) return;
        attributes.push(`@map("${name}")`);
      };
      var map = map2;
      let type;
      const attributes = [];
      map2(provider === "mongodb" ? column2.names.mongodb : column2.names.sql);
      switch (column2.type) {
        case "integer":
          type = "Int";
          break;
        case "bigint":
          type = "BigInt";
          break;
        case "bool":
          type = "Boolean";
          break;
        case "json":
          type = "Json";
          break;
        case "timestamp":
        case "date":
          type = "DateTime";
          break;
        case "decimal":
          type = "Decimal";
          break;
        case "binary":
          type = "Bytes";
          break;
        default:
          type = "String";
          if (column2.type.startsWith("varchar")) {
            const parsed = parseVarchar(column2.type);
            switch (provider) {
              case "cockroachdb":
                attributes.push(`@db.String(${parsed})`);
                break;
              case "mysql":
              case "postgresql":
              case "mssql":
                attributes.push(`@db.VarChar(${parsed})`);
                break;
            }
          }
      }
      if (column2 instanceof IdColumn) {
        attributes.push("@id");
      }
      if (column2.isUnique) {
        attributes.push("@unique");
      }
      if (column2.default) {
        if ("value" in column2.default) {
          attributes.push(`@default(${JSON.stringify(column2.default.value)})`);
        } else if (column2.default.runtime === "auto") {
          attributes.push("@default(cuid())");
        } else if (column2.default.runtime === "now") {
          attributes.push("@default(now())");
        }
      }
      if (column2.isNullable) {
        type += "?";
      }
      code.push(`  ${[column2.names.prisma, type, ...attributes].join(" ")}`);
    }
    for (const relation of Object.values(table2.relations)) {
      let type = relation.table.names.prisma;
      if (relation.implied) {
        if (relation.type === "many") type += "[]";
        else type += "?";
        code.push(`  ${relation.name} ${type} @relation("${relation.id}")`);
        continue;
      }
      const fields = [];
      const references = [];
      let isOptional = false;
      for (const [left, right] of relation.on) {
        const col = table2.columns[left];
        const refCol = relation.table.columns[right];
        if (col.isNullable) isOptional = true;
        fields.push(col.names.prisma);
        references.push(refCol.names.prisma);
      }
      if (isOptional) type += "?";
      const config = relation.foreignKey;
      code.push(
        `  ${relation.name} ${type} @relation(${[
          `"${relation.id}"`,
          `fields: [${fields.join(", ")}]`,
          `references: [${references.join(", ")}]`,
          `onUpdate: ${foreignKeyActionMap[config.onUpdate]}`,
          `onDelete: ${foreignKeyActionMap[config.onDelete]}`
        ].join(", ")})`
      );
    }
    for (const con of table2.getUniqueConstraints("table")) {
      code.push(
        `@@unique([${con.columns.map((col) => col.names.prisma).join(", ")}])`
      );
    }
    function mapTable(name) {
      if (table2.names.prisma === name) return;
      code.push(`@@map("${name}")`);
    }
    mapTable(provider === "mongodb" ? table2.names.mongodb : table2.names.sql);
    code.push("}");
    return code.join("\n");
  }
  const lines = [];
  for (const t of Object.values(schema.tables)) {
    lines.push(generateTable(t));
  }
  return lines.join("\n\n");
}

// src/adapters/prisma/index.ts
function prismaAdapter(options) {
  const config = options;
  const settingsModel = (namespace) => `private_${namespace}_settings`;
  return {
    name: "prisma",
    createORM(schema) {
      return fromPrisma(schema, config);
    },
    async getSchemaVersion() {
      const prisma = config.prisma;
      const settings = settingsModel(this.namespace);
      if (!(settings in prisma)) return;
      await prisma[settings].deleteMany({
        where: {
          key: "version"
        }
      });
      const result = await prisma[settings].create({
        data: {
          key: "version"
        }
      });
      return result.value;
    },
    generateSchema(schema, name) {
      const settings = settingsModel(this.namespace);
      const internalTable = table(settings, {
        key: idColumn("key", "varchar(255)"),
        value: column("value", "string").defaultTo(schema.version)
      });
      internalTable.ormName = settings;
      return {
        code: generateSchema(
          {
            ...schema,
            tables: {
              ...schema.tables,
              [settings]: internalTable
            }
          },
          config.provider
        ),
        path: `./prisma/schema/${name}.prisma`
      };
    }
  };
}
export {
  prismaAdapter
};
