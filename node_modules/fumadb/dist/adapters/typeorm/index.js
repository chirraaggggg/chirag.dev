import {
  importGenerator
} from "../../chunk-LHHP6UVP.js";
import {
  ident,
  parseVarchar
} from "../../chunk-GUE4GMNC.js";
import {
  kyselyAdapter
} from "../../chunk-SW3NYCJ4.js";
import {
  schemaToDBType
} from "../../chunk-46SBL45L.js";
import "../../chunk-CAEEQPOK.js";
import "../../chunk-ZOCGSAWS.js";
import "../../chunk-IVWNQO5P.js";
import "../../chunk-PK2W2SQ7.js";
import {
  IdColumn
} from "../../chunk-N6RQRWGA.js";

// src/adapters/typeorm/generate.ts
function toPascalCase(str) {
  return str.split("_").map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join("");
}
function generateSchema(schema, provider) {
  const code = [];
  const imports = importGenerator();
  imports.addImport("Entity", "typeorm");
  function generateTable(table) {
    const lines = [];
    const className = toPascalCase(table.names.sql);
    lines.push(`@Entity("${table.names.sql}")`);
    lines.push(`export class ${className} {`);
    for (const [key, column] of Object.entries(table.columns)) {
      const options = [];
      let type;
      switch (column.type) {
        case "integer":
          type = "number";
          break;
        case "bigint":
          type = "bigint";
          break;
        case "bool":
          type = "boolean";
          break;
        case "json":
          type = "object";
          break;
        case "timestamp":
        case "date":
          type = "Date";
          break;
        case "decimal":
          type = "number";
          break;
        case "binary":
          type = "Uint8Array";
          options.push(
            `type: "${schemaToDBType({ type: "binary" }, provider)}"`
          );
          break;
        default:
          type = "string";
          if (column.type.startsWith("varchar")) {
            const length = parseVarchar(column.type);
            if (length) {
              options.push(`length: ${length}`);
            }
          }
      }
      let decorator = "Column";
      if (column instanceof IdColumn) {
        decorator = column.default && "runtime" in column.default && column.default.runtime === "auto" ? "PrimaryGeneratedColumn" : "PrimaryColumn";
      }
      if (key !== column.names.sql) {
        options.push(`name: "${column.names.sql}"`);
      }
      if (column.isNullable) {
        type += " | null";
        options.push(`nullable: true`);
      }
      if (column.isUnique) {
        options.push(`unique: true`);
      }
      if (column.default) {
        if ("value" in column.default) {
          options.push(`default: ${JSON.stringify(column.default.value)}`);
        } else if (column.default.runtime === "now") {
          options.push("default: () => 'CURRENT_TIMESTAMP'");
        }
      }
      let arg = "";
      if (options.length > 0) {
        arg = `{
${ident(options.join(",\n"))}
}`;
      }
      imports.addImport(decorator, "typeorm");
      lines.push(ident(`@${decorator}(${arg})`));
      lines.push(`  ${key}: ${type};`);
      lines.push("");
    }
    for (const k in table.relations) {
      let buildJoinColumn2 = function() {
        imports.addImport("JoinColumn", "typeorm");
        const args2 = [];
        for (const [left, right] of relation.on) {
          args2.push(`{ name: "${left}", referencedColumnName: "${right}" }`);
        }
        return `  @JoinColumn([${args2.join(", ")}])`;
      };
      var buildJoinColumn = buildJoinColumn2;
      const relation = table.relations[k];
      if (!relation) continue;
      let decorator;
      const className2 = toPascalCase(relation.table.ormName);
      const args = [`() => ${className2}`];
      let type = className2;
      if (relation.implied) {
        if (relation.type === "many") {
          decorator = "OneToMany";
          type += "[]";
        } else decorator = "OneToOne";
        args.push(`v => v.${relation.impliedBy?.name}`);
      } else {
        if (relation.implying?.type === "many") decorator = "ManyToOne";
        else decorator = "OneToOne";
        args.push(`v => v.${relation.implying?.name}`);
        lines.push(buildJoinColumn2());
        const config = relation.foreignKey;
        if (config) {
          args.push(
            `{ onUpdate: "${config.onUpdate}", onDelete: "${config.onDelete}" }`
          );
        }
      }
      imports.addImport(decorator, "typeorm");
      lines.push(`  @${decorator}(${args.join(", ")})`);
      lines.push(`  ${relation.name}: ${type}`);
      lines.push("");
    }
    lines.pop();
    lines.push("}");
    return lines.join("\n");
  }
  for (const table of Object.values(schema.tables)) {
    code.push(generateTable(table));
  }
  code.unshift(imports.format());
  return code.join("\n\n");
}

// src/adapters/typeorm/index.ts
import {
  PostgresAdapter,
  PostgresIntrospector,
  PostgresQueryCompiler,
  MysqlAdapter,
  MysqlIntrospector,
  MysqlQueryCompiler,
  MssqlAdapter,
  MssqlIntrospector,
  MssqlQueryCompiler,
  SqliteAdapter,
  SqliteIntrospector,
  SqliteQueryCompiler,
  Kysely
} from "kysely";
import { KyselyTypeORMDialect } from "kysely-typeorm";
function typeormAdapter(options) {
  const kysely = getKysely(options.source, options.provider);
  return {
    ...kyselyAdapter({
      db: kysely,
      provider: options.provider
    }),
    name: "typeorm",
    generateSchema(schema, name) {
      return {
        code: generateSchema(schema, options.provider),
        path: `./models/${name}.ts`
      };
    }
  };
}
function getKysely(source, provider) {
  let subDialect;
  if (provider === "postgresql") {
    subDialect = {
      createAdapter: () => new PostgresAdapter(),
      createIntrospector: (db) => new PostgresIntrospector(db),
      createQueryCompiler: () => new PostgresQueryCompiler()
    };
  } else if (provider === "mysql") {
    subDialect = {
      createAdapter: () => new MysqlAdapter(),
      createIntrospector: (db) => new MysqlIntrospector(db),
      createQueryCompiler: () => new MysqlQueryCompiler()
    };
  } else if (provider === "mssql") {
    subDialect = {
      createAdapter: () => new MssqlAdapter(),
      createIntrospector: (db) => new MssqlIntrospector(db),
      createQueryCompiler: () => new MssqlQueryCompiler()
    };
  } else {
    subDialect = {
      createAdapter: () => new SqliteAdapter(),
      createIntrospector: (db) => new SqliteIntrospector(db),
      createQueryCompiler: () => new SqliteQueryCompiler()
    };
  }
  return new Kysely({
    dialect: new KyselyTypeORMDialect({
      kyselySubDialect: subDialect,
      typeORMDataSource: source
    })
  });
}
export {
  typeormAdapter
};
