import {
  createMigrator,
  exportNameVariants
} from "../../chunk-CAEEQPOK.js";
import {
  createSoftForeignKey
} from "../../chunk-ZOCGSAWS.js";
import "../../chunk-IVWNQO5P.js";
import {
  toORM
} from "../../chunk-PK2W2SQ7.js";
import {
  Column,
  IdColumn
} from "../../chunk-N6RQRWGA.js";

// src/adapters/mongodb/query.ts
import {
  Binary,
  ObjectId
} from "mongodb";
function buildWhere(condition) {
  function doc(name, op, value) {
    switch (op) {
      case "=":
      case "is":
        if (value == null) return { [name]: { $exists: false } };
        return { [name]: value };
      case "!=":
      case "is not":
        if (value == null) return { [name]: { $exists: true } };
        return { [name]: { $ne: value } };
      case ">":
        return { [name]: { $gt: value } };
      case ">=":
        return { [name]: { $gte: value } };
      case "<":
        return { [name]: { $lt: value } };
      case "<=":
        return { [name]: { $lte: value } };
      case "in":
        return { [name]: { $in: value } };
      case "not in":
        return { [name]: { $nin: value } };
      case "starts with":
        return { [name]: { $regex: `^${value}`, $options: "i" } };
      case "not starts with":
        return { [name]: { $not: { $regex: `^${value}`, $options: "i" } } };
      case "contains":
        return { [name]: { $regex: value, $options: "i" } };
      case "not contains":
        return { [name]: { $not: { $regex: value, $options: "i" } } };
      case "ends with":
        return { [name]: { $regex: `${value}$`, $options: "i" } };
      case "not ends with":
        return { [name]: { $not: { $regex: `${value}$`, $options: "i" } } };
      default:
        throw new Error(`Unsupported operator: ${op}`);
    }
  }
  function expr(exp1, op, exp2) {
    switch (op) {
      case "=":
      case "is":
        return { $eq: [exp1, exp2] };
      case "!=":
      case "is not":
        return { $ne: [exp1, exp2] };
      case ">":
        return { $gt: [exp1, exp2] };
      case ">=":
        return { $gte: [exp1, exp2] };
      case "<":
        return { $lt: [exp1, exp2] };
      case "<=":
        return { $lte: [exp1, exp2] };
      case "in":
        return { $in: [exp1, exp2] };
      case "not in":
        return { $nin: [exp1, exp2] };
      case "starts with":
        return {
          $regexMatch: {
            input: exp1,
            regex: `^${exp2}`,
            options: "i"
          }
        };
      case "not starts with":
        return {
          $not: [expr(exp1, "starts with", exp2)]
        };
      case "contains":
        return {
          $regexMatch: {
            input: exp1,
            regex: exp2,
            options: "i"
          }
        };
      case "not contains":
        return {
          $not: [expr(exp1, "contains", exp2)]
        };
      case "ends with":
        return {
          $regexMatch: {
            input: exp1,
            regex: `${exp2}$`,
            options: "i"
          }
        };
      case "not ends with":
        return {
          $not: [expr(exp1, "ends with", exp2)]
        };
      default:
        throw new Error(`Unsupported operator: ${op}`);
    }
  }
  if (condition.type === 2 /* Compare */) {
    const column = condition.a;
    const value = condition.b;
    const name = column.names.mongodb;
    if (value instanceof Column) {
      return {
        $match: expr(
          `$${name}`,
          condition.operator,
          column.table === value.table ? `$${value.names.mongodb}` : `$$${value.table?.ormName}_${value.ormName}`
        )
      };
    }
    return doc(name, condition.operator, serialize(value));
  }
  if (condition.type === 0 /* And */) {
    return {
      $and: condition.items.map(buildWhere)
    };
  }
  if (condition.type === 3 /* Not */) {
    return {
      $not: buildWhere(condition)
    };
  }
  return {
    $or: condition.items.map(buildWhere)
  };
}
function mapProjection(select, table) {
  const out = {
    _id: 0
  };
  function item(col) {
    out[col.ormName] = { $ifNull: [`$${col.names.mongodb}`, null] };
  }
  if (select === true) {
    for (const col of Object.values(table.columns)) item(col);
  } else {
    for (const k of select) {
      const col = table.columns[k];
      if (!col) continue;
      item(col);
    }
  }
  return out;
}
function mapSort(orderBy) {
  const out = {};
  for (const [col, mode] of orderBy) {
    out[col.names.mongodb] = mode === "asc" ? 1 : -1;
  }
  return out;
}
function serialize(value) {
  if (value instanceof Uint8Array) {
    value = new Binary(value);
  }
  return value;
}
function mapInsertValues(values, table) {
  const out = {};
  for (const k in table.columns) {
    const col = table.columns[k];
    const value = serialize(values[k]);
    if (value != null) out[col.names.mongodb] = value;
  }
  return out;
}
function mapResult(result, table) {
  const out = {};
  for (const k in result) {
    let value = result[k];
    if (k in table.relations) {
      const relation = table.relations[k];
      if (Array.isArray(value)) {
        value = value.map((v) => mapResult(v, relation.table));
      } else if (value) {
        value = mapResult(value, relation.table);
      }
      out[k] = value;
      continue;
    }
    if (value instanceof ObjectId) {
      value = value.toString("hex");
    } else if (value instanceof Binary) {
      const buffer = value.buffer;
      value = buffer instanceof Buffer ? new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength) : buffer;
    }
    out[k] = value;
  }
  return out;
}
function fromMongoDB(schema, client, session) {
  const db = client.db();
  function buildFindPipeline(table, v) {
    const pipeline = [];
    const where = v.where ? buildWhere(v.where) : void 0;
    if (where) pipeline.push({ $match: where });
    if (v.limit !== void 0)
      pipeline.push({
        $limit: v.limit
      });
    if (v.offset !== void 0)
      pipeline.push({
        $skip: v.offset
      });
    if (v.orderBy) {
      pipeline.push({ $sort: mapSort(v.orderBy) });
    }
    const project = mapProjection(v.select, table);
    if (v.join) {
      for (const { relation, options: joinOptions } of v.join) {
        project[relation.name] = 1;
        if (joinOptions === false) continue;
        const vars = {};
        for (const column of Object.values(table.columns)) {
          vars[`${table.ormName}_${column.ormName}`] = `$${column.names.mongodb}`;
        }
        const targetTable = relation.table;
        pipeline.push({
          $lookup: {
            from: targetTable.names.mongodb,
            let: vars,
            pipeline: [
              ...relation.on.map(([left, right]) => {
                return {
                  $match: {
                    $expr: {
                      $eq: [
                        `$${targetTable.columns[right].names.mongodb}`,
                        `$$${table.ormName}_${left}`
                      ]
                    }
                  }
                };
              }),
              ...buildFindPipeline(targetTable, {
                ...joinOptions,
                limit: relation.type === "many" ? joinOptions.limit : 1
              })
            ],
            as: relation.name
          }
        });
        if (relation.type === "one") {
          pipeline.push({
            $set: {
              [relation.name]: {
                $ifNull: [{ $first: `$${relation.name}` }, null]
              }
            }
          });
        }
      }
    }
    pipeline.push({
      $project: project
    });
    return pipeline;
  }
  const orm = createSoftForeignKey(schema, {
    generateInsertValuesDefault(table, values) {
      const out = {};
      for (const k in table.columns) {
        if (values[k] === void 0) {
          out[k] = table.columns[k].generateDefaultValue();
        } else {
          out[k] = values[k];
        }
      }
      return out;
    },
    tables: schema.tables,
    async count(table, { where }) {
      return await db.collection(table.names.mongodb).countDocuments(where ? buildWhere(where) : void 0, { session });
    },
    async findFirst(table, v) {
      const result = await orm.findMany(table, {
        ...v,
        limit: 1
      });
      return result[0] ?? null;
    },
    async findMany(table, v) {
      const query = db.collection(table.names.mongodb).aggregate(buildFindPipeline(table, v), { session });
      const result = await query.toArray();
      return result.map((v2) => mapResult(v2, table));
    },
    async updateMany(table, v) {
      const where = v.where ? buildWhere(v.where) : {};
      const set = {};
      const unset = {};
      for (const k in v.set) {
        const col = table.columns[k];
        const value = v.set[k];
        if (!col || value === void 0) continue;
        const name = col.names.mongodb;
        if (value === null) {
          unset[name] = "";
        } else {
          set[name] = serialize(value);
        }
      }
      await db.collection(table.names.mongodb).updateMany(
        where,
        {
          $set: set,
          $unset: unset
        },
        {
          session
        }
      );
    },
    async create(table, values) {
      const collection = db.collection(table.names.mongodb);
      const { insertedId } = await collection.insertOne(
        mapInsertValues(values, table),
        { session }
      );
      const result = await collection.findOne(
        {
          _id: insertedId
        },
        {
          session,
          projection: mapProjection(true, table)
        }
      );
      if (result === null)
        throw new Error(
          "Failed to insert document: cannot find inserted coument."
        );
      return mapResult(result, table);
    },
    async createMany(table, values) {
      const idField = table.getIdColumn().names.mongodb;
      values = values.map((v) => mapInsertValues(v, table));
      await db.collection(table.names.mongodb).insertMany(values, { session });
      return values.map((value) => ({ _id: value[idField] }));
    },
    async deleteMany(table, v) {
      const where = v.where ? buildWhere(v.where) : void 0;
      await db.collection(table.names.mongodb).deleteMany(where, { session });
    },
    async transaction(run) {
      const child = client.startSession();
      try {
        return await child.withTransaction(
          () => run(fromMongoDB(schema, client, child)),
          {
            session
          }
        );
      } finally {
        await child.endSession();
      }
    }
  });
  return toORM(orm);
}

// src/adapters/mongodb/migration/execute.ts
import {
  Binary as Binary2,
  ObjectId as ObjectId2
} from "mongodb";

// src/utils/binary.ts
function bigintToUint8Array(bigint) {
  let hex = bigint.toString(16);
  if (hex.length % 2) {
    hex = `0${hex}`;
  }
  return Buffer.from(hex, "hex");
}
function uint8ArrayToBigInt(arr) {
  const hex = Array.from(arr).map((b) => b.toString(16).padStart(2, "0")).join("");
  return BigInt(`0x${hex}`);
}
function stringToUint8Array(str) {
  const encoder = new TextEncoder();
  return encoder.encode(str);
}
function uint8ArrayToString(arr) {
  const decoder = new TextDecoder();
  return decoder.decode(arr);
}
function booleanToUint8Array(bool) {
  return new Uint8Array([bool ? 1 : 0]);
}
function uint8ArrayToBoolean(arr) {
  return arr[0] !== 0;
}
function numberToUint8Array(num) {
  const buf = Buffer.alloc(8);
  buf.writeDoubleBE(num);
  return new Uint8Array(buf);
}
function uint8ArrayToNumber(arr) {
  const buf = Buffer.from(arr);
  return buf.readDoubleBE(0);
}

// src/adapters/mongodb/migration/execute.ts
var errors = {
  IdColumnUpdate: "ID columns must not be updated, not every database supports updating primary keys and often requires workarounds."
};
async function createUniqueIndex(collection, name, columns) {
  const idx = {};
  for (const col of columns) {
    idx[col] = 1;
  }
  await collection.createIndex(idx, {
    name,
    unique: true,
    sparse: true
  });
}
async function executeColumn(collection, operation, config) {
  const { session } = config;
  switch (operation.type) {
    case "rename-column":
      await collection.updateMany(
        {},
        { $rename: { [operation.from]: operation.to } },
        { session }
      );
      return;
    case "drop-column": {
      if (operation.name === "_id")
        throw new Error("You cannot drop `_id` column");
      const indexes = await collection.indexes();
      for (const index of indexes) {
        if (!index.name || !index.unique || index.key[operation.name] !== 1)
          continue;
        await collection.dropIndex(index.name);
        break;
      }
      await collection.updateMany(
        {},
        { $unset: { [operation.name]: "" } },
        { session }
      );
      return;
    }
    case "create-column": {
      const col = operation.value;
      const defaultValue = col.generateDefaultValue() ?? null;
      if (defaultValue) {
        await collection.updateMany(
          { [col.names.mongodb]: { $exists: false } },
          { $set: { [col.names.mongodb]: defaultValue } },
          { session }
        );
      }
      return;
    }
    // do not handle nullable & default update as they're handled at application level
    case "update-column": {
      const col = operation.value;
      if (col instanceof IdColumn) {
        throw new Error(errors.IdColumnUpdate);
      }
      if (operation.updateDataType) {
        const field = operation.name;
        const bulk = collection.initializeUnorderedBulkOp();
        for await (const doc of collection.find()) {
          bulk.find({ _id: doc._id }).updateOne({
            $set: { [field]: migrateDataType(doc[field], col.type) }
          });
        }
        if (bulk.batches.length > 0) await bulk.execute();
      }
    }
  }
}
async function execute(operation, config, handleCustomNode) {
  const { client, session } = config;
  const db = client.db();
  async function createCollection(table) {
    const collection = await db.createCollection(table.names.mongodb);
    for (const col of Object.values(table.columns)) {
      if (!col.isUnique) continue;
      await createUniqueIndex(collection, col.getUniqueConstraintName(), [
        col.names.sql
      ]);
    }
  }
  switch (operation.type) {
    case "create-table":
      await createCollection(operation.value);
      return true;
    case "rename-table":
      await db.collection(operation.from).rename(operation.to, { session });
      return true;
    case "update-table": {
      const collection2 = db.collection(operation.name);
      for (const op of operation.value) {
        await executeColumn(collection2, op, config);
      }
      return true;
    }
    case "add-unique-constraint": {
      const collection2 = db.collection(operation.table);
      await createUniqueIndex(collection2, operation.name, operation.columns);
      return true;
    }
    case "drop-table":
      await db.collection(operation.name).drop({ session });
      return true;
    case "custom":
      await handleCustomNode(operation);
      return true;
    case "drop-unique-constraint":
      const collection = db.collection(operation.table);
      await collection.dropIndex(operation.name);
      return true;
    case "add-foreign-key":
    case "drop-foreign-key":
      return false;
  }
}
function migrateDataType(originalValue, toType) {
  if (toType.startsWith("varchar(")) toType = "string";
  if (originalValue instanceof ObjectId2)
    originalValue = originalValue.toHexString();
  if (originalValue == null) return originalValue;
  if (toType === "bigint") {
    if (originalValue instanceof Binary2) {
      return uint8ArrayToBigInt(originalValue.buffer);
    }
    if (originalValue instanceof Date) return BigInt(originalValue.getTime());
    switch (typeof originalValue) {
      case "bigint":
        return originalValue;
      case "boolean":
        return originalValue ? 1n : 0n;
      case "number":
      case "string":
        return BigInt(originalValue);
      default:
        throw new Error(`Failed to convert ${originalValue} to ${toType}.`);
    }
  }
  if (toType === "bool") {
    if (originalValue instanceof Binary2) {
      return uint8ArrayToBoolean(originalValue.buffer);
    }
    switch (typeof originalValue) {
      case "boolean":
        return originalValue;
      case "bigint":
        return originalValue !== 0n;
      case "number":
        return originalValue !== 0;
      case "string":
        return originalValue.toLowerCase() === "true";
      default:
        throw new Error(`Failed to convert ${originalValue} to ${toType}.`);
    }
  }
  if (toType === "binary") {
    if (originalValue instanceof Binary2) return originalValue;
    if (originalValue instanceof Date) originalValue = originalValue.getTime();
    switch (typeof originalValue) {
      case "bigint":
        return new Binary2(bigintToUint8Array(originalValue));
      case "string":
        return new Binary2(stringToUint8Array(originalValue));
      case "number":
        return new Binary2(numberToUint8Array(originalValue));
      case "boolean":
        return new Binary2(booleanToUint8Array(originalValue));
      default:
        throw new Error(`Failed to convert ${originalValue} to ${toType}.`);
    }
  }
  if (toType === "date" || toType === "timestamp") {
    if (originalValue instanceof Binary2)
      return new Date(uint8ArrayToNumber(originalValue.buffer));
    if (originalValue instanceof Date) return originalValue;
    switch (typeof originalValue) {
      case "bigint":
        return new Date(Number(originalValue));
      case "string":
      case "number":
        return new Date(originalValue);
      default:
        throw new Error(`Failed to convert ${originalValue} to ${toType}.`);
    }
  }
  if (toType === "decimal" || toType === "integer") {
    if (originalValue instanceof Binary2)
      return uint8ArrayToNumber(originalValue.buffer);
    if (originalValue instanceof Date) return originalValue.getTime();
    switch (typeof originalValue) {
      case "bigint":
      case "string":
      case "number":
        return Number(originalValue);
      case "boolean":
        return originalValue ? 1 : 0;
      default:
        throw new Error(`Failed to convert ${originalValue} to ${toType}.`);
    }
  }
  if (toType === "json") return originalValue;
  if (toType === "string") {
    if (originalValue instanceof Binary2)
      return uint8ArrayToString(originalValue.buffer);
    switch (typeof originalValue) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        return String(originalValue);
      default:
        return JSON.stringify(originalValue);
    }
  }
}

// src/adapters/mongodb/index.ts
function mongoAdapter(options) {
  return {
    name: "mongodb",
    createORM(schema) {
      return fromMongoDB(schema, options.client);
    },
    createMigrationEngine() {
      return createMongoDBMigrator(this, options.client);
    },
    async getSchemaVersion() {
      const manager = createSettingsManager(this, options.client);
      return await manager.get("version");
    }
  };
}
function createMongoDBMigrator(lib, client) {
  const manager = createSettingsManager(lib, client);
  return createMigrator({
    ...lib,
    libConfig: lib,
    userConfig: {
      provider: "mongodb"
    },
    settings: {
      async getVersion() {
        const result = await manager.get("version");
        if (typeof result === "string") return result;
      },
      async getNameVariants() {
        const result = await manager.get("name-variants");
        if (result) return result;
      },
      updateSettingsInMigration(schema) {
        return [
          {
            type: "custom",
            key: "version",
            value: schema.version
          },
          {
            type: "custom",
            key: "name-variants",
            value: exportNameVariants(schema)
          }
        ];
      }
    },
    async executor(operations) {
      const session = client.startSession();
      try {
        for (const op of operations) {
          await execute(
            op,
            { client, session },
            (node) => manager.set(node.key, node.value)
          ).catch((e) => {
            console.error("failed at", op, e);
            throw e;
          });
        }
      } finally {
        await session.endSession();
      }
    }
  });
}
function createSettingsManager(lib, client) {
  const db = client.db();
  const collection = db.collection(`private_${lib.namespace}_settings`);
  return {
    async get(key) {
      const result = await collection.findOne({
        key
      });
      return result?.value;
    },
    async set(key, value) {
      const result = await collection.updateOne(
        {
          key
        },
        { $set: { value } }
      );
      if (result.matchedCount === 0) {
        await collection.insertOne({ key, value });
      }
    }
  };
}
export {
  mongoAdapter
};
