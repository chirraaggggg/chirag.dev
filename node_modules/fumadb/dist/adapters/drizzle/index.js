import {
  importGenerator
} from "../../chunk-LHHP6UVP.js";
import {
  ident,
  parseVarchar
} from "../../chunk-GUE4GMNC.js";
import {
  schemaToDBType
} from "../../chunk-46SBL45L.js";
import {
  toORM
} from "../../chunk-PK2W2SQ7.js";
import {
  Column,
  IdColumn,
  column,
  idColumn,
  table
} from "../../chunk-N6RQRWGA.js";

// src/adapters/drizzle/query.ts
import * as Drizzle from "drizzle-orm";

// src/adapters/drizzle/shared.ts
function parseDrizzle(drizzle) {
  const db = drizzle;
  const drizzleTables = db._.fullSchema;
  if (!drizzleTables || Object.keys(drizzleTables).length === 0)
    throw new Error(
      "[fumadb] Drizzle adapter requires query mode, make sure to configure it following their guide: https://orm.drizzle.team/docs/rqb."
    );
  return [db, drizzleTables];
}

// src/adapters/drizzle/query.ts
function buildWhere(toDrizzle, condition) {
  if (condition.type === 2 /* Compare */) {
    const left = toDrizzle(condition.a);
    const op = condition.operator;
    let right = condition.b;
    if (right instanceof Column) right = toDrizzle(right);
    let inverse = false;
    switch (op) {
      case "=":
        return Drizzle.eq(left, right);
      case "!=":
        return Drizzle.ne(left, right);
      case ">":
        return Drizzle.gt(left, right);
      case ">=":
        return Drizzle.gte(left, right);
      case "<":
        return Drizzle.lt(left, right);
      case "<=":
        return Drizzle.lte(left, right);
      case "in": {
        return Drizzle.inArray(left, right);
      }
      case "not in":
        return Drizzle.notInArray(left, right);
      case "is":
        return right === null ? Drizzle.isNull(left) : Drizzle.eq(left, right);
      case "is not":
        return right === null ? Drizzle.isNotNull(left) : Drizzle.ne(left, right);
      case "not contains":
        inverse = true;
      case "contains":
        right = typeof right === "string" ? `%${right}%` : Drizzle.sql`concat('%', ${right}, '%')`;
        return inverse ? (
          // @ts-expect-error -- skip type check
          Drizzle.notLike(left, right)
        ) : (
          // @ts-expect-error -- skip type check
          Drizzle.like(left, right)
        );
      case "not ends with":
        inverse = true;
      case "ends with":
        right = typeof right === "string" ? `%${right}` : Drizzle.sql`concat('%', ${right})`;
        return inverse ? (
          // @ts-expect-error -- skip type check
          Drizzle.notLike(left, right)
        ) : (
          // @ts-expect-error -- skip type check
          Drizzle.like(left, right)
        );
      case "not starts with":
        inverse = true;
      case "starts with":
        right = typeof right === "string" ? `${right}%` : Drizzle.sql`concat(${right}, '%')`;
        return inverse ? (
          // @ts-expect-error -- skip type check
          Drizzle.notLike(left, right)
        ) : (
          // @ts-expect-error -- skip type check
          Drizzle.like(left, right)
        );
      default:
        throw new Error(`Unsupported operator: ${op}`);
    }
  }
  if (condition.type === 0 /* And */)
    return Drizzle.and(
      ...condition.items.map((item) => buildWhere(toDrizzle, item))
    );
  if (condition.type === 3 /* Not */) {
    const result = buildWhere(toDrizzle, condition.item);
    if (!result) return;
    return Drizzle.not(result);
  }
  return Drizzle.or(
    ...condition.items.map((item) => buildWhere(toDrizzle, item))
  );
}
function mapValues(values, table2) {
  const out = {};
  for (const column2 of Object.values(table2.columns)) {
    out[column2.names.drizzle] = values[column2.ormName];
  }
  return out;
}
function mapQueryResult(table2, result) {
  const out = {};
  for (const k in result) {
    const value = result[k];
    if (k in table2.relations) {
      const relation = table2.relations[k];
      if (relation.type === "many") {
        out[k] = value.map(
          (v) => mapQueryResult(relation.table, v)
        );
        continue;
      }
      out[k] = value ? mapQueryResult(relation.table, value) : null;
      continue;
    }
    const col = table2.getColumnByName(k, "drizzle");
    if (!col) continue;
    out[col.ormName] = value;
  }
  return out;
}
function fromDrizzle(schema, _db, provider) {
  const [db, drizzleTables] = parseDrizzle(_db);
  function toDrizzle(v) {
    const out = drizzleTables[v.names.drizzle];
    if (out) return out;
    throw new Error(
      `[FumaDB Drizzle] Unknown table name ${v.names.drizzle}, is it included in your Drizzle schema?`
    );
  }
  function toDrizzleColumn(v) {
    const table2 = toDrizzle(v.table);
    const out = table2[v.names.drizzle];
    if (out) return out;
    throw new Error(
      `[FumaDB Drizzle] Unknown column name ${v.names.drizzle} in ${v.table.names.drizzle}.`
    );
  }
  function buildQueryConfig(table2, options) {
    const columns = {};
    const select = options.select;
    if (select === true) {
      for (const col of Object.values(table2.columns)) {
        columns[col.names.drizzle] = true;
      }
    } else {
      for (const k of select) {
        columns[table2.columns[k].names.drizzle] = true;
      }
    }
    const out = {
      columns,
      limit: options.limit,
      offset: options.offset,
      where: options.where ? buildWhere(toDrizzleColumn, options.where) : void 0,
      orderBy: options.orderBy?.map(
        ([item, mode]) => mode === "asc" ? Drizzle.asc(toDrizzleColumn(item)) : Drizzle.desc(toDrizzleColumn(item))
      )
    };
    if (options.join) {
      out.with = {};
      for (const join of options.join) {
        if (join.options === false) continue;
        out.with[join.relation.name] = buildQueryConfig(
          join.relation.table,
          join.options
        );
      }
    }
    return out;
  }
  return toORM({
    tables: schema.tables,
    async count(table2, v) {
      return await db.$count(
        toDrizzle(table2),
        v.where ? buildWhere(toDrizzleColumn, v.where) : void 0
      );
    },
    async findFirst(table2, v) {
      const results = await this.findMany(table2, {
        ...v,
        limit: 1
      });
      return results[0] ?? null;
    },
    async upsert(table2, v) {
      const idField = table2.getIdColumn().names.drizzle;
      const drizzleTable = toDrizzle(table2);
      let query = db.select({ id: drizzleTable[idField] }).from(drizzleTable).limit(1);
      if (v.where) {
        query = query.where(buildWhere(toDrizzleColumn, v.where));
      }
      const targetIds = await query.execute();
      if (targetIds.length > 0) {
        await db.update(drizzleTable).set(mapValues(v.update, table2)).where(Drizzle.eq(drizzleTable[idField], targetIds[0].id));
      } else {
        await this.createMany(table2, [v.create]);
      }
    },
    async findMany(table2, v) {
      return (await db.query[table2.names.drizzle].findMany(buildQueryConfig(table2, v))).map((v2) => mapQueryResult(table2, v2));
    },
    async updateMany(table2, v) {
      const drizzleTable = toDrizzle(table2);
      let query = db.update(drizzleTable).set(mapValues(v.set, table2));
      if (v.where) {
        query = query.where(buildWhere(toDrizzleColumn, v.where));
      }
      await query;
    },
    async create(table2, values) {
      const idField = table2.getIdColumn().names.drizzle;
      const drizzleTable = toDrizzle(table2);
      values = mapValues(values, table2);
      const returning = {};
      for (const column2 of Object.values(table2.columns)) {
        returning[column2.ormName] = drizzleTable[column2.names.drizzle];
      }
      if (provider === "sqlite" || provider === "postgresql") {
        const result = await db.insert(drizzleTable).values(values).returning(returning);
        return result[0];
      }
      const obj = (await db.insert(drizzleTable).values(values).$returningId())[0];
      return (await db.select(returning).from(drizzleTable).where(Drizzle.eq(drizzleTable[idField], obj[idField])).limit(1))[0];
    },
    async createMany(table2, values) {
      const idField = table2.getIdColumn().names.drizzle;
      const drizzleTable = toDrizzle(table2);
      values = values.map((v) => mapValues(v, table2));
      if (provider === "sqlite" || provider === "postgresql") {
        return await db.insert(drizzleTable).values(values).returning({
          _id: drizzleTable[idField]
        });
      }
      const results = await db.insert(drizzleTable).values(values).$returningId();
      return results.map((result) => ({ _id: result[idField] }));
    },
    async deleteMany(table2, v) {
      const drizzleTable = toDrizzle(table2);
      let query = db.delete(drizzleTable);
      if (v.where) {
        query = query.where(buildWhere(toDrizzleColumn, v.where));
      }
      await query;
    },
    transaction(run) {
      return db.transaction((tx) => run(fromDrizzle(schema, tx, provider)));
    }
  });
}

// src/adapters/drizzle/generate.ts
function generateSchema(schema, provider) {
  const imports = importGenerator();
  const importSource = {
    mysql: "drizzle-orm/mysql-core",
    postgresql: "drizzle-orm/pg-core",
    sqlite: "drizzle-orm/sqlite-core"
  }[provider];
  const tableFn = {
    mysql: "mysqlTable",
    postgresql: "pgTable",
    sqlite: "sqliteTable"
  }[provider];
  const generatedCustomTypes = /* @__PURE__ */ new Set();
  function generateCustomType(name, options) {
    if (generatedCustomTypes.has(name)) return;
    imports.addImport("customType", importSource);
    generatedCustomTypes.add(name);
    return `const ${name} = customType<
  {
    data: ${options.dataType};
    driverData: ${options.driverDataType};
  }
>({
  dataType() {
    return "${options.databaseDataType}";
  },
  fromDriver(value) {
    ${options.fromDriverCode}
  },
  toDriver(value) {
    ${options.toDriverCode}
  }
});`;
  }
  function generateBinary() {
    const name = "customBinary";
    const code = generateCustomType(name, {
      dataType: "Uint8Array",
      driverDataType: "Buffer",
      databaseDataType: schemaToDBType({ type: "binary" }, provider),
      fromDriverCode: "return new Uint8Array(value.buffer, value.byteOffset, value.byteLength)",
      toDriverCode: `return value instanceof Buffer? value : Buffer.from(value)`
    });
    if (code) lines.push(code);
    return name;
  }
  function getColumnTypeFunction(column2) {
    if (provider === "sqlite") {
      switch (column2.type) {
        case "bigint":
          return {
            name: "blob",
            params: [`{ mode: "bigint" }`]
          };
        case "bool":
          return {
            name: "integer",
            params: [`{ mode: "boolean" }`]
          };
        case "json":
          return { name: "blob", params: [`{ mode: "json" }`] };
        // for sqlite, generate dates as a timestamp
        case "timestamp":
        case "date":
          return { name: "integer", params: [`{ mode: "timestamp" }`] };
        case "decimal":
          return { name: "real" };
      }
    }
    switch (column2.type) {
      case "string":
        return { name: "text" };
      case "binary":
        return {
          name: generateBinary(),
          isCustomType: true
        };
      case "bool":
        return { name: "boolean" };
      default:
        if (column2.type.startsWith("varchar")) {
          return {
            name: provider === "sqlite" ? "text" : "varchar",
            params: [`{ length: ${parseVarchar(column2.type)} }`]
          };
        }
        return { name: column2.type };
    }
  }
  function generateTable(table2) {
    const cols = [];
    for (const column2 of Object.values(table2.columns)) {
      const col = [];
      const typeFn = getColumnTypeFunction(column2);
      const params = [
        `"${column2.names.sql}"`,
        ...typeFn.params ?? []
      ];
      if (!typeFn.isCustomType) imports.addImport(typeFn.name, importSource);
      col.push(`${typeFn.name}(${params.join(", ")})`);
      if (column2 instanceof IdColumn) {
        col.push("primaryKey()");
      }
      if (column2.isUnique) {
        col.push("unique()");
      }
      if (!column2.isNullable) {
        col.push("notNull()");
      }
      if (column2.default) {
        if ("value" in column2.default) {
          const value = JSON.stringify(column2.default.value);
          col.push(`default(${value})`);
        } else if (column2.default.runtime === "auto") {
          imports.addImport("createId", "fumadb/cuid");
          col.push("$defaultFn(() => createId())");
        } else if (column2.default.runtime === "now") {
          col.push("defaultNow()");
        }
      }
      cols.push(`  ${column2.names.drizzle}: ${col.join(".")}`);
    }
    const args = [`"${table2.names.sql}"`];
    args.push(`{
${cols.join(",\n")}
}`);
    const keys = [];
    for (const key of table2.foreignKeys) {
      const referencedTable = key.referencedTable;
      const columns = key.columns.map((col) => `table.${col.names.drizzle}`);
      const foreignColumns = key.referencedColumns.map(
        (col) => `${referencedTable.names.drizzle}.${col.names.drizzle}`
      );
      imports.addImport("foreignKey", importSource);
      let code = `foreignKey({
  columns: [${columns.join(", ")}],
  foreignColumns: [${foreignColumns.join(", ")}],
  name: "${key.name}"
})`;
      if (key?.onUpdate) code += `.onUpdate("${key.onUpdate.toLowerCase()}")`;
      if (key?.onDelete) code += `.onDelete("${key.onDelete.toLowerCase()}")`;
      keys.push(code);
    }
    for (const con of table2.getUniqueConstraints("table")) {
      imports.addImport("uniqueIndex", importSource);
      keys.push(
        `uniqueIndex("${con.name}").on(${con.columns.map((col) => `table.${col.names.drizzle}`).join(", ")})`
      );
    }
    if (keys.length > 0)
      args.push(`(table) => [
${ident(keys.join(",\n"))}
]`);
    return `export const ${table2.names.drizzle} = ${tableFn}(${args.join(", ")})`;
  }
  function generateRelation(table2) {
    const cols = [];
    for (const relation of Object.values(table2.relations)) {
      const options = [`relationName: "${relation.id}"`];
      if (!relation.implied || relation.type === "one") {
        const fields = [];
        const references = [];
        for (const [left, right] of relation.on) {
          fields.push(
            `${table2.names.drizzle}.${table2.columns[left].names.drizzle}`
          );
          references.push(
            `${relation.table.names.drizzle}.${relation.table.columns[right].names.drizzle}`
          );
        }
        options.push(
          `fields: [${fields.join(", ")}]`,
          `references: [${references.join(", ")}]`
        );
      }
      const args = [];
      args.push(relation.table.names.drizzle);
      if (options.length > 0) args.push(`{
${ident(options.join(",\n"))}
}`);
      cols.push(
        ident(`${relation.name}: ${relation.type}(${args.join(", ")})`)
      );
    }
    if (cols.length === 0) return;
    imports.addImport("relations", "drizzle-orm");
    return `export const ${table2.names.drizzle}Relations = relations(${table2.names.drizzle}, ({ one, many }) => ({
${cols.join(",\n")}
}));`;
  }
  imports.addImport(tableFn, importSource);
  const lines = [];
  for (const table2 of Object.values(schema.tables)) {
    lines.push(generateTable(table2));
    const relation = generateRelation(table2);
    if (relation) lines.push(relation);
  }
  lines.unshift(imports.format());
  return lines.join("\n\n");
}

// src/adapters/drizzle/index.ts
function drizzleAdapter(options) {
  const settingsTableName = (namespace) => `private_${namespace}_settings`;
  return {
    name: "drizzle",
    createORM(schema) {
      return fromDrizzle(schema, options.db, options.provider);
    },
    // assume the database is sync with Drizzle schema
    async getSchemaVersion() {
      const [_db, tables] = parseDrizzle(options.db);
      const table2 = tables[settingsTableName(this.namespace)];
      if (!table2) return;
      const col = table2["version"];
      if (!col) return;
      return col.default;
    },
    generateSchema(schema, schemaName) {
      const settings = settingsTableName(this.namespace);
      const internalTable = table(settings, {
        id: idColumn("id", "varchar(255)"),
        // use default value to save schema version
        version: column("version", "varchar(255)").defaultTo(schema.version)
      });
      internalTable.ormName = settings;
      return {
        code: generateSchema(
          {
            ...schema,
            tables: {
              ...schema.tables,
              [settings]: internalTable
            }
          },
          options.provider
        ),
        path: `./db/${schemaName}.ts`
      };
    }
  };
}
export {
  drizzleAdapter
};
