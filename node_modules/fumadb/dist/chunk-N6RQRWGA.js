// src/cuid.ts
import { createId } from "@paralleldrive/cuid2";

// src/utils/deep-equal.ts
function deepEqual(a, b) {
  if (a === b) return true;
  if (typeof a !== typeof b) return false;
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) {
      if (!deepEqual(a[i], b[i])) return false;
    }
    return true;
  }
  if (typeof a === "object" && typeof b === "object") {
    const aKeys = Object.keys(a);
    const bKeys = Object.keys(b);
    if (aKeys.length !== bKeys.length) return false;
    for (const key of aKeys) {
      if (!(key in b)) return false;
      if (!Object.hasOwn(b, key) || !deepEqual(a[key], b[key])) return false;
    }
    return true;
  }
  return false;
}

// src/schema/validate.ts
import { valid } from "semver";
function validateSchema(schema2) {
  if (!valid(schema2.version)) {
    throw new Error(`the version ${schema2.version} is invalid.`);
  }
  const tables = Object.values(schema2.tables);
  function validateForeignKey(key) {
    if (key.table === key.referencedTable && (key.onUpdate !== "RESTRICT" || key.onDelete !== "RESTRICT")) {
      throw new Error(
        `[${key.name}] Due to the limitations of MSSQL & Prisma MongoDB, you cannot specify other foreign key actions than "RESTRICT" for self-referencing foreign keys.`
      );
    }
    for (const col of key.columns) {
      if (!col.isNullable && (key.onUpdate === "SET NULL" || key.onDelete === "SET NULL")) {
        throw new Error(
          `[${key.name}] You are using "SET NULL" as foreign key action, but some columns are non-nullable.`
        );
      }
    }
  }
  function isCompositeColumnsUnique(table2, columns) {
    if (columns.length === 1 && columns[0] instanceof IdColumn) return true;
    const columnNames = columns.map((col) => col.ormName);
    for (const con of table2.getUniqueConstraints()) {
      if (deepEqual(
        con.columns.map((col) => col.ormName),
        columnNames
      ))
        return true;
    }
    return false;
  }
  function validateRelation(relation) {
    if (!relation.implied && !relation.foreignKey) {
      throw new Error(
        `[${relation.name}] You must define foreign key for explicit relations due the limitations of Prisma.`
      );
    }
    if (relation.implied) return;
    if (relation.implying?.type === "one" && !isCompositeColumnsUnique(
      relation.referencer,
      relation.on.map(([left]) => relation.referencer.columns[left])
    )) {
      throw new Error(
        `[${relation.name}] one-to-one relations require both sides to be unique or primary key.`
      );
    }
    if (!isCompositeColumnsUnique(
      relation.table,
      relation.on.map(([, right]) => relation.table.columns[right])
    ))
      throw new Error(
        `[${relation.name}] For any explicit relations, the referenced columns must be unique or primary key.`
      );
  }
  for (const table2 of tables) {
    for (const foreignKey of table2.foreignKeys) {
      validateForeignKey(foreignKey);
    }
    for (const relation of Object.values(table2.relations)) {
      validateRelation(relation);
    }
  }
}

// src/schema/create.ts
var RelationInit = class {
  type;
  referencedTable;
  referencer;
  constructor(type, referencedTable, referencer) {
    this.type = type;
    this.referencedTable = referencedTable;
    this.referencer = referencer;
  }
};
var ImplicitRelationInit = class extends RelationInit {
  init(ormName, impliedBy) {
    const output = {
      id: impliedBy.id,
      on: impliedBy.on.map(([left, right]) => [right, left]),
      type: this.type,
      table: this.referencedTable,
      implied: true,
      impliedBy,
      name: ormName,
      referencer: this.referencer
    };
    impliedBy.implying = output;
    return output;
  }
};
var ExplicitRelationInit = class extends RelationInit {
  foreignKeyConfig;
  implyingRelationName;
  on = [];
  imply(implyingRelationName) {
    this.implyingRelationName = implyingRelationName;
    return this;
  }
  initForeignKey(ormName) {
    const config = this.foreignKeyConfig;
    if (!config) return;
    const columns = [];
    const referencedColumns = [];
    for (const [left, right] of this.on) {
      columns.push(this.referencer.columns[left]);
      referencedColumns.push(this.referencedTable.columns[right]);
    }
    return {
      columns,
      referencedColumns,
      referencedTable: this.referencedTable,
      table: this.referencer,
      name: config.name ?? `${this.referencer.ormName}_${this.referencedTable.ormName}_${ormName}_fk`,
      onDelete: config.onDelete ?? "RESTRICT",
      onUpdate: config.onUpdate ?? "RESTRICT"
    };
  }
  init(ormName) {
    let id = `${this.referencer.ormName}_${this.referencedTable.ormName}`;
    if (this.implyingRelationName) id += `_${this.implyingRelationName}`;
    return {
      id,
      implied: false,
      foreignKey: this.initForeignKey(ormName),
      implying: void 0,
      on: this.on,
      name: ormName,
      referencer: this.referencer,
      table: this.referencedTable,
      type: this.type
    };
  }
  /**
   * Define foreign key for explicit relation, please note that:
   *
   * - this constraint is ignored for MongoDB (without Prisma).
   * - you **must** define foreign key for explicit relations, due to the limitations of Prisma.
   */
  foreignKey(config = {}) {
    this.foreignKeyConfig = config;
    return this;
  }
};
var Column = class _Column {
  type;
  ormName = "";
  isNullable = false;
  isUnique = false;
  default;
  table = void 0;
  initNames;
  get names() {
    return this.initNames(this.ormName);
  }
  set names(v) {
    this.initNames = () => v;
  }
  constructor(type, onInitNames) {
    this.type = type;
    this.initNames = onInitNames;
  }
  nullable(nullable) {
    this.isNullable = nullable ?? true;
    return this;
  }
  /**
   * Add unique constraint to the field, for consistency, duplicated null values are allowed.
   */
  unique(unique = true) {
    this.isUnique = unique;
    return this;
  }
  /**
   * Generate default value on runtime
   */
  defaultTo$(fn) {
    this.default = { runtime: fn };
    return this;
  }
  /**
   * Set a database-level default value
   *
   * For schemaless database, it's still generated on runtime
   */
  defaultTo(value) {
    this.default = { value };
    return this;
  }
  clone() {
    const clone = new _Column(this.type, () => this.names);
    clone.ormName = this.ormName;
    clone.isNullable = this.isNullable;
    clone.isUnique = this.isUnique;
    clone.default = this.default;
    clone.table = this.table;
    return clone;
  }
  getUniqueConstraintName() {
    return `unique_c_${this.table.ormName}_${this.ormName}`;
  }
  /**
   * Generate default value for the column on runtime.
   */
  generateDefaultValue() {
    if (!this.default) return;
    if ("value" in this.default) return this.default.value;
    if (this.default.runtime === "auto") return createId();
    if (this.default.runtime === "now")
      return new Date(Date.now());
    return this.default.runtime();
  }
  get $in() {
    throw new Error("Type inference only");
  }
  get $out() {
    throw new Error("Type inference only");
  }
};
var IdColumn = class _IdColumn extends Column {
  id = true;
  constructor(type, onInitNames) {
    super(type, (ormName) => ({
      ...onInitNames(ormName),
      mongodb: "_id"
    }));
  }
  clone() {
    const clone = new _IdColumn(this.type, () => this.names);
    clone.ormName = this.ormName;
    clone.isNullable = this.isNullable;
    clone.isUnique = this.isUnique;
    clone.default = this.default;
    clone.table = this.table;
    return clone;
  }
  defaultTo$(fn) {
    return super.defaultTo$(fn);
  }
  defaultTo(value) {
    return super.defaultTo(value);
  }
};
function column(name, type) {
  return new Column(
    type,
    (ormName) => typeof name === "string" ? nameVariants(name, ormName) : nameVariants(ormName, ormName, name)
  );
}
function idColumn(name, type) {
  return new IdColumn(
    type,
    (ormName) => typeof name === "string" ? nameVariants(name, ormName) : nameVariants(ormName, ormName, name)
  );
}
function relationBuilder(tables, k) {
  const referencer = tables[k];
  return {
    one(another, ...on) {
      if (on.length > 0) {
        const init = new ExplicitRelationInit(
          "one",
          tables[another],
          referencer
        );
        init.on = on;
        return init;
      }
      return new ImplicitRelationInit(
        "one",
        tables[another],
        referencer
      );
    },
    many(another) {
      return new ImplicitRelationInit("many", tables[another], referencer);
    }
  };
}
function table(name, columns) {
  let idCol;
  let names;
  const uniqueConstraints = [];
  const out = {
    ormName: "",
    get names() {
      if (names) return names;
      return typeof name === "string" ? nameVariants(name, out.ormName) : nameVariants(out.ormName, out.ormName, name);
    },
    set names(v) {
      names = v;
    },
    columns,
    relations: {},
    foreignKeys: [],
    getUniqueConstraints(level = "all") {
      const result = [];
      if (level === "all" || level === "table")
        result.push(...uniqueConstraints);
      if (level === "all" || level === "column") {
        for (const col of Object.values(this.columns)) {
          if (!col.isUnique) continue;
          result.push({
            name: col.getUniqueConstraintName(),
            columns: [col]
          });
        }
      }
      return result;
    },
    getColumnByName(name2, type = "sql") {
      return Object.values(this.columns).find((c) => c.names[type] === name2);
    },
    getIdColumn() {
      return idCol;
    },
    unique(name2, columns2) {
      uniqueConstraints.push({
        name: name2,
        columns: columns2.map((name3) => {
          const column2 = this.columns[name3];
          if (!column2)
            throw new Error(`Unknown column name ${name3.toString()}`);
          return column2;
        })
      });
      return this;
    },
    clone() {
      const cloneColumns = {};
      for (const [k, v] of Object.entries(columns)) {
        cloneColumns[k] = v.clone();
      }
      const clone = table(name, cloneColumns);
      for (const con of uniqueConstraints) {
        clone.unique(
          con.name,
          con.columns.map((col) => col.ormName)
        );
      }
      return clone;
    }
  };
  for (const k in columns) {
    const column2 = columns[k];
    if (!column2) {
      delete columns[k];
      continue;
    }
    column2.table = out;
    column2.ormName = k;
    if (column2 instanceof IdColumn) idCol = column2;
  }
  if (idCol === void 0) {
    throw new Error(`there's no id column in your table ${name}`);
  }
  return out;
}
function schema(config) {
  const { tables, relations } = config;
  for (const k in tables) {
    if (!tables[k]) {
      delete tables[k];
      continue;
    }
    tables[k].ormName = k;
  }
  if (relations) setRelations(tables, relations);
  const out = {
    ...config,
    tables: config.tables,
    clone() {
      const cloneTables = {};
      for (const [k, v] of Object.entries(tables)) {
        cloneTables[k] = v.clone();
      }
      return schema({
        ...config,
        tables: cloneTables
      });
    }
  };
  validateSchema(out);
  return out;
}
function setRelations(tables, relationsMap) {
  const impliedRelations = [];
  const explicitRelations = [];
  for (const k in relationsMap) {
    const relationFn = relationsMap[k];
    if (!relationFn) continue;
    const table2 = tables[k];
    const relations = relationFn(relationBuilder(tables, k));
    for (const name in relations) {
      const relation = relations[name];
      if (!relation) continue;
      if (relation instanceof ImplicitRelationInit) {
        impliedRelations.push({
          relationName: name,
          relation
        });
        continue;
      }
      if (relation instanceof ExplicitRelationInit) {
        const output = relation.init(name);
        explicitRelations.push({
          relation: output,
          implicitRelationName: relation.implyingRelationName
        });
        table2.relations[name] = output;
        if (output.foreignKey) table2.foreignKeys.push(output.foreignKey);
      }
    }
  }
  for (const { relation, relationName } of impliedRelations) {
    const referencer = relation.referencer;
    const explicits = explicitRelations.filter((item) => {
      if (item.implicitRelationName) {
        return item.implicitRelationName === relationName;
      }
      return item.relation.table === referencer && item.relation.referencer === relation.referencedTable;
    });
    if (explicits.length !== 1)
      throw new Error(
        `Cannot resolve implied relation ${relationName} in table "${relation.referencer.ormName}", you may want to specify \`imply()\` on the explicit relation.`
      );
    referencer.relations[relationName] = relation.init(
      relationName,
      explicits[0].relation
    );
  }
}
function variantSchema(variant, originalSchema, override) {
  const cloned = originalSchema.clone();
  const tables = cloned.tables;
  for (const [k, v] of Object.entries(override.tables)) {
    if (v == null) continue;
    tables[k] = v;
  }
  if (override.relations)
    setRelations(tables, override.relations);
  return schema({
    version: `${originalSchema.version}-${variant}`,
    tables,
    relations: override.relations
  });
}
function nameVariants(rawName, ormName, names) {
  return {
    convex: ormName,
    drizzle: ormName,
    prisma: ormName,
    mongodb: rawName,
    sql: rawName,
    ...names
  };
}
function compileForeignKey(key, name) {
  return {
    name: key.name,
    onUpdate: key.onUpdate,
    onDelete: key.onDelete,
    table: key.table.names[name],
    referencedTable: key.referencedTable.names[name],
    referencedColumns: key.referencedColumns.map((col) => col.names[name]),
    columns: key.columns.map((col) => col.names[name])
  };
}

export {
  deepEqual,
  ImplicitRelationInit,
  ExplicitRelationInit,
  Column,
  IdColumn,
  column,
  idColumn,
  table,
  schema,
  variantSchema,
  compileForeignKey
};
