interface ForeignKeyInfo {
    name: string;
    columns: string[];
    referencedTable: string;
    referencedColumns: string[];
    onUpdate: "RESTRICT" | "CASCADE" | "SET NULL";
    onDelete: "RESTRICT" | "CASCADE" | "SET NULL";
}
type MigrationOperation = TableOperation | {
    type: "add-foreign-key";
    table: string;
    value: ForeignKeyInfo;
} | {
    type: "drop-foreign-key";
    table: string;
    name: string;
} | {
    type: "drop-unique-constraint";
    table: string;
    name: string;
} | {
    type: "add-unique-constraint";
    table: string;
    columns: string[];
    name: string;
} | CustomOperation;
type CustomOperation = {
    type: "custom";
} & Record<string, unknown>;
type TableOperation = {
    type: "create-table";
    value: AnyTable;
} | {
    type: "drop-table";
    name: string;
} | {
    /**
     * Not supported by FumaDB
     * - update table's primary key
     */
    type: "update-table";
    name: string;
    value: ColumnOperation[];
} | {
    type: "rename-table";
    from: string;
    to: string;
};
type ColumnOperation = {
    type: "rename-column";
    from: string;
    to: string;
} | {
    type: "drop-column";
    name: string;
} | {
    /**
     * Note: unique constraints are not created, please use dedicated operations like `add-unique-constraint` instead
     */
    type: "create-column";
    value: AnyColumn;
} | {
    /**
     * warning: Not supported by SQLite
     */
    type: "update-column";
    name: string;
    /**
     * For databases like MySQL, it requires the full definition for any modify column statement.
     * Hence, you need to specify the full information of your column here.
     *
     * Then, opt-in for in-detail modification for other databases that supports changing data type/nullable/default separately, such as PostgreSQL.
     *
     * Note: unique constraints are not updated, please use dedicated operations like `add-unique-constraint` instead
     */
    value: AnyColumn;
    updateNullable: boolean;
    updateDefault: boolean;
    updateDataType: boolean;
};

type NameVariantsConfig = Record<string, Partial<NameVariants>>;
type BuildNameVariants<Tables extends Record<string, AnyTable>> = {
    [K in keyof Tables as K extends string ? keyof Tables[K]["columns"] extends string ? `${K}.${keyof Tables[K]["columns"]}` : never : never]?: Partial<NameVariants>;
} & {
    [k in keyof Tables]?: Partial<NameVariants>;
};
type NameVariantsBuilder<Schemas extends AnySchema[], Out> = {
    (variants: BuildNameVariants<Schemas[number]["tables"]>): Out;
    <Version extends Schemas[number]["version"]>(versions: Version[], variants: BuildNameVariants<Extract<Schemas[number], {
        version: Version;
    }>["tables"]>): Out;
    /**
     * Add prefix to table names.
     *
     * If true, use package's `namespace` as prefix.
     */
    prefix: (prefix: true | string) => Out;
};

type Awaitable<T> = T | Promise<T>;
interface MigrationContext {
    auto: () => Promise<MigrationOperation[]>;
}
type CustomMigrationFn = (context: MigrationContext) => Awaitable<MigrationOperation[]>;
interface MigrateOptions {
    /**
     * Manage how migrations are generated.
     *
     * - `from-schema` (default): compare fumadb schemas
     * - `from-database`: introspect & compare the database with schema
     */
    mode?: "from-schema" | "from-database";
    /**
     * Update internal settings, it's true by default.
     * We don't recommend to disable it other than testing purposes.
     */
    updateSettings?: boolean;
    /**
     * Enable unsafe operations when auto-generating migration.
     */
    unsafe?: boolean;
}
interface MigrationResult {
    operations: MigrationOperation[];
    getSQL?: () => string;
    execute: () => Promise<void>;
}
interface Migrator {
    /**
     * Get current version, undefined if not initialized
     */
    getVersion: () => Promise<string | undefined>;
    getNameVariants: () => Promise<NameVariantsConfig | undefined>;
    next: () => Promise<AnySchema | undefined>;
    previous: () => Promise<AnySchema | undefined>;
    up: (options?: MigrateOptions) => Promise<MigrationResult>;
    down: (options?: MigrateOptions) => Promise<MigrationResult>;
    migrateTo: (version: string, options?: MigrateOptions) => Promise<MigrationResult>;
    migrateToLatest: (options?: MigrateOptions) => Promise<MigrationResult>;
}

type AnySchema = Schema<string, Record<string, AnyTable>>;
type AnyRelation = Relation;
type AnyTable = Table;
type AnyColumn = Column<keyof TypeMap, unknown, unknown> | IdColumn<IdColumnType, unknown, unknown>;
type ForeignKeyAction = "RESTRICT" | "CASCADE" | "SET NULL";
interface NameVariants {
    sql: string;
    drizzle: string;
    prisma: string;
    convex: string;
    mongodb: string;
}
interface ForeignKey {
    name: string;
    table: AnyTable;
    columns: AnyColumn[];
    referencedTable: AnyTable;
    referencedColumns: AnyColumn[];
    onUpdate: ForeignKeyAction;
    onDelete: ForeignKeyAction;
}
declare class RelationInit<Type extends RelationType, Tables extends Record<string, AnyTable>, T extends keyof Tables> {
    type: Type;
    referencedTable: Tables[T];
    referencer: AnyTable;
    constructor(type: Type, referencedTable: Tables[T], referencer: AnyTable);
}
declare class ImplicitRelationInit<Type extends RelationType, Tables extends Record<string, AnyTable>, T extends keyof Tables> extends RelationInit<Type, Tables, T> {
    init(ormName: string, impliedBy: ExplicitRelation): ImplicitRelation<Type, Tables[T]>;
}
interface UniqueConstraint {
    name: string;
    columns: AnyColumn[];
}
interface ForeignKeyConfig {
    name: string;
    onUpdate: ForeignKeyAction;
    onDelete: ForeignKeyAction;
}
declare class ExplicitRelationInit<Type extends RelationType, Tables extends Record<string, AnyTable>, T extends keyof Tables> extends RelationInit<Type, Tables, T> {
    private foreignKeyConfig?;
    implyingRelationName?: string;
    on: [string, string][];
    imply(implyingRelationName: string): this;
    private initForeignKey;
    init(ormName: string): ExplicitRelation<Type, Tables[T]>;
    /**
     * Define foreign key for explicit relation, please note that:
     *
     * - this constraint is ignored for MongoDB (without Prisma).
     * - you **must** define foreign key for explicit relations, due to the limitations of Prisma.
     */
    foreignKey(config?: Partial<ForeignKeyConfig>): this;
}
interface BaseRelation<Type extends RelationType = RelationType, T extends AnyTable = AnyTable> {
    /**
     * The relation id shared between implied/implying relation
     */
    id: string;
    name: string;
    type: Type;
    table: T;
    referencer: AnyTable;
    on: [string, string][];
}
interface ImplicitRelation<Type extends RelationType = RelationType, T extends AnyTable = AnyTable> extends BaseRelation<Type, T> {
    implied: true;
    readonly impliedBy: ExplicitRelation;
}
interface ExplicitRelation<Type extends RelationType = RelationType, T extends AnyTable = AnyTable> extends BaseRelation<Type, T> {
    implied: false;
    implying: ImplicitRelation | undefined;
    foreignKey?: ForeignKey;
}
type Relation<Type extends RelationType = RelationType, T extends AnyTable = AnyTable> = ImplicitRelation<Type, T> | ExplicitRelation<Type, T>;
interface Table<Columns extends Record<string, AnyColumn> = Record<string, AnyColumn>, Relations extends Record<string, AnyRelation> = Record<string, AnyRelation>> {
    names: NameVariants;
    ormName: string;
    columns: Columns;
    relations: Relations;
    foreignKeys: ForeignKey[];
    /**
     * @param level default to 'all'
     */
    getUniqueConstraints: (level?: "table" | "column" | "all") => UniqueConstraint[];
    /**
     * @param name - name
     * @param type - default to "sql"
     */
    getColumnByName: (name: string, type?: keyof NameVariants) => AnyColumn | undefined;
    getIdColumn: () => AnyColumn;
    /**
     * Add unique constraint to the fields, for consistency, duplicated null values are allowed.
     */
    unique: (name: string, columns: (keyof Columns)[]) => Table<Columns, Relations>;
    clone: () => Table<Columns, Relations>;
}
type DefaultFunctionMap = {
    date: "now";
    timestamp: "now";
    string: "auto";
} & Record<`varchar(${number})`, "auto">;
type DefaultFunction<Type extends keyof TypeMap> = (Type extends keyof DefaultFunctionMap ? DefaultFunctionMap[Type] : never) | (() => TypeMap[Type]);
type IdColumnType = `varchar(${number})`;
type TypeMap = {
    string: string;
    bigint: bigint;
    integer: number;
    decimal: number;
    bool: boolean;
    json: unknown;
    /**
     * this follows the same specs as Prisma `Bytes` for consistency.
     */
    binary: Uint8Array;
    date: Date;
    timestamp: Date;
} & Record<`varchar(${number})`, string>;
declare class Column<Type extends keyof TypeMap, In = unknown, Out = unknown> {
    type: Type;
    ormName: string;
    isNullable: boolean;
    isUnique: boolean;
    default?: {
        value: TypeMap[Type];
    } | {
        runtime: DefaultFunction<Type>;
    };
    table: AnyTable;
    private initNames;
    get names(): NameVariants;
    set names(v: NameVariants);
    constructor(type: Type, onInitNames: (ormName: string) => NameVariants);
    nullable<T extends boolean = true>(nullable?: T): Column<Type, T extends true ? In | null : Exclude<In, null>, T extends true ? Out | null : Exclude<Out, null>>;
    /**
     * Add unique constraint to the field, for consistency, duplicated null values are allowed.
     */
    unique(unique?: boolean): this;
    /**
     * Generate default value on runtime
     */
    defaultTo$(fn: DefaultFunction<Type>): Column<Type, In | null, Out>;
    /**
     * Set a database-level default value
     *
     * For schemaless database, it's still generated on runtime
     */
    defaultTo(value: TypeMap[Type]): Column<Type, In | null, Out>;
    clone(): Column<Type, unknown, unknown>;
    getUniqueConstraintName(): string;
    /**
     * Generate default value for the column on runtime.
     */
    generateDefaultValue(): TypeMap[Type] | undefined;
    get $in(): In;
    get $out(): Out;
}
declare class IdColumn<Type extends IdColumnType = IdColumnType, In = unknown, Out = unknown> extends Column<Type, In, Out> {
    id: boolean;
    constructor(type: Type, onInitNames: (ormName: string) => NameVariants);
    clone(): IdColumn<Type, unknown, unknown>;
    defaultTo$(fn: DefaultFunction<Type>): IdColumn<Type, In | null, Out>;
    defaultTo(value: TypeMap[Type]): IdColumn<Type, In | null, Out>;
}
declare function column<Type extends keyof TypeMap>(name: string | Partial<NameVariants>, type: Type): Column<Type, TypeMap[Type], TypeMap[Type]>;
declare function idColumn<Type extends IdColumnType>(name: string | Partial<NameVariants>, type: Type): IdColumn<Type, TypeMap[Type], TypeMap[Type]>;
type RelationType = "many" | "one";
interface RelationBuilder<Tables extends Record<string, AnyTable> = Record<string, AnyTable>, K extends keyof Tables = keyof Tables> {
    one<T extends keyof Tables>(another: T): ImplicitRelationInit<"one", Tables, T>;
    one<T extends keyof Tables>(another: T, ...on: [keyof Tables[K]["columns"], keyof Tables[T]["columns"]][]): ExplicitRelationInit<"one", Tables, T>;
    many<T extends keyof Tables>(another: T): ImplicitRelationInit<"many", Tables, T>;
}
declare function table<Columns extends Record<string, AnyColumn>>(name: string | Partial<NameVariants>, columns: Columns): Table<Columns, {}>;
type BuildRelation<Tables extends Record<string, AnyTable>, RM extends RelationsMap<Tables>, R> = R extends ExplicitRelationInit<infer Type, Tables, infer K> ? ExplicitRelation<Type, CreateSchemaTables<Tables, RM>[K]> : R extends ImplicitRelationInit<infer Type, Tables, infer K> ? ImplicitRelation<Type, CreateSchemaTables<Tables, RM>[K]> : never;
type Override<T, O> = Omit<T, keyof O> & O;
type RelationsMap<Tables extends Record<string, AnyTable>> = {
    [K in keyof Tables]?: (builder: RelationBuilder<Tables, K>) => Record<string, RelationInit<RelationType, Tables, keyof Tables>>;
};
type CreateSchemaTables<Tables extends Record<string, AnyTable>, RM extends RelationsMap<Tables>> = {
    [K in keyof Tables]: Tables[K] extends Table<infer Columns, infer Relations> ? Table<Columns, RM[K] extends (builder: RelationBuilder<Tables, K>) => infer Out ? Override<Relations, {
        [R in keyof Out]: BuildRelation<Tables, RM, Out[R]>;
    }> : Relations> : never;
};
interface Schema<Version extends string = string, Tables extends Record<string, AnyTable> = Record<string, AnyTable>> {
    /**
     * @description The version of the schema, it should be a semantic version string.
     */
    version: Version;
    tables: Tables;
    up?: CustomMigrationFn;
    down?: CustomMigrationFn;
    clone: () => Schema<Version, Tables>;
}
declare function schema<Version extends string, Tables extends Record<string, AnyTable>, RM extends RelationsMap<Tables>>(config: {
    version: Version;
    tables: Tables;
    up?: CustomMigrationFn;
    down?: CustomMigrationFn;
    relations?: RM;
}): Schema<Version, CreateSchemaTables<Tables, RM>>;
type OverrideTables<Tables extends Record<string, AnyTable>, Override extends Record<string, AnyTable | boolean>> = Omit<Tables, keyof Override> & {
    [K in keyof Override as Override[K] extends AnyTable | true ? K : never]: Override[K] extends true ? K extends keyof Tables ? Tables[K] : never : Override[K];
};
/**
 * extend original schema.
 *
 * 1. you can adding new tables and relations.
 * 2. you can replace relations.
 * 3. you cannot remove tables, otherwise it may breaks original relations.
 * 4. when replacing tables, its original relations will be removed.
 */
declare function variantSchema<Variant extends string, Version extends string, Tables extends Record<string, AnyTable>, $Tables extends Record<string, AnyTable>, RM extends RelationsMap<OverrideTables<Tables, $Tables>>>(variant: Variant, originalSchema: Schema<Version, Tables>, override: {
    tables: $Tables;
    relations?: RM;
}): Schema<`${Version}-${Variant}`, CreateSchemaTables<OverrideTables<Tables, $Tables>, RM>>;
declare function compileForeignKey(key: ForeignKey, name: keyof NameVariants): {
    name: string;
    onUpdate: ForeignKeyAction;
    onDelete: ForeignKeyAction;
    table: string;
    referencedTable: string;
    referencedColumns: string[];
    columns: string[];
};

export { type AnySchema as A, Column as C, ExplicitRelationInit as E, type ForeignKeyAction as F, IdColumn as I, type Migrator as M, type NameVariantsBuilder as N, type Relation as R, type Schema as S, type Table as T, type UniqueConstraint as U, type AnyColumn as a, type AnyTable as b, type AnyRelation as c, type NameVariants as d, type ForeignKey as e, ImplicitRelationInit as f, type ImplicitRelation as g, type ExplicitRelation as h, type TypeMap as i, column as j, idColumn as k, type RelationType as l, type RelationBuilder as m, type RelationsMap as n, compileForeignKey as o, schema as s, table as t, variantSchema as v };
