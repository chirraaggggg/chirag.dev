// src/query/polyfills/foreign-key.ts
async function checkForeignKeyOnInsert(orm, key, inserts) {
  const ifMatchEntry = [];
  function shouldSkipChecking(insert) {
    for (const priorInsert of inserts) {
      if (priorInsert === insert) break;
      if (key.columns.every(
        (col) => insert[col.ormName] === priorInsert[col.ormName]
      ))
        return true;
      if (key.table === key.referencedTable && key.columns.every(
        (col, i) => insert[col.ormName] === priorInsert[key.referencedColumns[i].ormName]
      )) {
        return true;
      }
    }
    return false;
  }
  for (const insert of inserts) {
    if (shouldSkipChecking(insert)) continue;
    const ifMatchColumn = [];
    let containsNull = false;
    for (let i = 0; i < key.columns.length; i++) {
      const col = key.columns[i];
      const referencedCol = key.referencedColumns[i];
      if (insert[col.ormName] == null) {
        containsNull = true;
        break;
      }
      ifMatchColumn.push({
        type: 2 /* Compare */,
        a: referencedCol,
        operator: "=",
        b: insert[col.ormName]
      });
    }
    if (!containsNull)
      ifMatchEntry.push({
        type: 0 /* And */,
        items: ifMatchColumn
      });
  }
  if (ifMatchEntry.length === 0) return;
  const count = await orm.count(key.referencedTable, {
    where: {
      type: 1 /* Or */,
      items: ifMatchEntry
    }
  });
  if (count < ifMatchEntry.length) errorForeignKey(key);
}
async function exists(orm, table, where) {
  const result = await orm.findFirst(table, {
    select: [table.getIdColumn().ormName],
    where
  });
  return result !== null;
}
async function foreignKeyOnUpdate(orm, key, set, targets) {
  const isAffected = {
    type: 1 /* Or */,
    items: []
  };
  const updated = key.referencedColumns.some(
    (col) => set[col.ormName] !== void 0
  );
  if (!updated) return;
  for (const target of targets) {
    const condition = {
      type: 0 /* And */,
      items: []
    };
    let containsNull = false;
    for (let i = 0; i < key.columns.length; i++) {
      const col = key.columns[i];
      const referencedCol = key.referencedColumns[i];
      if (target[referencedCol.ormName] === null) {
        containsNull = true;
        break;
      }
      condition.items.push({
        type: 2 /* Compare */,
        a: col,
        operator: "=",
        b: target[referencedCol.ormName]
      });
    }
    if (!containsNull) isAffected.items.push(condition);
  }
  if (isAffected.items.length === 0) return;
  if (key.onUpdate === "RESTRICT") {
    if (await exists(orm, key.table, isAffected)) errorForeignKey(key);
    return;
  }
  const mappedSet = {};
  for (let i = 0; i < key.columns.length; i++) {
    const col = key.columns[i].ormName;
    const referencedCol = key.referencedColumns[i].ormName;
    mappedSet[col] = key.onUpdate === "CASCADE" ? set[referencedCol] : null;
  }
  await orm.updateMany(key.table, {
    where: isAffected,
    set: mappedSet
  });
}
function createSoftForeignKey(schema, {
  generateInsertValuesDefault,
  ...orm
}) {
  const childForeignKeys = /* @__PURE__ */ new Map();
  for (const table of Object.values(schema.tables)) {
    for (const key of table.foreignKeys) {
      const name = key.referencedTable.ormName;
      const list = childForeignKeys.get(name) ?? [];
      list.push(key);
      childForeignKeys.set(name, list);
    }
  }
  if (!orm.transaction)
    throw new Error("native `transaction` required for soft foreign key.");
  return {
    ...orm,
    async updateMany(table, { set, where }) {
      const foreignKeys = childForeignKeys.get(table.ormName);
      if (!foreignKeys) return orm.updateMany(table, { set, where });
      const idColumnName = table.getIdColumn().ormName;
      const targets = await orm.findMany(table, { select: true, where });
      await orm.transaction?.(async (tx) => {
        for (const key of foreignKeys) {
          await foreignKeyOnUpdate(tx.internal, key, set, targets);
        }
        await orm.updateMany(table, {
          set,
          where: {
            type: 2 /* Compare */,
            a: table.columns[idColumnName],
            operator: "in",
            b: targets.map((target) => target[idColumnName])
          }
        });
      });
    },
    // ignore original `upsert` so we can re-use our logic
    async upsert(table, v) {
      const target = await orm.findFirst(table, {
        select: true,
        where: v.where
      });
      if (target === null) {
        await this.createMany(table, [v.create]);
      } else {
        const idColumn = table.getIdColumn();
        await this.updateMany(table, {
          set: v.update,
          where: {
            type: 2 /* Compare */,
            a: table.columns[idColumn.ormName],
            operator: "=",
            b: target[idColumn.ormName]
          }
        });
      }
    },
    async create(table, values) {
      values = generateInsertValuesDefault(table, values);
      await Promise.all(
        table.foreignKeys.map(
          (key) => checkForeignKeyOnInsert(this, key, [values])
        )
      );
      return orm.create(table, values);
    },
    async createMany(table, values) {
      values = values.map((value) => generateInsertValuesDefault(table, value));
      await Promise.all(
        table.foreignKeys.map(
          (key) => checkForeignKeyOnInsert(this, key, values)
        )
      );
      return orm.createMany(table, values);
    },
    async deleteMany(table, v) {
      const foreignKeys = childForeignKeys.get(table.ormName);
      if (!foreignKeys) return orm.deleteMany(table, v);
      const targets = await orm.findMany(table, {
        select: true,
        where: v.where
      });
      for (const key of foreignKeys) {
        const isAffected = {
          type: 1 /* Or */,
          items: []
        };
        for (const target of targets) {
          const isReferencingTarget = {
            type: 0 /* And */,
            items: []
          };
          let containsNull = false;
          for (let i = 0; i < key.columns.length; i++) {
            const targetValue = target[key.referencedColumns[i].ormName];
            if (targetValue === null) {
              containsNull = true;
              break;
            }
            isReferencingTarget.items.push({
              type: 2 /* Compare */,
              a: key.columns[i],
              operator: "=",
              b: targetValue
            });
          }
          if (!containsNull) isAffected.items.push(isReferencingTarget);
        }
        if (key.onDelete === "CASCADE") {
          await orm.deleteMany(key.table, {
            where: isAffected
          });
        } else if (key.onDelete === "SET NULL") {
          const set = {};
          for (const col of key.columns) {
            set[col.ormName] = null;
          }
          await orm.updateMany(key.table, {
            set,
            where: isAffected
          });
        } else if (await exists(this, key.table, isAffected)) {
          errorForeignKey(key);
        }
      }
      const idColumnName = table.getIdColumn().ormName;
      return orm.deleteMany(table, {
        where: {
          type: 2 /* Compare */,
          a: table.columns[idColumnName],
          operator: "in",
          b: targets.map((target) => target[idColumnName])
        }
      });
    }
  };
}
function errorForeignKey(key) {
  throw new Error(`foreign constraint failed ${key.name}`);
}

export {
  checkForeignKeyOnInsert,
  createSoftForeignKey
};
