import { deepMergeTranslations, detectBrowserLanguage, enTranslations, mergeTranslationConfigs, prepareTranslationConfig } from "@c15t/translations";
import { createStore } from "zustand/vanilla";
const LEADING_SLASHES_REGEX = /^\/+/;
function createResponseContext(isSuccess, data = null, error = null, response = null) {
    return {
        data,
        error,
        ok: isSuccess,
        response
    };
}
function createErrorResponse(message, status = 500, code = 'ERROR', cause) {
    return createResponseContext(false, null, {
        message,
        status,
        code,
        cause
    }, null);
}
const DEFAULT_RETRY_CONFIG = {
    maxRetries: 3,
    initialDelayMs: 100,
    backoffFactor: 2,
    retryableStatusCodes: [
        500,
        502,
        503,
        504
    ],
    nonRetryableStatusCodes: [
        400,
        401,
        403,
        404
    ],
    retryOnNetworkError: true,
    shouldRetry: void 0
};
const ABSOLUTE_URL_REGEX = /^(?:[a-z+]+:)?\/\//i;
const constants_LEADING_SLASHES_REGEX = LEADING_SLASHES_REGEX;
const delay = (ms)=>new Promise((resolve)=>setTimeout(resolve, ms));
function generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c)=>{
        const r = 16 * Math.random() | 0;
        const v = 'x' === c ? r : 0x3 & r | 0x8;
        return v.toString(16);
    });
}
function removeTrailingSlashes(str) {
    let i = str.length;
    while(i > 0 && '/' === str[i - 1])i--;
    return str.slice(0, i);
}
function resolveUrl(backendURL, path) {
    if (ABSOLUTE_URL_REGEX.test(backendURL)) {
        const backendURLObj = new URL(backendURL);
        const basePath = removeTrailingSlashes(backendURLObj.pathname);
        const cleanPath = path.replace(constants_LEADING_SLASHES_REGEX, '');
        const newPath = `${basePath}/${cleanPath}`;
        backendURLObj.pathname = newPath;
        return backendURLObj.toString();
    }
    const cleanBase = removeTrailingSlashes(backendURL);
    const cleanPath = path.replace(constants_LEADING_SLASHES_REGEX, '');
    return `${cleanBase}/${cleanPath}`;
}
const fetcher_createResponseContext = createResponseContext;
async function fetcher(context, path, options) {
    const finalRetryConfig = {
        ...context.retryConfig,
        ...options?.retryConfig || {},
        retryableStatusCodes: options?.retryConfig?.retryableStatusCodes ?? context.retryConfig.retryableStatusCodes ?? DEFAULT_RETRY_CONFIG.retryableStatusCodes,
        nonRetryableStatusCodes: options?.retryConfig?.nonRetryableStatusCodes ?? context.retryConfig.nonRetryableStatusCodes ?? DEFAULT_RETRY_CONFIG.nonRetryableStatusCodes
    };
    const { maxRetries, initialDelayMs, backoffFactor, retryableStatusCodes, nonRetryableStatusCodes, retryOnNetworkError } = finalRetryConfig;
    let attemptsMade = 0;
    let currentDelay = initialDelayMs;
    let lastErrorResponse = null;
    while(attemptsMade <= (maxRetries ?? 0)){
        const requestId = generateUUID();
        const fetchImpl = context.customFetch || globalThis.fetch;
        const resolvedUrl = resolveUrl(context.backendURL, path);
        let url;
        try {
            url = new URL(resolvedUrl);
        } catch  {
            url = new URL(resolvedUrl, window.location.origin);
        }
        if (options?.query) {
            for (const [key, value] of Object.entries(options.query))if (void 0 !== value) url.searchParams.append(key, String(value));
        }
        const requestOptions = {
            method: options?.method || 'GET',
            mode: context.corsMode,
            credentials: 'include',
            headers: {
                ...context.headers,
                'X-Request-ID': requestId,
                ...options?.headers
            },
            ...options?.fetchOptions
        };
        if (options?.body && 'GET' !== requestOptions.method) requestOptions.body = JSON.stringify(options.body);
        try {
            const response = await fetchImpl(url.toString(), requestOptions);
            let data = null;
            let parseError = null;
            try {
                const contentType = response.headers.get('content-type');
                if (contentType?.includes('application/json') && 204 !== response.status && '0' !== response.headers.get('content-length')) data = await response.json();
                else if (204 === response.status) data = null;
            } catch (err) {
                parseError = err;
            }
            if (parseError) {
                const errorResponse = fetcher_createResponseContext(false, null, {
                    message: 'Failed to parse response',
                    status: response.status,
                    code: 'PARSE_ERROR',
                    cause: parseError
                }, response);
                options?.onError?.(errorResponse, path);
                if (options?.throw) throw new Error('Failed to parse response');
                return errorResponse;
            }
            const isSuccess = response.status >= 200 && response.status < 300;
            if (isSuccess) {
                const successResponse = fetcher_createResponseContext(true, data, null, response);
                options?.onSuccess?.(successResponse);
                return successResponse;
            }
            const errorData = data;
            const errorResponse = fetcher_createResponseContext(false, null, {
                message: errorData?.message || `Request failed with status ${response.status}`,
                status: response.status,
                code: errorData?.code || 'API_ERROR',
                details: errorData?.details || null
            }, response);
            lastErrorResponse = errorResponse;
            let shouldRetryThisRequest = false;
            if (nonRetryableStatusCodes?.includes(response.status)) {
                console.debug(`Not retrying request to ${path} with status ${response.status} (nonRetryableStatusCodes)`);
                shouldRetryThisRequest = false;
            } else if ('function' == typeof finalRetryConfig.shouldRetry) try {
                shouldRetryThisRequest = finalRetryConfig.shouldRetry(response, {
                    attemptsMade,
                    url: url.toString(),
                    method: requestOptions.method || 'GET'
                });
                console.debug(`Custom retry strategy for ${path} with status ${response.status}: ${shouldRetryThisRequest}`);
            } catch  {
                shouldRetryThisRequest = retryableStatusCodes?.includes(response.status) ?? false;
                console.debug(`Custom retry strategy failed, falling back to status code check: ${shouldRetryThisRequest}`);
            }
            else {
                shouldRetryThisRequest = retryableStatusCodes?.includes(response.status) ?? false;
                console.debug(`Standard retry check for ${path} with status ${response.status}: ${shouldRetryThisRequest}`);
            }
            if (!shouldRetryThisRequest || attemptsMade >= (maxRetries ?? 0)) {
                options?.onError?.(errorResponse, path);
                if (options?.throw) throw new Error(errorResponse.error?.message || 'Request failed');
                return errorResponse;
            }
            attemptsMade++;
            await delay(currentDelay ?? 0);
            currentDelay = (currentDelay ?? 0) * (backoffFactor ?? 2);
        } catch (fetchError) {
            if (fetchError && 'Failed to parse response' === fetchError.message) throw fetchError;
            const isNetworkError = !(fetchError instanceof Response);
            const errorResponse = fetcher_createResponseContext(false, null, {
                message: fetchError instanceof Error ? fetchError.message : String(fetchError),
                status: 0,
                code: 'NETWORK_ERROR',
                cause: fetchError
            }, null);
            lastErrorResponse = errorResponse;
            const shouldRetryThisRequest = isNetworkError && retryOnNetworkError;
            if (!shouldRetryThisRequest || attemptsMade >= (maxRetries ?? 0)) {
                options?.onError?.(errorResponse, path);
                if (options?.throw) throw fetchError;
                return errorResponse;
            }
            attemptsMade++;
            await delay(currentDelay ?? 0);
            currentDelay = (currentDelay ?? 0) * (backoffFactor ?? 2);
        }
    }
    const maxRetriesErrorResponse = lastErrorResponse || fetcher_createResponseContext(false, null, {
        message: `Request failed after ${maxRetries} retries`,
        status: 0,
        code: 'MAX_RETRIES_EXCEEDED'
    }, null);
    options?.onError?.(maxRetriesErrorResponse, path);
    if (options?.throw) throw new Error(`Request failed after ${maxRetries} retries`);
    return maxRetriesErrorResponse;
}
function getDefaultCookieOptions(config) {
    return {
        expiryDays: config?.defaultExpiryDays ?? 365,
        crossSubdomain: config?.crossSubdomain ?? false,
        domain: config?.defaultDomain ?? '',
        path: '/',
        secure: 'undefined' != typeof window && 'https:' === window.location.protocol,
        sameSite: 'Lax'
    };
}
function getRootDomain() {
    if ('undefined' == typeof window) return '';
    const hostname = window.location.hostname;
    if ('localhost' === hostname || /^\d+\.\d+\.\d+\.\d+$/.test(hostname)) return hostname;
    const parts = hostname.split('.');
    if (parts.length >= 2) return `.${parts.slice(-2).join('.')}`;
    return hostname;
}
const COOKIE_KEY_MAP = {
    consents: 'c',
    consentInfo: 'i',
    timestamp: 'ts',
    time: 't',
    type: 'y',
    id: 'id',
    identified: 'eid'
};
const REVERSE_COOKIE_KEY_MAP = Object.entries(COOKIE_KEY_MAP).reduce((acc, [key, value])=>{
    acc[value] = key;
    return acc;
}, {});
function shortenFlatKeys(flattened) {
    const shortened = {};
    for (const [key, value] of Object.entries(flattened)){
        const keys = key.split('.');
        const shortenedKeys = keys.map((k)=>COOKIE_KEY_MAP[k] || k);
        shortened[shortenedKeys.join('.')] = value;
    }
    return shortened;
}
function expandFlatKeys(shortened) {
    const expanded = {};
    for (const [key, value] of Object.entries(shortened)){
        const keys = key.split('.');
        const expandedKeys = keys.map((k)=>REVERSE_COOKIE_KEY_MAP[k] || k);
        expanded[expandedKeys.join('.')] = value;
    }
    return expanded;
}
function flattenObject(obj, prefix = '') {
    const flattened = {};
    for (const [key, value] of Object.entries(obj)){
        const newKey = prefix ? `${prefix}.${key}` : key;
        if (null == value) flattened[newKey] = '';
        else if ('boolean' == typeof value) {
            if (value) flattened[newKey] = '1';
        } else if ('object' != typeof value || Array.isArray(value)) flattened[newKey] = String(value);
        else Object.assign(flattened, flattenObject(value, newKey));
    }
    return flattened;
}
function unflattenObject(flattened) {
    const result = {};
    for (const [key, value] of Object.entries(flattened)){
        const keys = key.split('.');
        if (0 === keys.length) continue;
        let current = result;
        for(let i = 0; i < keys.length - 1; i++){
            const k = keys[i];
            if (void 0 !== k) {
                if (!current[k]) current[k] = {};
                current = current[k];
            }
        }
        const lastKey = keys[keys.length - 1];
        if (void 0 !== lastKey) if ('1' === value) current[lastKey] = true;
        else if ('0' === value) current[lastKey] = false;
        else if ('' === value) current[lastKey] = null;
        else if (Number.isNaN(Number(value)) || '' === value) current[lastKey] = value;
        else current[lastKey] = Number(value);
    }
    return result;
}
function flatToString(flattened) {
    return Object.entries(flattened).map(([key, value])=>`${key}:${value}`).join(',');
}
function stringToFlat(str) {
    if (!str) return {};
    const result = {};
    const pairs = str.split(',');
    for (const pair of pairs){
        const colonIndex = pair.indexOf(':');
        if (-1 === colonIndex) continue;
        const key = pair.substring(0, colonIndex);
        const value = pair.substring(colonIndex + 1);
        result[key] = value;
    }
    return result;
}
function setCookie(name, value, options, config) {
    if ('undefined' == typeof document) return;
    const opts = {
        ...getDefaultCookieOptions(config),
        ...options
    };
    if (opts.crossSubdomain && !options?.domain) opts.domain = getRootDomain();
    try {
        let cookieValue;
        if ('string' == typeof value) cookieValue = value;
        else {
            const flattened = flattenObject(value);
            const shortened = shortenFlatKeys(flattened);
            cookieValue = flatToString(shortened);
        }
        const date = new Date();
        date.setTime(date.getTime() + 24 * opts.expiryDays * 3600000);
        const expires = `expires=${date.toUTCString()}`;
        const parts = [
            `${name}=${cookieValue}`,
            expires,
            `path=${opts.path}`
        ];
        if (opts.domain) parts.push(`domain=${opts.domain}`);
        if (opts.secure) parts.push('secure');
        if (opts.sameSite) parts.push(`SameSite=${opts.sameSite}`);
        document.cookie = parts.join('; ');
    } catch (error) {
        console.warn(`Failed to set cookie "${name}":`, error);
    }
}
function getCookie(name) {
    if ('undefined' == typeof document) return null;
    try {
        const nameEQ = `${name}=`;
        const cookies = document.cookie.split(';');
        for (const cookie of cookies){
            let c = cookie;
            while(' ' === c.charAt(0))c = c.substring(1);
            if (0 === c.indexOf(nameEQ)) {
                const cookieValue = c.substring(nameEQ.length);
                if (cookieValue.includes(':')) {
                    const shortened = stringToFlat(cookieValue);
                    const expanded = expandFlatKeys(shortened);
                    const nested = unflattenObject(expanded);
                    return nested;
                }
                return cookieValue;
            }
        }
        return null;
    } catch (error) {
        console.warn(`Failed to get cookie "${name}":`, error);
        return null;
    }
}
function deleteCookie(name, options, config) {
    if ('undefined' == typeof document) return;
    const opts = {
        ...getDefaultCookieOptions(config),
        ...options
    };
    if (opts.crossSubdomain && !options?.domain) opts.domain = getRootDomain();
    try {
        const parts = [
            `${name}=`,
            'expires=Thu, 01 Jan 1970 00:00:00 GMT',
            `path=${opts.path}`
        ];
        if (opts.domain) parts.push(`domain=${opts.domain}`);
        document.cookie = parts.join('; ');
    } catch (error) {
        console.warn(`Failed to delete cookie "${name}":`, error);
    }
}
const defaultTranslationConfig = {
    translations: {
        en: enTranslations
    },
    defaultLanguage: 'en',
    disableAutoLanguageSwitch: false
};
const gdpr_consentTypes = [
    {
        defaultValue: true,
        description: 'These trackers are used for activities that are strictly necessary to operate or deliver the service you requested from us and, therefore, do not require you to consent.',
        disabled: true,
        display: true,
        gdprType: 1,
        name: 'necessary'
    },
    {
        defaultValue: false,
        description: 'These trackers enable basic interactions and functionalities that allow you to access selected features of our service and facilitate your communication with us.',
        display: false,
        gdprType: 2,
        name: 'functionality'
    },
    {
        defaultValue: false,
        description: 'These trackers help us to measure traffic and analyze your behavior to improve our service.',
        display: false,
        gdprType: 4,
        name: 'measurement'
    },
    {
        defaultValue: false,
        description: 'These trackers help us to improve the quality of your user experience and enable interactions with external content, networks, and platforms.',
        display: false,
        gdprType: 3,
        name: 'experience'
    },
    {
        defaultValue: false,
        description: 'These trackers help us to deliver personalized ads or marketing content to you, and to measure their performance.',
        display: false,
        gdprType: 5,
        name: 'marketing'
    }
];
const allConsentNames = gdpr_consentTypes.map((consent)=>consent.name);
const STORAGE_KEY_V2 = 'c15t';
const STORAGE_KEY = 'privacy-consent-storage';
const initialState = {
    config: {
        pkg: 'c15t',
        version: "1.8.2",
        mode: 'Unknown'
    },
    consents: gdpr_consentTypes.reduce((acc, consent)=>{
        acc[consent.name] = consent.defaultValue;
        return acc;
    }, {}),
    selectedConsents: gdpr_consentTypes.reduce((acc, consent)=>{
        acc[consent.name] = consent.defaultValue;
        return acc;
    }, {}),
    consentInfo: null,
    branding: 'c15t',
    showPopup: true,
    isLoadingConsentInfo: false,
    hasFetchedBanner: false,
    lastBannerFetchData: null,
    gdprTypes: [
        'necessary',
        'marketing'
    ],
    isPrivacyDialogOpen: false,
    isConsentDomain: false,
    complianceSettings: {
        gdpr: {
            enabled: true,
            appliesGlobally: true,
            applies: true
        },
        ccpa: {
            enabled: true,
            appliesGlobally: false,
            applies: void 0
        },
        lgpd: {
            enabled: false,
            appliesGlobally: false,
            applies: void 0
        },
        usStatePrivacy: {
            enabled: true,
            appliesGlobally: false,
            applies: void 0
        }
    },
    callbacks: {},
    detectedCountry: null,
    locationInfo: null,
    legalLinks: {},
    jurisdictionInfo: null,
    translationConfig: defaultTranslationConfig,
    includeNonDisplayedConsents: false,
    consentTypes: gdpr_consentTypes,
    iframeBlockerConfig: {
        disableAutomaticBlocking: false
    },
    ignoreGeoLocation: false,
    storageConfig: void 0,
    privacySettings: {
        honorDoNotTrack: true
    },
    user: void 0,
    setConsent: ()=>{},
    setShowPopup: ()=>{},
    setIsPrivacyDialogOpen: ()=>{},
    saveConsents: ()=>{},
    resetConsents: ()=>{},
    setGdprTypes: ()=>{},
    setComplianceSetting: ()=>{},
    resetComplianceSettings: ()=>{},
    setCallback: ()=>{},
    setDetectedCountry: ()=>{},
    setLocationInfo: ()=>{},
    getDisplayedConsents: ()=>[],
    hasConsented: ()=>false,
    setTranslationConfig: ()=>{},
    scripts: [],
    loadedScripts: {},
    scriptIdMap: {}
};
function migrateLegacyStorage(config) {
    const newKey = config?.storageKey || STORAGE_KEY_V2;
    const legacyKey = STORAGE_KEY;
    if (newKey === legacyKey) return;
    try {
        if ('undefined' != typeof window && window.localStorage) {
            const existingData = window.localStorage.getItem(newKey);
            if (existingData) return void window.localStorage.removeItem(legacyKey);
            const legacyData = window.localStorage.getItem(legacyKey);
            if (legacyData) {
                window.localStorage.setItem(newKey, legacyData);
                window.localStorage.removeItem(legacyKey);
                console.log(`[c15t] Migrated consent data from "${legacyKey}" to "${newKey}"`);
            }
        }
    } catch (error) {
        console.warn('[c15t] Failed to migrate legacy storage:', error);
    }
}
function saveConsentToStorage(data, options, config) {
    let localStorageSuccess = false;
    let cookieSuccess = false;
    const storageKey = config?.storageKey || STORAGE_KEY_V2;
    try {
        if ('undefined' != typeof window && window.localStorage) {
            window.localStorage.setItem(storageKey, JSON.stringify(data));
            localStorageSuccess = true;
        }
    } catch (error) {
        console.warn('Failed to save consent to localStorage:', error);
    }
    try {
        setCookie(storageKey, data, options, config);
        cookieSuccess = true;
    } catch (error) {
        console.warn('Failed to save consent to cookie:', error);
    }
    if (!localStorageSuccess && !cookieSuccess) throw new Error('Failed to save consent to any storage method');
}
function normalizeConsentData(data) {
    if (!data.consents) return data;
    const normalizedConsents = {
        ...data.consents
    };
    for (const consentName of allConsentNames)normalizedConsents[consentName] = data.consents[consentName] ?? false;
    return {
        ...data,
        consents: normalizedConsents
    };
}
function getConsentFromStorage(config) {
    migrateLegacyStorage(config);
    const storageKey = config?.storageKey || STORAGE_KEY_V2;
    let localStorageData = null;
    let cookieData = null;
    try {
        if ('undefined' != typeof window && window.localStorage) {
            const stored = window.localStorage.getItem(storageKey);
            if (stored) localStorageData = JSON.parse(stored);
        }
    } catch (error) {
        console.warn('Failed to read consent from localStorage:', error);
    }
    try {
        cookieData = getCookie(storageKey);
    } catch (error) {
        console.warn('Failed to read consent from cookie:', error);
    }
    let chosenData = null;
    let chosenSource = null;
    if (cookieData) {
        chosenData = cookieData;
        chosenSource = 'cookie';
    } else if (localStorageData) {
        chosenData = localStorageData;
        chosenSource = 'localStorage';
    }
    if (chosenData && chosenSource) {
        const isCrossSubdomain = config?.crossSubdomain === true || !!config?.defaultDomain;
        if ('localStorage' !== chosenSource || cookieData) {
            if ('cookie' === chosenSource) try {
                if ('undefined' != typeof window && window.localStorage) {
                    let normalizedCookieData = chosenData;
                    if ('object' == typeof normalizedCookieData && null !== normalizedCookieData && 'consents' in normalizedCookieData) normalizedCookieData = normalizeConsentData(normalizedCookieData);
                    let normalizedLocalStorageData = null;
                    try {
                        const stored = window.localStorage.getItem(storageKey);
                        if (stored) {
                            const parsed = JSON.parse(stored);
                            normalizedLocalStorageData = 'object' == typeof parsed && null !== parsed && 'consents' in parsed ? normalizeConsentData(parsed) : parsed;
                        }
                    } catch  {
                        normalizedLocalStorageData = null;
                    }
                    const cookieJson = JSON.stringify(normalizedCookieData);
                    const localStorageJson = JSON.stringify(normalizedLocalStorageData);
                    if (cookieJson !== localStorageJson) {
                        window.localStorage.setItem(storageKey, cookieJson);
                        if (normalizedLocalStorageData) if (isCrossSubdomain) console.log('[c15t] Updated localStorage with consent from cookie (cross-subdomain mode)');
                        else console.log('[c15t] Updated localStorage with consent from cookie');
                        else console.log('[c15t] Synced consent from cookie to localStorage');
                    }
                }
            } catch (error) {
                console.warn('[c15t] Failed to sync consent to localStorage:', error);
            }
        } else try {
            setCookie(storageKey, chosenData, void 0, config);
            console.log('[c15t] Synced consent from localStorage to cookie');
        } catch (error) {
            console.warn('[c15t] Failed to sync consent to cookie:', error);
        }
    }
    if (chosenData && 'object' == typeof chosenData && 'consents' in chosenData) return normalizeConsentData(chosenData);
    return chosenData;
}
function deleteConsentFromStorage(options, config) {
    const storageKey = config?.storageKey || STORAGE_KEY_V2;
    try {
        if ('undefined' != typeof window && window.localStorage) {
            window.localStorage.removeItem(storageKey);
            if (storageKey !== STORAGE_KEY) window.localStorage.removeItem(STORAGE_KEY);
        }
    } catch (error) {
        console.warn('Failed to remove consent from localStorage:', error);
    }
    try {
        deleteCookie(storageKey, options, config);
        if (storageKey !== STORAGE_KEY) deleteCookie(STORAGE_KEY, options, config);
    } catch (error) {
        console.warn('Failed to remove consent cookie:', error);
    }
}
const API_ENDPOINTS = {
    SHOW_CONSENT_BANNER: '/show-consent-banner',
    SET_CONSENT: '/consent/set',
    VERIFY_CONSENT: '/consent/verify',
    IDENTIFY_CONSENT: '/consent/identify'
};
async function withFallback(context, endpoint, method, options, fallbackFn) {
    try {
        const response = await fetcher(context, endpoint, {
            method,
            ...options
        });
        if (response.ok) return response;
        console.warn(`API request failed, falling back to offline mode for ${endpoint}`);
        return fallbackFn(options);
    } catch (error) {
        console.warn(`Error calling ${endpoint}, falling back to offline mode:`, error);
        return fallbackFn(options);
    }
}
function updateConsentStorage(storageConfig) {
    try {
        if ('undefined' != typeof window) {
            const existingData = getConsentFromStorage(storageConfig);
            if (existingData?.consentInfo) saveConsentToStorage({
                consents: existingData.consents || {},
                consentInfo: {
                    ...existingData.consentInfo,
                    identified: true,
                    time: existingData.consentInfo.time ?? Date.now()
                }
            }, void 0, storageConfig);
            else if (existingData) saveConsentToStorage({
                consents: existingData.consents || {},
                consentInfo: {
                    identified: true,
                    time: Date.now()
                }
            }, void 0, storageConfig);
        }
    } catch (error) {
        console.warn('Failed to update consent storage after identification:', error);
    }
}
async function offlineFallbackForIdentifyUser(storageConfig, options) {
    const pendingSubmissionsKey = 'c15t-pending-identify-user-submissions';
    try {
        if ('undefined' != typeof window) {
            updateConsentStorage(storageConfig);
            if (options?.body && window.localStorage) {
                let pendingSubmissions = [];
                try {
                    const storedSubmissions = window.localStorage.getItem(pendingSubmissionsKey);
                    if (storedSubmissions) {
                        const parsed = JSON.parse(storedSubmissions);
                        if (Array.isArray(parsed)) pendingSubmissions = parsed;
                    }
                } catch (e) {
                    console.warn('Error parsing pending identify-user submissions:', e);
                    pendingSubmissions = [];
                }
                const newSubmission = options.body;
                const isDuplicate = pendingSubmissions.some((submission)=>JSON.stringify(submission) === JSON.stringify(newSubmission));
                if (!isDuplicate) {
                    pendingSubmissions.push(newSubmission);
                    window.localStorage.setItem(pendingSubmissionsKey, JSON.stringify(pendingSubmissions));
                    console.log('Queued identify-user submission for retry on next page load');
                }
            }
        }
    } catch (error) {
        console.warn('Failed to write to localStorage in offline fallback:', error);
    }
    const response = fetcher_createResponseContext(true, {
        success: true
    }, null, null);
    if (options?.onSuccess) await options.onSuccess(response);
    return response;
}
async function identifyUser(context, storageConfig, options) {
    const response = await withFallback(context, API_ENDPOINTS.IDENTIFY_CONSENT, 'PATCH', options, async (fallbackOptions)=>offlineFallbackForIdentifyUser(storageConfig, fallbackOptions));
    if (response.ok && response.data) updateConsentStorage(storageConfig);
    return response;
}
function checkPendingConsentSubmissions(_context, processPendingSubmissions) {
    const pendingSubmissionsKey = 'c15t-pending-consent-submissions';
    if ('undefined' == typeof window || !window.localStorage) return;
    try {
        window.localStorage.setItem('c15t-storage-test-key', 'test');
        window.localStorage.removeItem('c15t-storage-test-key');
        const pendingSubmissionsStr = window.localStorage.getItem(pendingSubmissionsKey);
        if (!pendingSubmissionsStr) return;
        const pendingSubmissions = JSON.parse(pendingSubmissionsStr);
        if (!pendingSubmissions.length) return void window.localStorage.removeItem(pendingSubmissionsKey);
        console.log(`Found ${pendingSubmissions.length} pending consent submission(s) to retry`);
        setTimeout(()=>{
            processPendingSubmissions(pendingSubmissions);
        }, 2000);
    } catch (error) {
        console.warn('Failed to check for pending consent submissions:', error);
    }
}
async function processPendingConsentSubmissions(context, submissions) {
    const pendingSubmissionsKey = 'c15t-pending-consent-submissions';
    const maxRetries = 3;
    const remainingSubmissions = [
        ...submissions
    ];
    for(let i = 0; i < maxRetries && remainingSubmissions.length > 0; i++){
        const successfulSubmissions = [];
        for(let j = 0; j < remainingSubmissions.length; j++){
            const submission = remainingSubmissions[j];
            try {
                console.log('Retrying consent submission:', submission);
                const response = await fetcher(context, API_ENDPOINTS.SET_CONSENT, {
                    method: 'POST',
                    body: submission
                });
                if (response.ok) {
                    console.log('Successfully resubmitted consent');
                    successfulSubmissions.push(j);
                }
            } catch (error) {
                console.warn('Failed to resend consent submission:', error);
            }
        }
        for(let k = successfulSubmissions.length - 1; k >= 0; k--){
            const index = successfulSubmissions[k];
            if (void 0 !== index) remainingSubmissions.splice(index, 1);
        }
        if (0 === remainingSubmissions.length) break;
        if (i < maxRetries - 1) await delay(1000 * (i + 1));
    }
    try {
        if ('undefined' != typeof window && window.localStorage) if (remainingSubmissions.length > 0) {
            window.localStorage.setItem(pendingSubmissionsKey, JSON.stringify(remainingSubmissions));
            console.log(`${remainingSubmissions.length} consent submissions still pending for future retry`);
        } else {
            window.localStorage.removeItem(pendingSubmissionsKey);
            console.log('All pending consent submissions processed successfully');
        }
    } catch (error) {
        console.warn('Error updating pending submissions storage:', error);
    }
}
function checkPendingIdentifyUserSubmissions(_context, processPendingSubmissions) {
    const pendingSubmissionsKey = 'c15t-pending-identify-user-submissions';
    if ('undefined' == typeof window || !window.localStorage) return;
    try {
        window.localStorage.setItem('c15t-storage-test-key', 'test');
        window.localStorage.removeItem('c15t-storage-test-key');
        const pendingSubmissionsStr = window.localStorage.getItem(pendingSubmissionsKey);
        if (!pendingSubmissionsStr) return;
        const pendingSubmissions = JSON.parse(pendingSubmissionsStr);
        if (!pendingSubmissions.length) return void window.localStorage.removeItem(pendingSubmissionsKey);
        console.log(`Found ${pendingSubmissions.length} pending identify-user submission(s) to retry`);
        setTimeout(()=>{
            processPendingSubmissions(pendingSubmissions);
        }, 2000);
    } catch (error) {
        console.warn('Failed to check for pending identify-user submissions:', error);
    }
}
async function processPendingIdentifyUserSubmissions(context, submissions) {
    const pendingSubmissionsKey = 'c15t-pending-identify-user-submissions';
    const maxRetries = 3;
    const remainingSubmissions = [
        ...submissions
    ];
    for(let i = 0; i < maxRetries && remainingSubmissions.length > 0; i++){
        const successfulSubmissions = [];
        for(let j = 0; j < remainingSubmissions.length; j++){
            const submission = remainingSubmissions[j];
            try {
                console.log('Retrying identify-user submission:', submission);
                const response = await fetcher(context, API_ENDPOINTS.IDENTIFY_CONSENT, {
                    method: 'PATCH',
                    body: submission
                });
                if (response.ok) {
                    console.log('Successfully resubmitted identify-user');
                    successfulSubmissions.push(j);
                }
            } catch (error) {
                console.warn('Failed to resend identify-user submission:', error);
            }
        }
        for(let k = successfulSubmissions.length - 1; k >= 0; k--){
            const index = successfulSubmissions[k];
            if (void 0 !== index) remainingSubmissions.splice(index, 1);
        }
        if (0 === remainingSubmissions.length) break;
        if (i < maxRetries - 1) await delay(1000 * (i + 1));
    }
    try {
        if ('undefined' != typeof window && window.localStorage) if (remainingSubmissions.length > 0) {
            window.localStorage.setItem(pendingSubmissionsKey, JSON.stringify(remainingSubmissions));
            console.log(`${remainingSubmissions.length} identify-user submissions still pending for future retry`);
        } else {
            window.localStorage.removeItem(pendingSubmissionsKey);
            console.log('All pending identify-user submissions processed successfully');
        }
    } catch (error) {
        console.warn('Error updating pending identify-user submissions storage:', error);
    }
}
async function offlineFallbackForSetConsent(storageConfig, options) {
    const pendingSubmissionsKey = 'c15t-pending-consent-submissions';
    try {
        if ('undefined' != typeof window) {
            saveConsentToStorage({
                consents: options?.body?.preferences || {},
                consentInfo: {
                    time: Date.now(),
                    identified: Boolean(options?.body?.externalSubjectId)
                }
            }, void 0, storageConfig);
            if (options?.body && window.localStorage) {
                let pendingSubmissions = [];
                try {
                    const storedSubmissions = window.localStorage.getItem(pendingSubmissionsKey);
                    if (storedSubmissions) pendingSubmissions = JSON.parse(storedSubmissions);
                } catch (e) {
                    console.warn('Error parsing pending submissions:', e);
                    pendingSubmissions = [];
                }
                const newSubmission = options.body;
                const isDuplicate = pendingSubmissions.some((submission)=>JSON.stringify(submission) === JSON.stringify(newSubmission));
                if (!isDuplicate) {
                    pendingSubmissions.push(newSubmission);
                    window.localStorage.setItem(pendingSubmissionsKey, JSON.stringify(pendingSubmissions));
                    console.log('Queued consent submission for retry on next page load');
                }
            }
        }
    } catch (error) {
        console.warn('Failed to write to localStorage in offline fallback:', error);
    }
    const response = fetcher_createResponseContext(true, null, null, null);
    if (response.ok && response.data) saveConsentToStorage({
        consents: options?.body?.preferences || {},
        consentInfo: {
            time: Date.now(),
            id: response.data.id,
            identified: Boolean(options?.body?.externalSubjectId)
        }
    }, void 0, storageConfig);
    if (options?.onSuccess) await options.onSuccess(response);
    return response;
}
async function setConsent(context, storageConfig, options) {
    const response = await withFallback(context, API_ENDPOINTS.SET_CONSENT, 'POST', options, async (fallbackOptions)=>offlineFallbackForSetConsent(storageConfig, fallbackOptions));
    if (response.ok && response.data) saveConsentToStorage({
        consents: options?.body?.preferences || {},
        consentInfo: {
            time: Date.now(),
            id: response.data.id,
            identified: Boolean(options?.body?.externalSubjectId)
        }
    }, void 0, storageConfig);
    return response;
}
async function offlineFallbackForConsentBanner(options) {
    let shouldShow = true;
    let hasLocalStorageAccess = false;
    try {
        if ('undefined' != typeof window && window.localStorage) {
            window.localStorage.setItem('c15t-storage-test-key', 'test');
            window.localStorage.removeItem('c15t-storage-test-key');
            hasLocalStorageAccess = true;
            const storedConsent = window.localStorage.getItem('c15t-consent');
            shouldShow = null === storedConsent;
        }
    } catch (error) {
        console.warn('Failed to access localStorage in offline fallback:', error);
        shouldShow = false;
    }
    const response = fetcher_createResponseContext(true, {
        showConsentBanner: shouldShow && hasLocalStorageAccess,
        jurisdiction: {
            code: 'NONE',
            message: 'Unknown (offline mode)'
        },
        location: {
            countryCode: null,
            regionCode: null
        },
        translations: enTranslations
    }, null, null);
    if (options?.onSuccess) await options.onSuccess(response);
    return response;
}
async function show_consent_banner_showConsentBanner(context, options) {
    try {
        const response = await fetcher(context, API_ENDPOINTS.SHOW_CONSENT_BANNER, {
            method: 'GET',
            ...options
        });
        if (response.ok) return response;
        console.warn('API request failed, falling back to offline mode for consent banner');
        return offlineFallbackForConsentBanner(options);
    } catch (error) {
        console.warn('Error fetching consent banner info, falling back to offline mode:', error);
        return offlineFallbackForConsentBanner(options);
    }
}
async function verifyConsent(context, options) {
    const response = await fetcher(context, API_ENDPOINTS.VERIFY_CONSENT, {
        method: 'POST',
        ...options
    });
    return response;
}
class C15tClient {
    backendURL;
    storageConfig;
    headers;
    customFetch;
    corsMode;
    retryConfig;
    fetcherContext;
    constructor(options){
        this.backendURL = options.backendURL.endsWith('/') ? options.backendURL.slice(0, -1) : options.backendURL;
        this.headers = {
            'Content-Type': 'application/json',
            ...options.headers
        };
        this.customFetch = options.customFetch;
        this.corsMode = options.corsMode || 'cors';
        this.storageConfig = options.storageConfig;
        this.retryConfig = {
            maxRetries: options.retryConfig?.maxRetries ?? DEFAULT_RETRY_CONFIG.maxRetries ?? 3,
            initialDelayMs: options.retryConfig?.initialDelayMs ?? DEFAULT_RETRY_CONFIG.initialDelayMs ?? 100,
            backoffFactor: options.retryConfig?.backoffFactor ?? DEFAULT_RETRY_CONFIG.backoffFactor ?? 2,
            retryableStatusCodes: options.retryConfig?.retryableStatusCodes ?? DEFAULT_RETRY_CONFIG.retryableStatusCodes,
            nonRetryableStatusCodes: options.retryConfig?.nonRetryableStatusCodes ?? DEFAULT_RETRY_CONFIG.nonRetryableStatusCodes,
            shouldRetry: options.retryConfig?.shouldRetry ?? DEFAULT_RETRY_CONFIG.shouldRetry,
            retryOnNetworkError: options.retryConfig?.retryOnNetworkError ?? DEFAULT_RETRY_CONFIG.retryOnNetworkError
        };
        this.fetcherContext = {
            backendURL: this.backendURL,
            headers: this.headers,
            customFetch: this.customFetch,
            corsMode: this.corsMode,
            retryConfig: this.retryConfig
        };
        this.checkPendingConsentSubmissions();
        this.checkPendingIdentifyUserSubmissions();
    }
    async showConsentBanner(options) {
        return show_consent_banner_showConsentBanner(this.fetcherContext, options);
    }
    async setConsent(options) {
        return setConsent(this.fetcherContext, this.storageConfig, options);
    }
    async verifyConsent(options) {
        return verifyConsent(this.fetcherContext, options);
    }
    async identifyUser(options) {
        return identifyUser(this.fetcherContext, this.storageConfig, options);
    }
    async $fetch(path, options) {
        return fetcher(this.fetcherContext, path, options);
    }
    checkPendingConsentSubmissions() {
        checkPendingConsentSubmissions(this.fetcherContext, (submissions)=>this.processPendingConsentSubmissions(submissions));
    }
    async processPendingConsentSubmissions(submissions) {
        return processPendingConsentSubmissions(this.fetcherContext, submissions);
    }
    checkPendingIdentifyUserSubmissions() {
        checkPendingIdentifyUserSubmissions(this.fetcherContext, (submissions)=>this.processPendingIdentifyUserSubmissions(submissions));
    }
    async processPendingIdentifyUserSubmissions(submissions) {
        return processPendingIdentifyUserSubmissions(this.fetcherContext, submissions);
    }
}
function utils_createErrorResponse(message, status = 500, code = 'HANDLER_ERROR', cause) {
    return createErrorResponse(message, status, code, cause);
}
async function executeHandler(endpointHandlers, handlerKey, options) {
    const handler = endpointHandlers[handlerKey];
    if (!handler) {
        const errorResponse = utils_createErrorResponse(`No endpoint handler found for '${String(handlerKey)}'`, 404, 'ENDPOINT_NOT_FOUND');
        if (options?.throw) throw new Error(`No endpoint handler found for '${String(handlerKey)}'`);
        return errorResponse;
    }
    try {
        const response = await handler(options);
        const normalizedResponse = {
            data: response.data,
            error: response.error,
            ok: response.ok ?? !response.error,
            response: response.response
        };
        return normalizedResponse;
    } catch (error) {
        const errorResponse = utils_createErrorResponse(error instanceof Error ? error.message : String(error), 0, 'HANDLER_ERROR', error);
        if (options?.throw) throw error;
        return errorResponse;
    }
}
async function customFetch(endpointHandlers, dynamicHandlers, path, options) {
    const endpointName = path.replace(LEADING_SLASHES_REGEX, '').split('/')[0];
    const handler = dynamicHandlers[path];
    if (handler) try {
        return await handler(options);
    } catch (error) {
        const errorResponse = utils_createErrorResponse(error instanceof Error ? error.message : String(error), 0, 'HANDLER_ERROR', error);
        return errorResponse;
    }
    if (!endpointName || !(endpointName in endpointHandlers)) {
        const errorResponse = utils_createErrorResponse(`No endpoint handler found for '${path}'`, 404, 'ENDPOINT_NOT_FOUND');
        return errorResponse;
    }
    return await executeHandler(endpointHandlers, endpointName, options);
}
async function identify_user_identifyUser(endpointHandlers, options) {
    return await executeHandler(endpointHandlers, 'identifyUser', options);
}
async function set_consent_setConsent(endpointHandlers, options) {
    return await executeHandler(endpointHandlers, 'setConsent', options);
}
async function custom_show_consent_banner_showConsentBanner(endpointHandlers, options) {
    return await executeHandler(endpointHandlers, 'showConsentBanner', options);
}
async function verify_consent_verifyConsent(endpointHandlers, options) {
    return await executeHandler(endpointHandlers, 'verifyConsent', options);
}
class CustomClient {
    endpointHandlers;
    dynamicHandlers = {};
    constructor(options){
        this.endpointHandlers = options.endpointHandlers;
    }
    async showConsentBanner(options) {
        return custom_show_consent_banner_showConsentBanner(this.endpointHandlers, options);
    }
    async setConsent(options) {
        return set_consent_setConsent(this.endpointHandlers, options);
    }
    async verifyConsent(options) {
        return verify_consent_verifyConsent(this.endpointHandlers, options);
    }
    async identifyUser(options) {
        return identify_user_identifyUser(this.endpointHandlers, options);
    }
    registerHandler(path, handler) {
        this.dynamicHandlers[path] = handler;
    }
    async $fetch(path, options) {
        return customFetch(this.endpointHandlers, this.dynamicHandlers, path, options);
    }
}
function utils_createResponseContext(data = null) {
    return createResponseContext(true, data);
}
async function handleOfflineResponse(options) {
    const emptyResponse = utils_createResponseContext();
    if (options?.onSuccess) await options.onSuccess(emptyResponse);
    return emptyResponse;
}
async function offline_identify_user_identifyUser(options) {
    return await handleOfflineResponse(options);
}
async function offline_set_consent_setConsent(storageConfig, options) {
    try {
        if ('undefined' != typeof window) saveConsentToStorage({
            consentInfo: {
                time: Date.now(),
                identified: Boolean(options?.body?.externalSubjectId)
            },
            consents: options?.body?.preferences || {}
        }, void 0, storageConfig);
    } catch (error) {
        console.warn('Failed to write to storage:', error);
    }
    return await handleOfflineResponse(options);
}
function checkJurisdiction(countryCode) {
    const jurisdictions = {
        EU: new Set([
            'AT',
            'BE',
            'BG',
            'HR',
            'CY',
            'CZ',
            'DK',
            'EE',
            'FI',
            'FR',
            'DE',
            'GR',
            'HU',
            'IE',
            'IT',
            'LV',
            'LT',
            'LU',
            'MT',
            'NL',
            'PL',
            'PT',
            'RO',
            'SK',
            'SI',
            'ES',
            'SE'
        ]),
        EEA: new Set([
            'IS',
            'NO',
            'LI'
        ]),
        UK: new Set([
            'GB'
        ]),
        CH: new Set([
            'CH'
        ]),
        BR: new Set([
            'BR'
        ]),
        CA: new Set([
            'CA'
        ]),
        AU: new Set([
            'AU'
        ]),
        JP: new Set([
            'JP'
        ]),
        KR: new Set([
            'KR'
        ])
    };
    let showConsentBanner = true;
    let jurisdictionCode = 'NONE';
    if (countryCode) {
        const normalizedCountryCode = countryCode.toUpperCase();
        showConsentBanner = false;
        const jurisdictionMap = [
            {
                sets: [
                    jurisdictions.EU,
                    jurisdictions.EEA,
                    jurisdictions.UK
                ],
                code: 'GDPR'
            },
            {
                sets: [
                    jurisdictions.CH
                ],
                code: 'CH'
            },
            {
                sets: [
                    jurisdictions.BR
                ],
                code: 'BR'
            },
            {
                sets: [
                    jurisdictions.CA
                ],
                code: 'PIPEDA'
            },
            {
                sets: [
                    jurisdictions.AU
                ],
                code: 'AU'
            },
            {
                sets: [
                    jurisdictions.JP
                ],
                code: 'APPI'
            },
            {
                sets: [
                    jurisdictions.KR
                ],
                code: 'PIPA'
            }
        ];
        for (const { sets, code } of jurisdictionMap)if (sets.some((set)=>set.has(normalizedCountryCode))) {
            jurisdictionCode = code;
            showConsentBanner = true;
            break;
        }
    }
    const message = '';
    return {
        showConsentBanner,
        jurisdictionCode,
        message
    };
}
async function offline_show_consent_banner_showConsentBanner(options) {
    const country = options?.headers?.['x-c15t-country'] ?? 'GB';
    const region = options?.headers?.['x-c15t-region'] ?? null;
    const language = options?.headers?.['accept-language'] ?? defaultTranslationConfig.defaultLanguage ?? 'en';
    const { showConsentBanner, jurisdictionCode, message } = checkJurisdiction(country);
    const response = utils_createResponseContext({
        showConsentBanner: showConsentBanner,
        jurisdiction: {
            code: jurisdictionCode,
            message: message
        },
        branding: 'c15t',
        location: {
            countryCode: country,
            regionCode: region
        },
        translations: {
            language: language,
            translations: defaultTranslationConfig.translations[language]
        }
    });
    if (options?.onSuccess) await options.onSuccess(response);
    return response;
}
async function offline_verify_consent_verifyConsent(options) {
    return await handleOfflineResponse(options);
}
class OfflineClient {
    storageConfig;
    constructor(storageConfig){
        this.storageConfig = storageConfig;
    }
    async showConsentBanner(options) {
        return offline_show_consent_banner_showConsentBanner(options);
    }
    async setConsent(options) {
        return offline_set_consent_setConsent(this.storageConfig, options);
    }
    async verifyConsent(options) {
        return offline_verify_consent_verifyConsent(options);
    }
    async identifyUser(options) {
        return offline_identify_user_identifyUser(options);
    }
    async $fetch(_path, options) {
        return await handleOfflineResponse(options);
    }
}
const DEFAULT_BACKEND_URL = '/api/c15t';
const DEFAULT_CLIENT_MODE = 'c15t';
const clientRegistry = new Map();
function serializeStorageConfig(storageConfig) {
    if (!storageConfig) return '';
    const sorted = Object.keys(storageConfig).sort().map((key)=>{
        const value = storageConfig[key];
        if (null == value) return `${key}:null`;
        return `${key}:${String(value)}`;
    }).join('|');
    return sorted;
}
function getClientCacheKey(options) {
    const storageConfigPart = serializeStorageConfig(options.storageConfig);
    const storageKey = storageConfigPart ? `:storage:${storageConfigPart}` : '';
    if ('offline' === options.mode) return `offline${storageKey}`;
    if ('custom' === options.mode) {
        const handlerKeys = Object.keys(options.endpointHandlers || {}).sort().join(',');
        return `custom:${handlerKeys}${storageKey}`;
    }
    let headersPart = '';
    if ('headers' in options && options.headers) {
        const headerKeys = Object.keys(options.headers).sort();
        headersPart = `:headers:${headerKeys.map((k)=>`${k}=${options.headers?.[k]}`).join(',')}`;
    }
    return `c15t:${options.backendURL || ''}${headersPart}${storageKey}`;
}
function configureConsentManager(options) {
    const cacheKey = getClientCacheKey(options);
    if (clientRegistry.has(cacheKey)) {
        if ('offline' !== options.mode && 'custom' !== options.mode && 'headers' in options && options.headers) {
            const existingClient = clientRegistry.get(cacheKey);
            if (existingClient instanceof C15tClient) existingClient.headers = {
                'Content-Type': 'application/json',
                ...options.headers
            };
        }
        const existingClient = clientRegistry.get(cacheKey);
        if (existingClient) return new Proxy(existingClient, {
            get (target, prop) {
                return target[prop];
            }
        });
    }
    const mode = options.mode || DEFAULT_CLIENT_MODE;
    let client;
    switch(mode){
        case 'custom':
            {
                const customOptions = options;
                client = new CustomClient({
                    endpointHandlers: customOptions.endpointHandlers
                });
                break;
            }
        case 'offline':
            client = new OfflineClient(options.storageConfig);
            break;
        default:
            {
                const c15tOptions = options;
                client = new C15tClient({
                    backendURL: c15tOptions.backendURL || DEFAULT_BACKEND_URL,
                    headers: c15tOptions.headers,
                    customFetch: c15tOptions.customFetch,
                    retryConfig: c15tOptions.retryConfig,
                    storageConfig: options.storageConfig
                });
                break;
            }
    }
    clientRegistry.set(cacheKey, client);
    return client;
}
function validateNonEmptyConditions(conditions, conditionType) {
    if (0 === conditions.length) throw new TypeError(`${conditionType} condition cannot be empty`);
}
function evaluateCategoryCondition(category, consents) {
    if (!(category in consents)) throw new Error(`Consent category "${category}" not found in consent state`);
    return consents[category] || false;
}
function evaluateAndCondition(andCondition, consents) {
    const andConditions = Array.isArray(andCondition) ? andCondition : [
        andCondition
    ];
    validateNonEmptyConditions(andConditions, 'AND');
    return andConditions.every((subCondition)=>evaluateConditionRecursive(subCondition, consents));
}
function evaluateOrCondition(orCondition, consents) {
    const orConditions = Array.isArray(orCondition) ? orCondition : [
        orCondition
    ];
    validateNonEmptyConditions(orConditions, 'OR');
    return orConditions.some((subCondition)=>evaluateConditionRecursive(subCondition, consents));
}
function evaluateConditionRecursive(condition, consents) {
    if ('string' == typeof condition) return evaluateCategoryCondition(condition, consents);
    if ('object' == typeof condition && null !== condition) {
        if ('and' in condition) return evaluateAndCondition(condition.and, consents);
        if ('or' in condition) return evaluateOrCondition(condition.or, consents);
        if ('not' in condition) return !evaluateConditionRecursive(condition.not, consents);
    }
    throw new TypeError(`Invalid condition structure: ${JSON.stringify(condition)}`);
}
function has_has(condition, consents) {
    return evaluateConditionRecursive(condition, consents);
}
function extractConsentNamesFromCondition(condition) {
    const categories = new Set();
    function recurse(cond) {
        if ('string' == typeof cond) return void categories.add(cond);
        if ('object' == typeof cond && null !== cond) {
            if ('and' in cond) {
                const conditions = Array.isArray(cond.and) ? cond.and : [
                    cond.and
                ];
                conditions.forEach(recurse);
            } else if ('or' in cond) {
                const conditions = Array.isArray(cond.or) ? cond.or : [
                    cond.or
                ];
                conditions.forEach(recurse);
            } else if ('not' in cond) recurse(cond.not);
        }
    }
    recurse(condition);
    return Array.from(categories);
}
function createDefaultConsentState() {
    return {
        experience: false,
        functionality: false,
        marketing: false,
        measurement: false,
        necessary: true
    };
}
function determineRequiredConsent(iframe) {
    const categoryAttr = iframe.getAttribute('data-category');
    if (!categoryAttr) return;
    if (!allConsentNames.includes(categoryAttr)) throw new Error(`Invalid category attribute "${categoryAttr}" on iframe. Must be one of: ${allConsentNames.join(', ')}`);
    return categoryAttr;
}
function processIframeElement(iframe, consents) {
    const dataSrc = iframe.getAttribute('data-src');
    const requiredConsent = determineRequiredConsent(iframe);
    if (!requiredConsent) return;
    const hasConsent = has_has(requiredConsent, consents);
    if (hasConsent) {
        if (dataSrc && !iframe.src) {
            iframe.src = dataSrc;
            iframe.removeAttribute('data-src');
        }
    } else if (iframe.src) iframe.removeAttribute('src');
}
function createIframeBlocker(config = {}, initialConsents) {
    const blockerConfig = {
        disableAutomaticBlocking: false,
        ...config
    };
    let consents = initialConsents || createDefaultConsentState();
    function processIframes() {
        const iframes = document.querySelectorAll('iframe');
        iframes.forEach((iframe)=>{
            processIframeElement(iframe, consents);
        });
    }
    function setupMutationObserver() {
        const observer = new MutationObserver((mutations)=>{
            mutations.forEach((mutation)=>{
                mutation.addedNodes.forEach((node)=>{
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        const element = node;
                        if (element.tagName && 'IFRAME' === element.tagName.toUpperCase()) processIframeElement(element, consents);
                        const iframes = element.querySelectorAll?.('iframe');
                        if (iframes) iframes.forEach((iframe)=>{
                            processIframeElement(iframe, consents);
                        });
                    }
                });
            });
        });
        observer.observe(document.body, {
            childList: true,
            subtree: true
        });
        return observer;
    }
    let mutationObserver = null;
    if (!blockerConfig.disableAutomaticBlocking) {
        processIframes();
        mutationObserver = setupMutationObserver();
    }
    return {
        updateConsents: (newConsents)=>{
            consents = {
                ...consents,
                ...newConsents
            };
            processIframes();
        },
        processIframes,
        destroy: ()=>{
            if (mutationObserver) {
                mutationObserver.disconnect();
                mutationObserver = null;
            }
        }
    };
}
function getIframeConsentCategories() {
    if ('undefined' == typeof document) return [];
    const iframes = document.querySelectorAll('iframe[data-category]');
    const categories = new Set();
    if (!iframes) return [];
    iframes.forEach((iframe)=>{
        const categoryAttr = iframe.getAttribute('data-category');
        if (!categoryAttr) return;
        const category = categoryAttr.trim();
        if (allConsentNames.includes(category)) categories.add(category);
    });
    return Array.from(categories);
}
function processAllIframes(consents) {
    if ('undefined' == typeof document) return;
    const iframes = document.querySelectorAll('iframe');
    if (!iframes) return;
    iframes.forEach((iframe)=>{
        processIframeElement(iframe, consents);
    });
}
function setupIframeObserver(getConsents, onCategoriesDiscovered) {
    const observer = new MutationObserver((mutations)=>{
        const currentConsents = getConsents();
        let hasNewCategories = false;
        mutations.forEach((mutation)=>{
            mutation.addedNodes.forEach((node)=>{
                if (node.nodeType === Node.ELEMENT_NODE) {
                    const element = node;
                    if (element.tagName && 'IFRAME' === element.tagName.toUpperCase()) {
                        processIframeElement(element, currentConsents);
                        if (element.hasAttribute('data-category')) hasNewCategories = true;
                    }
                    const iframes = element.querySelectorAll?.('iframe');
                    if (iframes && iframes.length > 0) iframes.forEach((iframe)=>{
                        processIframeElement(iframe, currentConsents);
                        if (iframe.hasAttribute('data-category')) hasNewCategories = true;
                    });
                }
            });
        });
        if (hasNewCategories && onCategoriesDiscovered) {
            const categories = getIframeConsentCategories();
            if (categories.length > 0) onCategoriesDiscovered(categories);
        }
    });
    observer.observe(document.body, {
        childList: true,
        subtree: true
    });
    return observer;
}
function generateRandomScriptId() {
    if ('undefined' != typeof crypto && crypto.randomUUID) return crypto.randomUUID().replace(/-/g, '').substring(0, 8);
    if ('undefined' != typeof crypto && crypto.getRandomValues) {
        const array = new Uint8Array(4);
        crypto.getRandomValues(array);
        return Array.from(array, (byte)=>byte.toString(36)).join('').padEnd(8, '0').substring(0, 8);
    }
    const randomStr = Math.random().toString(36).substring(2);
    return randomStr.padEnd(8, '0').substring(0, 8);
}
function getScriptElementId(scriptId, anonymizeId, scriptIdMap) {
    if (anonymizeId) {
        if (scriptIdMap[scriptId]) return scriptIdMap[scriptId];
        scriptIdMap[scriptId] = generateRandomScriptId();
        return scriptIdMap[scriptId];
    }
    return `c15t-script-${scriptId}`;
}
const loadedScripts = new Map();
function hasLoadedScript(src) {
    return loadedScripts.has(src);
}
function getLoadedScript(src) {
    return loadedScripts.get(src);
}
function setLoadedScript(src, element) {
    loadedScripts.set(src, element);
}
function deleteLoadedScript(src) {
    loadedScripts.delete(src);
}
function utils_getLoadedScriptsSnapshot() {
    return loadedScripts;
}
function loadScripts(scripts, consents, scriptIdMap = {}) {
    const loadedScriptIds = [];
    scripts.forEach((script)=>{
        if (!script.alwaysLoad && !has_has(script.category, consents)) return;
        if (hasLoadedScript(script.id)) return void script.onConsentChange?.({
            id: script.id,
            elementId: getScriptElementId(script.id, false !== script.anonymizeId, scriptIdMap),
            hasConsent: has_has(script.category, consents),
            consents
        });
        if (script.src && script.textContent) throw new Error(`Script '${script.id}' cannot have both 'src' and 'textContent'. Choose one.`);
        if (!script.src && !script.textContent && !script.callbackOnly) throw new Error(`Script '${script.id}' must have either 'src', 'textContent', or 'callbackOnly' set to true.`);
        if (true === script.callbackOnly) {
            const shouldAnonymize = false !== script.anonymizeId;
            const elementId = getScriptElementId(script.id, shouldAnonymize, scriptIdMap);
            const callbackInfo = {
                id: script.id,
                elementId,
                consents,
                hasConsent: has_has(script.category, consents)
            };
            if (script.onBeforeLoad) script.onBeforeLoad(callbackInfo);
            if (script.onLoad) script.onLoad(callbackInfo);
            setLoadedScript(script.id, null);
            loadedScriptIds.push(script.id);
            return;
        }
        const shouldAnonymize = false !== script.anonymizeId;
        const elementId = getScriptElementId(script.id, shouldAnonymize, scriptIdMap);
        if (true === script.persistAfterConsentRevoked) {
            const existingElement = document.getElementById(elementId);
            if (existingElement) {
                const callbackInfo = {
                    id: script.id,
                    hasConsent: has_has(script.category, consents),
                    elementId,
                    consents,
                    element: existingElement
                };
                script.onConsentChange?.(callbackInfo);
                script.onLoad?.(callbackInfo);
                setLoadedScript(script.id, existingElement);
                loadedScriptIds.push(script.id);
                return;
            }
        }
        const scriptElement = document.createElement("script");
        scriptElement.id = elementId;
        if (script.src) scriptElement.src = script.src;
        else if (script.textContent) scriptElement.textContent = script.textContent;
        if (script.fetchPriority) scriptElement.fetchPriority = script.fetchPriority;
        if (script.async) scriptElement.async = true;
        if (script.defer) scriptElement.defer = true;
        if (script.nonce) scriptElement.nonce = script.nonce;
        if (script.attributes) Object.entries(script.attributes).forEach(([key, value])=>{
            scriptElement.setAttribute(key, value);
        });
        const callbackInfo = {
            id: script.id,
            hasConsent: has_has(script.category, consents),
            elementId,
            consents,
            element: scriptElement
        };
        if (script.onLoad) if (script.textContent) setTimeout(()=>{
            script.onLoad?.({
                ...callbackInfo
            });
        }, 0);
        else scriptElement.addEventListener('load', ()=>{
            script.onLoad?.({
                ...callbackInfo
            });
        });
        if (script.onError) script.textContent || scriptElement.addEventListener('error', ()=>{
            script.onError?.({
                ...callbackInfo,
                error: new Error(`Failed to load script: ${script.src}`)
            });
        });
        if (script.onBeforeLoad) script.onBeforeLoad(callbackInfo);
        const target = script.target ?? 'head';
        const targetElement = 'body' === target ? document.body : document.head;
        if (!targetElement) throw new Error(`Document ${target} is not available for script injection`);
        targetElement.appendChild(scriptElement);
        setLoadedScript(script.id, scriptElement);
        loadedScriptIds.push(script.id);
    });
    return loadedScriptIds;
}
function unloadScripts(scripts, consents, scriptIdMap = {}) {
    const unloadedScriptIds = [];
    scripts.forEach((script)=>{
        if (!hasLoadedScript(script.id)) return;
        if (script.alwaysLoad) return;
        if (!has_has(script.category, consents)) {
            const scriptElement = getLoadedScript(script.id);
            const elementId = scriptIdMap[script.id] || `c15t-script-${script.id}`;
            if (true === script.callbackOnly || null === scriptElement) {
                const callbackInfo = {
                    id: script.id,
                    elementId,
                    consents,
                    hasConsent: has_has(script.category, consents)
                };
                if (script.onDelete) script.onDelete(callbackInfo);
                deleteLoadedScript(script.id);
                unloadedScriptIds.push(script.id);
            } else if (scriptElement) {
                const callbackInfo = {
                    id: script.id,
                    elementId,
                    consents,
                    hasConsent: has_has(script.category, consents),
                    element: scriptElement
                };
                if (script.onDelete) script.onDelete(callbackInfo);
                if (script.persistAfterConsentRevoked) {
                    deleteLoadedScript(script.id);
                    unloadedScriptIds.push(script.id);
                } else {
                    scriptElement.remove();
                    deleteLoadedScript(script.id);
                    unloadedScriptIds.push(script.id);
                }
            }
        }
    });
    return unloadedScriptIds;
}
function core_updateScripts(scripts, consents, scriptIdMap = {}) {
    const unloaded = unloadScripts(scripts, consents, scriptIdMap);
    const loaded = loadScripts(scripts, consents, scriptIdMap);
    return {
        loaded,
        unloaded
    };
}
function isScriptLoaded(scriptId) {
    return hasLoadedScript(scriptId);
}
function getLoadedScriptIds() {
    return Array.from(utils_getLoadedScriptsSnapshot().keys());
}
function reloadScript(scriptId, scripts, consents, scriptIdMap = {}) {
    const script = scripts.find((s)=>s.id === scriptId);
    if (!script) return false;
    if (hasLoadedScript(scriptId)) {
        const scriptElement = getLoadedScript(scriptId);
        const elementId = scriptIdMap[scriptId] || `c15t-script-${scriptId}`;
        if (true === script.callbackOnly || null === scriptElement) {
            const callbackInfo = {
                id: scriptId,
                elementId,
                consents,
                hasConsent: has_has(script.category, consents)
            };
            if (script.onDelete) script.onDelete(callbackInfo);
            deleteLoadedScript(scriptId);
        } else if (scriptElement) {
            const callbackInfo = {
                id: scriptId,
                elementId,
                consents,
                hasConsent: has_has(script.category, consents),
                element: scriptElement
            };
            if (script.onDelete) script.onDelete(callbackInfo);
            if (!script.persistAfterConsentRevoked) scriptElement.remove();
            deleteLoadedScript(scriptId);
        }
    }
    if (!script.alwaysLoad && !has_has(script.category, consents)) return false;
    loadScripts([
        script
    ], consents, scriptIdMap);
    return true;
}
function createScriptManager(getState, setState, trackingBlocker) {
    const updateScriptsFn = ()=>{
        const { scripts, consents, scriptIdMap } = getState();
        const result = core_updateScripts(scripts, consents, scriptIdMap);
        const newLoadedScripts = {
            ...getState().loadedScripts
        };
        result.loaded.forEach((id)=>{
            newLoadedScripts[id] = true;
        });
        result.unloaded.forEach((id)=>{
            newLoadedScripts[id] = false;
        });
        setState({
            loadedScripts: newLoadedScripts
        });
        return result;
    };
    return {
        updateScripts: ()=>updateScriptsFn(),
        setScripts: (scripts)=>{
            if (trackingBlocker) trackingBlocker.destroy();
            const state = getState();
            const newScriptIdMap = {
                ...state.scriptIdMap
            };
            scripts.forEach((script)=>{
                if (false !== script.anonymizeId) newScriptIdMap[script.id] = generateRandomScriptId();
            });
            const newCategories = scripts.flatMap((script)=>extractConsentNamesFromCondition(script.category));
            const allCategories = [
                ...new Set([
                    ...state.gdprTypes,
                    ...newCategories
                ])
            ];
            setState({
                scripts: [
                    ...state.scripts,
                    ...scripts
                ],
                scriptIdMap: newScriptIdMap,
                gdprTypes: allCategories
            });
            updateScriptsFn();
        },
        removeScript: (scriptId)=>{
            const state = getState();
            const script = state.scripts.find((s)=>s.id === scriptId);
            if (hasLoadedScript(scriptId)) {
                const scriptElement = getLoadedScript(scriptId);
                if (scriptElement) {
                    const elementId = state.scriptIdMap[scriptId] || `c15t-script-${scriptId}`;
                    const callbackInfo = {
                        id: scriptId,
                        elementId,
                        consents: state.consents,
                        element: scriptElement,
                        hasConsent: has_has(script?.category ?? 'necessary', state.consents)
                    };
                    if (script?.onDelete) script.onDelete(callbackInfo);
                    scriptElement.remove();
                    deleteLoadedScript(scriptId);
                }
            }
            const newScriptIdMap = {
                ...state.scriptIdMap
            };
            delete newScriptIdMap[scriptId];
            setState({
                scripts: state.scripts.filter((script)=>script.id !== scriptId),
                loadedScripts: {
                    ...state.loadedScripts,
                    [scriptId]: false
                },
                scriptIdMap: newScriptIdMap
            });
        },
        reloadScript: (scriptId)=>{
            const state = getState();
            return reloadScript(scriptId, state.scripts, state.consents, state.scriptIdMap);
        },
        isScriptLoaded: (scriptId)=>isScriptLoaded(scriptId),
        getLoadedScriptIds: ()=>getLoadedScriptIds()
    };
}
const DEFAULT_DOMAIN_CONSENT_MAP = {
    'www.google-analytics.com': 'measurement',
    'analytics.google.com': 'measurement',
    'www.googletagmanager.com': 'measurement',
    'stats.g.doubleclick.net': 'measurement',
    'ampcid.google.com': 'measurement',
    'analytics.twitter.com': 'measurement',
    'analytics.pinterest.com': 'measurement',
    'dc.services.visualstudio.com': 'measurement',
    'www.clarity.ms': 'measurement',
    'www.hotjar.com': 'measurement',
    'static.hotjar.com': 'measurement',
    "script.hotjar.com": 'measurement',
    'insights.hotjar.com': 'measurement',
    'mouseflow.com': 'measurement',
    'api.mouseflow.com': 'measurement',
    'tools.mouseflow.com': 'measurement',
    'cdn.heapanalytics.com': 'measurement',
    'plausible.io': 'measurement',
    'matomo.cloud': 'measurement',
    'matomo.org': 'measurement',
    'mixpanel.com': 'measurement',
    'api.mixpanel.com': 'measurement',
    'sentry.io': 'measurement',
    'browser.sentry-cdn.com': 'measurement',
    'js.monitor.azure.com': 'measurement',
    'stats.wp.com': 'measurement',
    'pixel.wp.com': 'measurement',
    'analytics.amplitude.com': 'measurement',
    'api2.amplitude.com': 'measurement',
    'cdn.amplitude.com': 'measurement',
    'api.segment.io': 'measurement',
    'cdn.segment.com': 'measurement',
    'api.segment.com': 'measurement',
    'pendo.io': 'measurement',
    'data.pendo.io': 'measurement',
    'cdn.pendo.io': 'measurement',
    'connect.facebook.net': 'marketing',
    'platform.twitter.com': 'marketing',
    'platform.linkedin.com': 'marketing',
    'www.googleadservices.com': 'marketing',
    'doubleclick.net': 'marketing',
    'googleads.g.doubleclick.net': 'marketing',
    'ad.doubleclick.net': 'marketing',
    'www.facebook.com': 'marketing',
    'ads.linkedin.com': 'marketing',
    'ads-api.tiktok.com': 'marketing',
    'analytics.tiktok.com': 'marketing',
    'business.tiktok.com': 'marketing',
    'ads.pinterest.com': 'marketing',
    'log.pinterest.com': 'marketing',
    'ads-twitter.com': 'marketing',
    'static.ads-twitter.com': 'marketing',
    'advertising.twitter.com': 'marketing',
    'ads.yahoo.com': 'marketing',
    'sp.analytics.yahoo.com': 'marketing',
    'gemini.yahoo.com': 'marketing',
    'adroll.com': 'marketing',
    'a.adroll.com': 'marketing',
    'd.adroll.com': 'marketing',
    's.adroll.com': 'marketing',
    'adform.net': 'marketing',
    'track.adform.net': 'marketing',
    'dmp.adform.net': 'marketing',
    'criteo.com': 'marketing',
    'static.criteo.net': 'marketing',
    'bidder.criteo.com': 'marketing',
    'dynamic.criteo.com': 'marketing',
    'gum.criteo.com': 'marketing',
    'taboola.com': 'marketing',
    'cdn.taboola.com': 'marketing',
    'trc.taboola.com': 'marketing',
    'outbrain.com': 'marketing',
    'widgets.outbrain.com': 'marketing',
    'tr.outbrain.com': 'marketing',
    'amplify.outbrain.com': 'marketing',
    'bing.com': 'marketing',
    'bat.bing.com': 'marketing',
    'clarity.ms': 'marketing',
    'quantserve.com': 'marketing',
    'secure.quantserve.com': 'marketing',
    'pixel.quantserve.com': 'marketing',
    'exelator.com': 'marketing',
    'load.exelator.com': 'marketing',
    'api.exelator.com': 'marketing',
    'ad.360yield.com': 'marketing',
    'match.360yield.com': 'marketing',
    'ad.turn.com': 'marketing',
    'r.turn.com': 'marketing',
    'd.turn.com': 'marketing',
    'cdn.jsdelivr.net': 'functionality',
    'ajax.googleapis.com': 'functionality',
    'fonts.googleapis.com': 'functionality',
    'maps.googleapis.com': 'functionality',
    'www.recaptcha.net': 'functionality',
    'recaptcha.net': 'functionality',
    'www.gstatic.com': 'functionality',
    'fonts.gstatic.com': 'functionality',
    'cdnjs.cloudflare.com': 'functionality',
    'unpkg.com': 'functionality',
    'code.jquery.com': 'functionality',
    'maxcdn.bootstrapcdn.com': 'functionality',
    'cdn.datatables.net': 'functionality',
    'js.stripe.com': 'functionality',
    'api.stripe.com': 'functionality',
    'checkout.stripe.com': 'functionality',
    'js.braintreegateway.com': 'functionality',
    'api.braintreegateway.com': 'functionality',
    'cdn.shopify.com': 'functionality',
    'js.intercomcdn.com': 'functionality',
    'widget.intercom.io': 'functionality',
    'cdn.auth0.com': 'functionality',
    'js.pusher.com': 'functionality',
    'sockjs.pusher.com': 'functionality',
    'app.optimizely.com': 'experience',
    'cdn.optimizely.com': 'experience',
    'logx.optimizely.com': 'experience',
    'cdn.mouseflow.com': 'experience',
    'fullstory.com': 'experience',
    'rs.fullstory.com': 'experience',
    'edge.fullstory.com': 'experience',
    'vwo.com': 'experience',
    'dev.visualwebsiteoptimizer.com': 'experience',
    'assets.adobedtm.com': 'experience',
    'cdn.tt.omtrdc.net': 'experience',
    'demdex.net': 'experience',
    'sc.omtrdc.net': 'experience',
    'crazyegg.com': 'experience',
    "script.crazyegg.com": 'experience',
    'tracking.crazyegg.com': 'experience',
    'luckyorange.com': 'experience',
    'cdn.luckyorange.com': 'experience',
    'w1.luckyorange.com': 'experience',
    'upload.luckyorange.com': 'experience',
    'clicktale.net': 'experience',
    'cdn.clicktale.net': 'experience',
    'conductor.clicktale.net': 'experience',
    'userzoom.com': 'experience',
    'cdn.userzoom.com': 'experience',
    'api.userzoom.com': 'experience',
    'contentsquare.net': 'experience',
    't.contentsquare.net': 'experience',
    'app.contentsquare.com': 'experience'
};
const tracking_domains = DEFAULT_DOMAIN_CONSENT_MAP;
function tracking_blocker_createDefaultConsentState() {
    return {
        experience: false,
        functionality: false,
        marketing: false,
        measurement: false,
        necessary: true
    };
}
const WWW_PREFIX_REGEX = /^www\./;
const PORT_NUMBER_REGEX = /:\d+$/;
function createTrackingBlocker(config = {}, initialConsents) {
    const blockerConfig = {
        disableAutomaticBlocking: false,
        ...config,
        domainConsentMap: config.overrideDomainConsentMap ? config.domainConsentMap : {
            ...tracking_domains,
            ...config.domainConsentMap
        }
    };
    let consents = initialConsents || tracking_blocker_createDefaultConsentState();
    const originalFetch = window.fetch;
    const originalXHR = window.XMLHttpRequest;
    function normalizeDomain(domain) {
        return domain.toLowerCase().replace(WWW_PREFIX_REGEX, '').replace(PORT_NUMBER_REGEX, '').trim();
    }
    function findMatchingDomain(domain, domainMap) {
        const normalizedDomain = normalizeDomain(domain);
        const directMatch = domainMap[normalizedDomain];
        if (directMatch) return directMatch;
        for (const [mapDomain, consent] of Object.entries(domainMap)){
            const normalizedMapDomain = normalizeDomain(mapDomain);
            if (normalizedDomain.endsWith(`.${normalizedMapDomain}`) || normalizedDomain === normalizedMapDomain) return consent;
        }
    }
    function isRequestAllowed(url) {
        try {
            const domain = new URL(url).hostname;
            const requiredConsent = findMatchingDomain(domain, blockerConfig.domainConsentMap || {});
            if (!requiredConsent) return true;
            const isAllowed = true === consents[requiredConsent];
            return isAllowed;
        } catch  {
            return true;
        }
    }
    function dispatchConsentBlockedEvent(url) {
        document.dispatchEvent(new CustomEvent('ConsentBlockedRequest', {
            detail: {
                url
            }
        }));
    }
    function interceptNetworkRequests() {
        if (window.fetch === originalFetch) window.fetch = async (input, init)=>{
            const url = input instanceof Request ? input.url : input.toString();
            if (!isRequestAllowed(url)) {
                dispatchConsentBlockedEvent(url);
                return Promise.reject(new Error(`Request to ${url} blocked due to missing consent`));
            }
            return await originalFetch.call(window, input, init);
        };
        if (window.XMLHttpRequest === originalXHR) window.XMLHttpRequest = class extends originalXHR {
            open(method, url, async = true, username, password) {
                if (!isRequestAllowed(url.toString())) {
                    dispatchConsentBlockedEvent(url.toString());
                    throw new Error(`Request to ${url} blocked due to missing consent`);
                }
                super.open(method, url, async, username, password);
            }
        };
    }
    function restoreOriginalRequests() {
        if (window.fetch !== originalFetch) window.fetch = originalFetch;
        if (window.XMLHttpRequest !== originalXHR) window.XMLHttpRequest = originalXHR;
    }
    if (!blockerConfig.disableAutomaticBlocking) interceptNetworkRequests();
    return {
        updateConsents: (newConsents)=>{
            consents = {
                ...consents,
                ...newConsents
            };
        },
        destroy: ()=>{
            restoreOriginalRequests();
        }
    };
}
function getEffectiveConsents(consents, honorDoNotTrack) {
    if (honorDoNotTrack && 'undefined' != typeof window && '1' === window.navigator.doNotTrack) return Object.keys(consents).reduce((acc, key)=>{
        if (key in consents) acc[key] = 'necessary' === key;
        return acc;
    }, {});
    return consents;
}
function hasConsentFor(consentType, consents, honorDoNotTrack) {
    const effectiveConsents = getEffectiveConsents(consents, honorDoNotTrack);
    return effectiveConsents[consentType] || false;
}
function consent_utils_hasConsented(consentInfo) {
    return null !== consentInfo;
}
function checkLocalStorageAccess(set) {
    try {
        if (window.localStorage) {
            window.localStorage.setItem('c15t-storage-test-key', 'test');
            window.localStorage.removeItem('c15t-storage-test-key');
            return true;
        }
    } catch (error) {
        console.warn('localStorage not available, skipping consent banner:', error);
        set({
            isLoadingConsentInfo: false,
            showPopup: false
        });
    }
    return false;
}
function updateStore(data, { set, get, initialTranslationConfig, trackingBlocker }, hasLocalStorageAccess) {
    const { consentInfo, ignoreGeoLocation, callbacks, setDetectedCountry } = get();
    const { translations, location, showConsentBanner } = data;
    const shouldAutoGrantConsents = data.jurisdiction?.code === 'NONE' && !data.showConsentBanner;
    const updatedStore = {
        isLoadingConsentInfo: false,
        branding: data.branding ?? 'c15t',
        ...null === consentInfo ? {
            showPopup: showConsentBanner && hasLocalStorageAccess || ignoreGeoLocation
        } : {},
        ...shouldAutoGrantConsents && {
            consents: {
                necessary: true,
                functionality: true,
                experience: true,
                marketing: true,
                measurement: true
            }
        },
        locationInfo: {
            countryCode: location?.countryCode ?? null,
            regionCode: location?.regionCode ?? null,
            jurisdiction: data.jurisdiction?.code ?? null,
            jurisdictionMessage: data.jurisdiction?.message ?? null
        },
        jurisdictionInfo: data.jurisdiction
    };
    translations?.language && translations?.translations;
    {
        const translationConfig = prepareTranslationConfig({
            translations: {
                [translations.language]: translations.translations
            },
            disableAutoLanguageSwitch: true,
            defaultLanguage: translations.language
        }, initialTranslationConfig);
        updatedStore.translationConfig = translationConfig;
    }
    if (data.location?.countryCode) setDetectedCountry(data.location.countryCode);
    updatedStore.hasFetchedBanner = true;
    updatedStore.lastBannerFetchData = data;
    set(updatedStore);
    if (shouldAutoGrantConsents) callbacks?.onConsentSet?.({
        preferences: {
            necessary: true,
            functionality: true,
            experience: true,
            marketing: true,
            measurement: true
        }
    });
    callbacks?.onBannerFetched?.({
        showConsentBanner: data.showConsentBanner,
        jurisdiction: data.jurisdiction,
        location: data.location,
        translations: {
            language: translations.language,
            translations: translations.translations
        }
    });
    trackingBlocker?.updateConsents(get().consents);
    get().updateScripts();
}
async function fetchConsentBannerInfo(config) {
    const { get, set, manager, initialData } = config;
    const { callbacks } = get();
    if ('undefined' == typeof window) return;
    const hasLocalStorageAccess = checkLocalStorageAccess(set);
    if (!hasLocalStorageAccess) return;
    set({
        isLoadingConsentInfo: true
    });
    if (initialData && !get().overrides) {
        const showConsentBanner = await initialData;
        if (showConsentBanner) {
            updateStore(showConsentBanner, config, true);
            return showConsentBanner;
        }
    }
    try {
        const language = get().overrides?.language;
        const country = get().overrides?.country;
        const region = get().overrides?.region;
        const { data, error } = await manager.showConsentBanner({
            headers: {
                ...language && {
                    'accept-language': language
                },
                ...country && {
                    'x-c15t-country': country
                },
                ...region && {
                    'x-c15t-region': region
                }
            },
            onError: callbacks.onError ? (context)=>{
                if (callbacks.onError) callbacks.onError({
                    error: context.error?.message || 'Unknown error'
                });
            } : void 0
        });
        if (error || !data) throw new Error(`Failed to fetch consent banner info: ${error?.message}`);
        updateStore(data, config, hasLocalStorageAccess);
        return data;
    } catch (error) {
        console.error('Error fetching consent banner information:', error);
        set({
            isLoadingConsentInfo: false
        });
        const errorMessage = error instanceof Error ? error.message : 'Unknown error fetching consent banner information';
        callbacks.onError?.({
            error: errorMessage
        });
        set({
            showPopup: false
        });
        return;
    }
}
const DEFAULT_GTM_CONSENT_CONFIG = {
    functionality_storage: 'denied',
    security_storage: 'denied',
    analytics_storage: 'denied',
    ad_storage: 'denied',
    ad_user_data: 'denied',
    ad_personalization: 'denied',
    personalization_storage: 'denied'
};
const CONSENT_STATE_TO_GTM_MAPPING = {
    necessary: [
        'security_storage'
    ],
    functionality: [
        'functionality_storage'
    ],
    measurement: [
        'analytics_storage'
    ],
    marketing: [
        'ad_storage',
        'ad_user_data',
        'ad_personalization'
    ],
    experience: [
        'personalization_storage'
    ]
};
function mapConsentStateToGTM(consentState) {
    const gtmConfig = {
        ...DEFAULT_GTM_CONSENT_CONFIG
    };
    for (const consentType of Object.keys(consentState)){
        const isGranted = consentState[consentType];
        const gtmConsentTypes = CONSENT_STATE_TO_GTM_MAPPING[consentType];
        for (const gtmType of gtmConsentTypes)gtmConfig[gtmType] = isGranted ? 'granted' : 'denied';
    }
    return gtmConfig;
}
function initializeGTMDataLayer(gtm) {
    const gtmConsent = gtm.consentState ? mapConsentStateToGTM(gtm.consentState) : DEFAULT_GTM_CONSENT_CONFIG;
    const gtmSetupScript = document.createElement("script");
    gtmSetupScript.textContent = `
    window.dataLayer = window.dataLayer || [];
    window.gtag = function gtag() {
      window.dataLayer.push(arguments);
    };
    window.gtag('consent', 'default', {
      ...${JSON.stringify(gtmConsent)},
    });
    window.dataLayer.push({
      'gtm.start': Date.now(),
      event: 'gtm.js',
    });
  `;
    if (!document.head) throw new Error("Document head is not available for script injection");
    document.head.appendChild(gtmSetupScript);
}
function createGTMScript(gtm) {
    const gtmScript = document.createElement("script");
    gtmScript.async = true;
    gtmScript.src = gtm.customScriptUrl ? gtm.customScriptUrl : `https://www.googletagmanager.com/gtm.js?id=${gtm.id}`;
    if (!document.head) throw new Error("Document head is not available for script injection");
    document.head.appendChild(gtmScript);
}
function setupGTM(gtm) {
    const id = gtm.id;
    if (!id || 0 === id.trim().length) throw new Error('GTM container ID is required and must be a non-empty string');
    if ('undefined' == typeof window || 'undefined' == typeof document) return;
    initializeGTMDataLayer(gtm);
    createGTMScript(gtm);
}
function updateGTMConsent(consentState) {
    if (!window.gtag) return;
    window.gtag('consent', 'update', mapConsentStateToGTM(consentState));
}
async function libs_identify_user_identifyUser({ user, manager, get, set }) {
    const { hasConsented, consentInfo } = get();
    const consented = hasConsented() && !!consentInfo?.id;
    const isIdentified = !!consentInfo?.identified;
    set({
        user: {
            id: user.id,
            identityProvider: user.identityProvider
        }
    });
    if (consented && !isIdentified) {
        await manager.identifyUser({
            body: {
                consentId: consentInfo.id,
                externalId: user.id,
                identityProvider: user.identityProvider
            }
        });
        set({
            consentInfo: {
                ...consentInfo,
                identified: true
            }
        });
    }
}
function createIframeManager(get, _set) {
    let observer = null;
    let isInitialized = false;
    return {
        initializeIframeBlocker: ()=>{
            if (isInitialized) return;
            if ('undefined' == typeof document) return;
            const state = get();
            if (state.iframeBlockerConfig?.disableAutomaticBlocking) return;
            const discoverAndRegisterCategories = ()=>{
                const iframeCategories = getIframeConsentCategories();
                if (iframeCategories.length > 0) get().updateConsentCategories(iframeCategories);
            };
            if ('loading' === document.readyState) document.addEventListener('DOMContentLoaded', discoverAndRegisterCategories);
            else discoverAndRegisterCategories();
            setTimeout(discoverAndRegisterCategories, 100);
            processAllIframes(state.consents);
            observer = setupIframeObserver(()=>get().consents, (categories)=>get().updateConsentCategories(categories));
            isInitialized = true;
        },
        updateIframeConsents: ()=>{
            if (!isInitialized) return;
            if ('undefined' == typeof document) return;
            const state = get();
            const { consents, iframeBlockerConfig } = state;
            if (iframeBlockerConfig?.disableAutomaticBlocking) return;
            processAllIframes(consents);
        },
        destroyIframeBlocker: ()=>{
            if (!isInitialized) return;
            if ('undefined' == typeof document) return;
            const state = get();
            const { iframeBlockerConfig } = state;
            if (iframeBlockerConfig?.disableAutomaticBlocking) return;
            if (observer) {
                observer.disconnect();
                observer = null;
            }
            isInitialized = false;
        }
    };
}
async function saveConsents({ manager, type, get, set, trackingBlocker }) {
    const { callbacks, selectedConsents, consents, consentTypes, updateScripts, updateIframeConsents, gdprTypes } = get();
    const newConsents = selectedConsents ?? consents ?? {};
    if ('all' === type) {
        for (const consent of consentTypes)if (gdprTypes.includes(consent.name)) newConsents[consent.name] = true;
    } else if ('necessary' === type) for (const consent of consentTypes)newConsents[consent.name] = 'necessary' === consent.name;
    set({
        consents: newConsents,
        selectedConsents: newConsents,
        showPopup: false,
        consentInfo: {
            time: Date.now(),
            type: type,
            identified: !!get().user?.id
        }
    });
    await new Promise((resolve)=>setTimeout(resolve, 0));
    trackingBlocker?.updateConsents(newConsents);
    updateIframeConsents();
    updateGTMConsent(newConsents);
    updateScripts();
    callbacks.onConsentSet?.({
        preferences: newConsents
    });
    const consent = await manager.setConsent({
        body: {
            type: 'cookie_banner',
            domain: window.location.hostname,
            preferences: newConsents,
            externalSubjectId: get().user?.id,
            identityProvider: get().user?.identityProvider,
            metadata: {
                source: 'consent_widget',
                acceptanceMethod: type
            }
        }
    });
    if (!consent.ok) {
        const errorMsg = consent.error?.message ?? 'Failed to save consents';
        callbacks.onError?.({
            error: errorMsg
        });
        if (!callbacks.onError) console.error(errorMsg);
    }
}
const getStoredConsent = (config)=>{
    if ('undefined' == typeof window) return null;
    try {
        return getConsentFromStorage(config);
    } catch (e) {
        console.error('Failed to retrieve stored consent:', e);
        return null;
    }
};
const createConsentManagerStore = (manager, options = {})=>{
    const { namespace = 'c15tStore', trackingBlockerConfig, isConsentDomain = false, translationConfig, storageConfig, enabled = true } = options;
    const storedConsent = getStoredConsent(storageConfig);
    const shouldDisableTrackingBlocker = options.scripts && options.scripts.length > 0;
    const trackingBlocker = 'undefined' == typeof window || shouldDisableTrackingBlocker ? null : createTrackingBlocker(trackingBlockerConfig || {}, storedConsent?.consents || initialState.consents);
    const getInitialConsentState = ()=>{
        if (!enabled) {
            const consents = gdpr_consentTypes.reduce((acc, consent)=>{
                acc[consent.name] = true;
                return acc;
            }, {});
            return {
                consents,
                selectedConsents: consents,
                consentInfo: {
                    time: Date.now(),
                    type: 'all',
                    identified: !!options.user?.id
                },
                showPopup: false,
                isLoadingConsentInfo: false,
                hasFetchedBanner: false,
                lastBannerFetchData: null
            };
        }
        if (storedConsent) return {
            consents: storedConsent.consents,
            selectedConsents: storedConsent.consents,
            consentInfo: storedConsent.consentInfo,
            showPopup: false,
            isLoadingConsentInfo: false
        };
        return {
            showPopup: false,
            isLoadingConsentInfo: true
        };
    };
    const store = createStore((set, get)=>({
            ...initialState,
            gdprTypes: options.initialGdprTypes ?? initialState.gdprTypes,
            ignoreGeoLocation: options.ignoreGeoLocation ?? false,
            config: options.config ?? initialState.config,
            iframeBlockerConfig: options.iframeBlockerConfig ?? initialState.iframeBlockerConfig,
            isConsentDomain,
            callbacks: options.callbacks ?? initialState.callbacks,
            scripts: options.scripts ?? initialState.scripts,
            legalLinks: options.legalLinks ?? initialState.legalLinks,
            translationConfig: translationConfig || initialState.translationConfig,
            storageConfig: storageConfig,
            user: options.user ?? initialState.user,
            ...getInitialConsentState(),
            setShowPopup: (show, force = false)=>{
                if (!show) return void set({
                    showPopup: false
                });
                const state = get();
                const storedConsent = getStoredConsent();
                if (force || !storedConsent && !state.consentInfo && !state.isLoadingConsentInfo) set({
                    showPopup: true
                });
            },
            setIsPrivacyDialogOpen: (isOpen)=>{
                set({
                    isPrivacyDialogOpen: isOpen
                });
                if (!isOpen) queueMicrotask(()=>{});
            },
            setSelectedConsent: (name, value)=>{
                set((state)=>{
                    const consentType = state.consentTypes.find((type)=>type.name === name);
                    if (consentType?.disabled) return state;
                    return {
                        selectedConsents: {
                            ...state.selectedConsents,
                            [name]: value
                        }
                    };
                });
            },
            saveConsents: async (type)=>await saveConsents({
                    manager,
                    type,
                    get,
                    set,
                    trackingBlocker
                }),
            setConsent: (name, value)=>{
                set((state)=>{
                    const consentType = state.consentTypes.find((type)=>type.name === name);
                    if (consentType?.disabled) return state;
                    const newConsents = {
                        ...state.consents,
                        [name]: value
                    };
                    return {
                        selectedConsents: newConsents
                    };
                });
                get().saveConsents('custom');
            },
            resetConsents: ()=>{
                set(()=>{
                    const consents = gdpr_consentTypes.reduce((acc, consent)=>{
                        acc[consent.name] = consent.defaultValue;
                        return acc;
                    }, {});
                    const resetState = {
                        consents,
                        selectedConsents: consents,
                        consentInfo: null
                    };
                    deleteConsentFromStorage(void 0, storageConfig);
                    return resetState;
                });
            },
            setGdprTypes: (types)=>set({
                    gdprTypes: types
                }),
            setComplianceSetting: (region, settings)=>set((state)=>({
                        complianceSettings: {
                            ...state.complianceSettings,
                            [region]: {
                                ...state.complianceSettings[region],
                                ...settings
                            }
                        }
                    })),
            resetComplianceSettings: ()=>set({
                    complianceSettings: initialState.complianceSettings
                }),
            setCallback: (name, callback)=>{
                const currentState = get();
                set((state)=>({
                        callbacks: {
                            ...state.callbacks,
                            [name]: callback
                        }
                    }));
                if ('onConsentSet' === name && callback && 'function' == typeof callback) callback?.({
                    preferences: currentState.consents
                });
                if ('onBannerFetched' === name && currentState.hasFetchedBanner && currentState.lastBannerFetchData && callback && 'function' == typeof callback) {
                    const { lastBannerFetchData } = currentState;
                    callback?.({
                        showConsentBanner: lastBannerFetchData.showConsentBanner,
                        jurisdiction: lastBannerFetchData.jurisdiction,
                        location: lastBannerFetchData.location,
                        translations: {
                            language: lastBannerFetchData.translations.language,
                            translations: lastBannerFetchData.translations.translations
                        }
                    });
                }
            },
            setDetectedCountry: (country)=>set({
                    detectedCountry: country
                }),
            setLocationInfo: (location)=>set({
                    locationInfo: location
                }),
            fetchConsentBannerInfo: ()=>{
                if (!enabled) return Promise.resolve(void 0);
                return fetchConsentBannerInfo({
                    manager,
                    initialData: options._initialData,
                    initialTranslationConfig: options.initialTranslationConfig,
                    get,
                    set,
                    trackingBlocker
                });
            },
            getDisplayedConsents: ()=>{
                const { gdprTypes, consentTypes } = get();
                return consentTypes.filter((consent)=>gdprTypes.includes(consent.name));
            },
            hasConsented: ()=>{
                const { consentInfo } = get();
                return consent_utils_hasConsented(consentInfo);
            },
            getEffectiveConsents: ()=>{
                const { consents, privacySettings } = get();
                return getEffectiveConsents(consents, privacySettings.honorDoNotTrack);
            },
            hasConsentFor: (consentType)=>{
                const { consents, privacySettings } = get();
                return hasConsentFor(consentType, consents, privacySettings.honorDoNotTrack);
            },
            has: (condition)=>{
                const { consents } = get();
                return has_has(condition, consents);
            },
            setTranslationConfig: (config)=>{
                set({
                    translationConfig: config
                });
            },
            updateConsentCategories: (newCategories)=>{
                const allCategories = [
                    ...new Set([
                        ...get().gdprTypes,
                        ...newCategories
                    ])
                ];
                set({
                    gdprTypes: allCategories
                });
            },
            identifyUser: (user)=>libs_identify_user_identifyUser({
                    user,
                    manager,
                    get,
                    set
                }),
            setOverrides: (overrides)=>set({
                    overrides: {
                        ...get().overrides,
                        ...overrides
                    }
                }),
            ...createScriptManager(get, set, trackingBlocker),
            ...createIframeManager(get, set)
        }));
    store.getState().initializeIframeBlocker();
    if (options.scripts && options.scripts.length > 0) store.getState().updateConsentCategories(options.scripts.flatMap((script)=>extractConsentNamesFromCondition(script.category)));
    if ('undefined' != typeof window) {
        window[namespace] = store;
        if (options.unstable_googleTagManager) try {
            setupGTM({
                ...options.unstable_googleTagManager,
                consentState: store.getState().consents
            });
        } catch (e) {
            console.error('Failed to setup Google Tag Manager:', e);
        }
        store.getState().callbacks.onConsentSet?.({
            preferences: store.getState().consents
        });
        if (options.user) store.getState().identifyUser(options.user);
        trackingBlocker?.updateConsents(store.getState().consents);
        store.getState().updateScripts();
        if (enabled) store.getState().fetchConsentBannerInfo();
    }
    return store;
};
export { API_ENDPOINTS, C15tClient, CustomClient, OfflineClient, allConsentNames, configureConsentManager, gdpr_consentTypes as consentTypes, createConsentManagerStore, createIframeBlocker, createTrackingBlocker, deepMergeTranslations, defaultTranslationConfig, deleteConsentFromStorage, deleteCookie, detectBrowserLanguage, getConsentFromStorage, getCookie, getLoadedScriptIds, getRootDomain, isScriptLoaded, loadScripts, mergeTranslationConfigs, prepareTranslationConfig, saveConsentToStorage, setCookie, unloadScripts, core_updateScripts as updateScripts };
