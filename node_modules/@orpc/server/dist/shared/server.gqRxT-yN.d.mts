import { HTTPPath, ORPCError } from '@orpc/client';
import { Meta } from '@orpc/contract';
import { Interceptor } from '@orpc/shared';
import { StandardResponse, StandardLazyRequest } from '@orpc/standard-server';
import { C as Context, R as Router, b as AnyRouter, A as AnyProcedure, d as ProcedureClientInterceptorOptions } from './server.CYNGeoCm.mjs';

interface StandardHandlerPlugin<T extends Context> {
    order?: number;
    init?(options: StandardHandlerOptions<T>, router: Router<any, T>): void;
}
declare class CompositeStandardHandlerPlugin<T extends Context, TPlugin extends StandardHandlerPlugin<T>> implements StandardHandlerPlugin<T> {
    protected readonly plugins: TPlugin[];
    constructor(plugins?: readonly TPlugin[]);
    init(options: StandardHandlerOptions<T>, router: Router<any, T>): void;
}

type StandardParams = Record<string, string>;
type StandardMatchResult = {
    path: readonly string[];
    procedure: AnyProcedure;
    params?: StandardParams;
} | undefined;
interface StandardMatcher {
    init(router: AnyRouter): void;
    match(method: string, pathname: HTTPPath): Promise<StandardMatchResult>;
}
interface StandardCodec {
    encode(output: unknown, procedure: AnyProcedure): StandardResponse;
    encodeError(error: ORPCError<any, any>): StandardResponse;
    decode(request: StandardLazyRequest, params: StandardParams | undefined, procedure: AnyProcedure): Promise<unknown>;
}

interface StandardHandleOptions<T extends Context> {
    prefix?: HTTPPath;
    context: T;
}
type StandardHandleResult = {
    matched: true;
    response: StandardResponse;
} | {
    matched: false;
    response: undefined;
};
interface StandardHandlerInterceptorOptions<T extends Context> extends StandardHandleOptions<T> {
    request: StandardLazyRequest;
}
interface StandardHandlerOptions<TContext extends Context> {
    plugins?: StandardHandlerPlugin<TContext>[];
    /**
     * Interceptors at the request level, helpful when you want catch errors
     */
    interceptors?: Interceptor<StandardHandlerInterceptorOptions<TContext>, Promise<StandardHandleResult>>[];
    /**
     * Interceptors at the root level, helpful when you want override the request/response
     */
    rootInterceptors?: Interceptor<StandardHandlerInterceptorOptions<TContext>, Promise<StandardHandleResult>>[];
    /**
     *
     * Interceptors for procedure client.
     */
    clientInterceptors?: Interceptor<ProcedureClientInterceptorOptions<TContext, Record<never, never>, Meta>, Promise<unknown>>[];
}
declare class StandardHandler<T extends Context> {
    private readonly matcher;
    private readonly codec;
    private readonly interceptors;
    private readonly clientInterceptors;
    private readonly rootInterceptors;
    constructor(router: Router<any, T>, matcher: StandardMatcher, codec: StandardCodec, options: NoInfer<StandardHandlerOptions<T>>);
    handle(request: StandardLazyRequest, options: StandardHandleOptions<T>): Promise<StandardHandleResult>;
}

export { CompositeStandardHandlerPlugin as C, StandardHandler as f };
export type { StandardCodec as S, StandardParams as a, StandardHandleOptions as b, StandardHandleResult as c, StandardHandlerInterceptorOptions as d, StandardHandlerOptions as e, StandardHandlerPlugin as g, StandardMatchResult as h, StandardMatcher as i };
