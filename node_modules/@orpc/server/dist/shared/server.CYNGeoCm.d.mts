import { ORPCErrorCode, ORPCErrorOptions, ORPCError, HTTPPath, ClientContext, Client } from '@orpc/client';
import { ErrorMap, ErrorMapItem, InferSchemaInput, AnySchema, Meta, ContractProcedureDef, InferSchemaOutput, ErrorFromErrorMap, AnyContractRouter, ContractProcedure } from '@orpc/contract';
import { MaybeOptionalOptions, Promisable, Interceptor, PromiseWithError, Value } from '@orpc/shared';

type Context = Record<PropertyKey, any>;
type MergedInitialContext<TInitial extends Context, TAdditional extends Context, TCurrent extends Context> = TInitial & Omit<TAdditional, keyof TCurrent>;
type MergedCurrentContext<T extends Context, U extends Context> = Omit<T, keyof U> & U;
declare function mergeCurrentContext<T extends Context, U extends Context>(context: T, other: U): MergedCurrentContext<T, U>;

type ORPCErrorConstructorMapItemOptions<TData> = Omit<ORPCErrorOptions<TData>, 'defined' | 'status'>;
type ORPCErrorConstructorMapItem<TCode extends ORPCErrorCode, TInData> = (...rest: MaybeOptionalOptions<ORPCErrorConstructorMapItemOptions<TInData>>) => ORPCError<TCode, TInData>;
type ORPCErrorConstructorMap<T extends ErrorMap> = {
    [K in keyof T]: K extends ORPCErrorCode ? T[K] extends ErrorMapItem<infer UInputSchema> ? ORPCErrorConstructorMapItem<K, InferSchemaInput<UInputSchema>> : never : never;
};
declare function createORPCErrorConstructorMap<T extends ErrorMap>(errors: T): ORPCErrorConstructorMap<T>;
declare function validateORPCError(map: ErrorMap, error: ORPCError<any, any>): Promise<ORPCError<string, unknown>>;

declare const LAZY_SYMBOL: unique symbol;
interface LazyMeta {
    prefix?: HTTPPath;
}
interface Lazy<T> {
    [LAZY_SYMBOL]: {
        loader: () => Promise<{
            default: T;
        }>;
        meta: LazyMeta;
    };
}
type Lazyable<T> = T | Lazy<T>;
/**
 * Creates a lazy-loaded item.
 *
 * @warning The `prefix` in `meta` only holds metadata and does not apply the prefix to the lazy router, use `os.prefix(...).lazy(...)` instead.
 */
declare function lazy<T>(loader: () => Promise<{
    default: T;
}>, meta?: LazyMeta): Lazy<T>;
declare function isLazy(item: unknown): item is Lazy<any>;
declare function getLazyMeta(lazied: Lazy<any>): LazyMeta;
declare function unlazy<T extends Lazyable<any>>(lazied: T): Promise<{
    default: T extends Lazy<infer U> ? U : T;
}>;

interface ProcedureHandlerOptions<TCurrentContext extends Context, TInput, TErrorConstructorMap extends ORPCErrorConstructorMap<any>, TMeta extends Meta> {
    context: TCurrentContext;
    input: TInput;
    path: readonly string[];
    procedure: Procedure<Context, Context, AnySchema, AnySchema, ErrorMap, TMeta>;
    signal?: AbortSignal;
    lastEventId: string | undefined;
    errors: TErrorConstructorMap;
}
interface ProcedureHandler<TCurrentContext extends Context, TInput, THandlerOutput, TErrorMap extends ErrorMap, TMeta extends Meta> {
    (opt: ProcedureHandlerOptions<TCurrentContext, TInput, ORPCErrorConstructorMap<TErrorMap>, TMeta>): Promisable<THandlerOutput>;
}
interface ProcedureDef<TInitialContext extends Context, TCurrentContext extends Context, TInputSchema extends AnySchema, TOutputSchema extends AnySchema, TErrorMap extends ErrorMap, TMeta extends Meta> extends ContractProcedureDef<TInputSchema, TOutputSchema, TErrorMap, TMeta> {
    __initialContext?: (type: TInitialContext) => unknown;
    middlewares: readonly AnyMiddleware[];
    inputValidationIndex: number;
    outputValidationIndex: number;
    handler: ProcedureHandler<TCurrentContext, any, any, any, any>;
}
/**
 * This class represents a procedure.
 *
 * @see {@link https://orpc.unnoq.com/docs/procedure Procedure Docs}
 */
declare class Procedure<TInitialContext extends Context, TCurrentContext extends Context, TInputSchema extends AnySchema, TOutputSchema extends AnySchema, TErrorMap extends ErrorMap, TMeta extends Meta> {
    /**
     * This property holds the defined options.
     */
    '~orpc': ProcedureDef<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    constructor(def: ProcedureDef<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>);
}
type AnyProcedure = Procedure<any, any, any, any, any, any>;
declare function isProcedure(item: unknown): item is AnyProcedure;

type MiddlewareResult<TOutContext extends Context, TOutput> = Promisable<{
    output: TOutput;
    context: TOutContext;
}>;
type MiddlewareNextFnOptions<TOutContext extends Context> = Record<never, never> extends TOutContext ? {
    context?: TOutContext;
} : {
    context: TOutContext;
};
interface MiddlewareNextFn<TOutput> {
    <U extends Context = Record<never, never>>(...rest: MaybeOptionalOptions<MiddlewareNextFnOptions<U>>): MiddlewareResult<U, TOutput>;
}
interface MiddlewareOutputFn<TOutput> {
    (output: TOutput): MiddlewareResult<Record<never, never>, TOutput>;
}
interface MiddlewareOptions<TInContext extends Context, TOutput, TErrorConstructorMap extends ORPCErrorConstructorMap<any>, TMeta extends Meta> {
    context: TInContext;
    path: readonly string[];
    procedure: Procedure<Context, Context, AnySchema, AnySchema, ErrorMap, TMeta>;
    signal?: AbortSignal;
    lastEventId: string | undefined;
    next: MiddlewareNextFn<TOutput>;
    errors: TErrorConstructorMap;
}
/**
 * A function that represents a middleware.
 *
 * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
 */
interface Middleware<TInContext extends Context, TOutContext extends Context, TInput, TOutput, TErrorConstructorMap extends ORPCErrorConstructorMap<any>, TMeta extends Meta> {
    (options: MiddlewareOptions<TInContext, TOutput, TErrorConstructorMap, TMeta>, input: TInput, output: MiddlewareOutputFn<TOutput>): Promisable<MiddlewareResult<TOutContext, TOutput>>;
}
type AnyMiddleware = Middleware<any, any, any, any, any, any>;
interface MapInputMiddleware<TInput, TMappedInput> {
    (input: TInput): TMappedInput;
}
declare function middlewareOutputFn<TOutput>(output: TOutput): MiddlewareResult<Record<never, never>, TOutput>;

type ProcedureClient<TClientContext extends ClientContext, TInputSchema extends AnySchema, TOutputSchema extends AnySchema, TErrorMap extends ErrorMap> = Client<TClientContext, InferSchemaInput<TInputSchema>, InferSchemaOutput<TOutputSchema>, ErrorFromErrorMap<TErrorMap>>;
interface ProcedureClientInterceptorOptions<TInitialContext extends Context, TErrorMap extends ErrorMap, TMeta extends Meta> {
    context: TInitialContext;
    input: unknown;
    errors: ORPCErrorConstructorMap<TErrorMap>;
    path: readonly string[];
    procedure: Procedure<Context, Context, AnySchema, AnySchema, ErrorMap, TMeta>;
    signal?: AbortSignal;
    lastEventId: string | undefined;
}
type CreateProcedureClientOptions<TInitialContext extends Context, TOutputSchema extends AnySchema, TErrorMap extends ErrorMap, TMeta extends Meta, TClientContext extends ClientContext> = {
    /**
     * This is helpful for logging and analytics.
     */
    path?: readonly string[];
    interceptors?: Interceptor<ProcedureClientInterceptorOptions<TInitialContext, TErrorMap, TMeta>, PromiseWithError<InferSchemaOutput<TOutputSchema>, ErrorFromErrorMap<TErrorMap>>>[];
} & (Record<never, never> extends TInitialContext ? {
    context?: Value<Promisable<TInitialContext>, [clientContext: TClientContext]>;
} : {
    context: Value<Promisable<TInitialContext>, [clientContext: TClientContext]>;
});
/**
 * Create Server-side client from a procedure.
 *
 * @see {@link https://orpc.unnoq.com/docs/client/server-side Server-side Client Docs}
 */
declare function createProcedureClient<TInitialContext extends Context, TInputSchema extends AnySchema, TOutputSchema extends AnySchema, TErrorMap extends ErrorMap, TMeta extends Meta, TClientContext extends ClientContext>(lazyableProcedure: Lazyable<Procedure<TInitialContext, any, TInputSchema, TOutputSchema, TErrorMap, TMeta>>, ...rest: MaybeOptionalOptions<CreateProcedureClientOptions<TInitialContext, TOutputSchema, TErrorMap, TMeta, TClientContext>>): ProcedureClient<TClientContext, TInputSchema, TOutputSchema, TErrorMap>;

/**
 * Represents a router, which defines a hierarchical structure of procedures.
 *
 * @info A procedure is a router too.
 * @see {@link https://orpc.unnoq.com/docs/contract-first/define-contract#contract-router Contract Router Docs}
 */
type Router<T extends AnyContractRouter, TInitialContext extends Context> = T extends ContractProcedure<infer UInputSchema, infer UOutputSchema, infer UErrorMap, infer UMeta> ? Procedure<TInitialContext, any, UInputSchema, UOutputSchema, UErrorMap, UMeta> : {
    [K in keyof T]: T[K] extends AnyContractRouter ? Lazyable<Router<T[K], TInitialContext>> : never;
};
type AnyRouter = Router<any, any>;
type InferRouterInitialContext<T extends AnyRouter> = T extends Router<any, infer UInitialContext> ? UInitialContext : never;
/**
 * Infer all initial context of the router.
 *
 * @info A procedure is a router too.
 * @see {@link https://orpc.unnoq.com/docs/router#utilities Router Utilities Docs}
 */
type InferRouterInitialContexts<T extends AnyRouter> = T extends Procedure<infer UInitialContext, any, any, any, any, any> ? UInitialContext : {
    [K in keyof T]: T[K] extends Lazyable<infer U extends AnyRouter> ? InferRouterInitialContexts<U> : never;
};
/**
 * Infer all current context of the router.
 *
 * @info A procedure is a router too.
 * @see {@link https://orpc.unnoq.com/docs/router#utilities Router Utilities Docs}
 */
type InferRouterCurrentContexts<T extends AnyRouter> = T extends Procedure<any, infer UCurrentContext, any, any, any, any> ? UCurrentContext : {
    [K in keyof T]: T[K] extends Lazyable<infer U extends AnyRouter> ? InferRouterCurrentContexts<U> : never;
};
/**
 * Infer all router inputs
 *
 * @info A procedure is a router too.
 * @see {@link https://orpc.unnoq.com/docs/router#utilities Router Utilities Docs}
 */
type InferRouterInputs<T extends AnyRouter> = T extends Procedure<any, any, infer UInputSchema, any, any, any> ? InferSchemaInput<UInputSchema> : {
    [K in keyof T]: T[K] extends Lazyable<infer U extends AnyRouter> ? InferRouterInputs<U> : never;
};
/**
 * Infer all router outputs
 *
 * @info A procedure is a router too.
 * @see {@link https://orpc.unnoq.com/docs/router#utilities Router Utilities Docs}
 */
type InferRouterOutputs<T extends AnyRouter> = T extends Procedure<any, any, any, infer UOutputSchema, any, any> ? InferSchemaOutput<UOutputSchema> : {
    [K in keyof T]: T[K] extends Lazyable<infer U extends AnyRouter> ? InferRouterOutputs<U> : never;
};

export { middlewareOutputFn as B, isProcedure as F, createProcedureClient as G, Procedure as P, mergeCurrentContext as m, createORPCErrorConstructorMap as n, LAZY_SYMBOL as o, lazy as q, isLazy as r, getLazyMeta as s, unlazy as u, validateORPCError as v };
export type { AnyProcedure as A, Context as C, ProcedureHandlerOptions as D, ProcedureDef as E, InferRouterInitialContexts as H, InferRouterInitialContext as I, InferRouterCurrentContexts as J, InferRouterInputs as K, Lazyable as L, MergedInitialContext as M, InferRouterOutputs as N, ORPCErrorConstructorMap as O, Router as R, AnyMiddleware as a, AnyRouter as b, Lazy as c, ProcedureClientInterceptorOptions as d, Middleware as e, MergedCurrentContext as f, MapInputMiddleware as g, CreateProcedureClientOptions as h, ProcedureClient as i, ProcedureHandler as j, ORPCErrorConstructorMapItemOptions as k, ORPCErrorConstructorMapItem as l, LazyMeta as p, MiddlewareResult as t, MiddlewareNextFnOptions as w, MiddlewareNextFn as x, MiddlewareOutputFn as y, MiddlewareOptions as z };
