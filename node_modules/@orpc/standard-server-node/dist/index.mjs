import { Readable } from 'node:stream';
import { runWithSpan, parseEmptyableJSON, isAsyncIteratorObject, stringifyJSON, AbortError, once } from '@orpc/shared';
import { getFilenameFromContentDisposition, flattenHeader, generateContentDisposition } from '@orpc/standard-server';
import { toEventIterator as toEventIterator$1, toEventStream as toEventStream$1 } from '@orpc/standard-server-fetch';

function toEventIterator(stream, options = {}) {
  return toEventIterator$1(Readable.toWeb(stream), options);
}
function toEventStream(iterator, options = {}) {
  return Readable.fromWeb(toEventStream$1(iterator, options));
}

function toStandardBody(req, options = {}) {
  return runWithSpan({ name: "parse_standard_body", signal: options.signal }, async () => {
    const contentDisposition = req.headers["content-disposition"];
    const contentType = req.headers["content-type"];
    if (typeof contentDisposition === "string") {
      const fileName = getFilenameFromContentDisposition(contentDisposition) ?? "blob";
      return _streamToFile(req, fileName, contentType ?? "");
    }
    if (!contentType || contentType.startsWith("application/json")) {
      const text = await _streamToString(req);
      return parseEmptyableJSON(text);
    }
    if (contentType.startsWith("multipart/form-data")) {
      return _streamToFormData(req, contentType);
    }
    if (contentType.startsWith("application/x-www-form-urlencoded")) {
      const text = await _streamToString(req);
      return new URLSearchParams(text);
    }
    if (contentType.startsWith("text/event-stream")) {
      return toEventIterator(req, options);
    }
    if (contentType.startsWith("text/plain")) {
      return _streamToString(req);
    }
    return _streamToFile(req, "blob", contentType);
  });
}
function toNodeHttpBody(body, headers, options = {}) {
  const currentContentDisposition = flattenHeader(headers["content-disposition"]);
  delete headers["content-type"];
  delete headers["content-disposition"];
  if (body === void 0) {
    return;
  }
  if (body instanceof Blob) {
    headers["content-type"] = body.type;
    headers["content-length"] = body.size.toString();
    headers["content-disposition"] = currentContentDisposition ?? generateContentDisposition(body instanceof File ? body.name : "blob");
    return Readable.fromWeb(body.stream());
  }
  if (body instanceof FormData) {
    const response = new Response(body);
    headers["content-type"] = response.headers.get("content-type");
    return Readable.fromWeb(response.body);
  }
  if (body instanceof URLSearchParams) {
    headers["content-type"] = "application/x-www-form-urlencoded";
    return body.toString();
  }
  if (isAsyncIteratorObject(body)) {
    headers["content-type"] = "text/event-stream";
    return toEventStream(body, options);
  }
  headers["content-type"] = "application/json";
  return stringifyJSON(body);
}
function _streamToFormData(stream, contentType) {
  const response = new Response(stream, {
    headers: {
      "content-type": contentType
    }
  });
  return response.formData();
}
async function _streamToString(stream) {
  let string = "";
  for await (const chunk of stream) {
    string += chunk.toString();
  }
  return string;
}
async function _streamToFile(stream, fileName, contentType) {
  const chunks = [];
  for await (const chunk of stream) {
    chunks.push(chunk);
  }
  return new File(chunks, fileName, { type: contentType });
}

function toStandardMethod(method) {
  return method ?? "GET";
}

function toAbortSignal(stream) {
  const controller = new AbortController();
  stream.once("error", (error) => controller.abort(error));
  stream.once("close", () => {
    if (!stream.writableFinished) {
      controller.abort(new AbortError("Writable stream closed before it finished writing"));
    }
  });
  return controller.signal;
}

function toStandardUrl(req) {
  const protocol = "encrypted" in req.socket && req.socket.encrypted ? "https:" : "http:";
  const host = req.headers.host ?? "localhost";
  const url = new URL(req.originalUrl ?? req.url ?? "/", `${protocol}//${host}`);
  return url;
}

function toStandardLazyRequest(req, res) {
  const signal = toAbortSignal(res);
  return {
    method: toStandardMethod(req.method),
    url: toStandardUrl(req),
    headers: req.headers,
    body: once(() => toStandardBody(req, { signal })),
    signal
  };
}

function sendStandardResponse(res, standardResponse, options = {}) {
  return new Promise((resolve, reject) => {
    res.once("error", reject);
    res.once("close", resolve);
    const resHeaders = { ...standardResponse.headers };
    const resBody = toNodeHttpBody(standardResponse.body, resHeaders, options);
    res.writeHead(standardResponse.status, resHeaders);
    if (resBody === void 0) {
      res.end();
    } else if (typeof resBody === "string") {
      res.end(resBody);
    } else {
      res.once("close", () => {
        if (!resBody.closed) {
          resBody.destroy(res.errored ?? void 0);
        }
      });
      resBody.once("error", (error) => res.destroy(error));
      resBody.pipe(res);
    }
  });
}

export { sendStandardResponse, toAbortSignal, toEventIterator, toEventStream, toNodeHttpBody, toStandardBody, toStandardLazyRequest, toStandardMethod, toStandardUrl };
