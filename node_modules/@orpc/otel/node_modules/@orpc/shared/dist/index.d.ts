import { Promisable } from 'type-fest';
export { IsEqual, IsNever, JsonValue, PartialDeep, Promisable } from 'type-fest';
import { Tracer, TraceAPI, ContextAPI, PropagationAPI, SpanOptions, Context, Span, AttributeValue, Exception } from '@opentelemetry/api';
export { group, guard, mapEntries, mapValues, omit, retry, sleep } from 'radash';

type MaybeOptionalOptions<TOptions> = Record<never, never> extends TOptions ? [options?: TOptions] : [options: TOptions];
declare function resolveMaybeOptionalOptions<T>(rest: MaybeOptionalOptions<T>): T;

declare function toArray<T>(value: T): T extends readonly any[] ? T : Exclude<T, undefined | null>[];
declare function splitInHalf<T>(arr: readonly T[]): [T[], T[]];

/**
 * Converts Request/Response/Blob/File/.. to a buffer (ArrayBuffer or Uint8Array).
 *
 * Prefers the newer `.bytes` method when available as it more efficient but not widely supported yet.
 */
declare function readAsBuffer(source: Pick<Blob, 'arrayBuffer' | 'bytes'>): Promise<ArrayBuffer | Uint8Array>;

type AnyFunction = (...args: any[]) => any;
declare function once<T extends () => any>(fn: T): () => ReturnType<T>;
declare function sequential<A extends any[], R>(fn: (...args: A) => Promise<R>): (...args: A) => Promise<R>;
/**
 * Executes the callback function after the current call stack has been cleared.
 */
declare function defer(callback: () => void): void;

type OmitChainMethodDeep<T extends object, K extends keyof any> = {
    [P in keyof Omit<T, K>]: T[P] extends AnyFunction ? ((...args: Parameters<T[P]>) => OmitChainMethodDeep<ReturnType<T[P]>, K>) : T[P];
};

declare const ORPC_NAME = "orpc";
declare const ORPC_SHARED_PACKAGE_NAME = "@orpc/shared";
declare const ORPC_SHARED_PACKAGE_VERSION = "1.13.0";

/**
 * Error thrown when an operation is aborted.
 * Uses the standardized 'AbortError' name for consistency with JavaScript APIs.
 */
declare class AbortError extends Error {
    constructor(...rest: ConstructorParameters<typeof Error>);
}

interface EventPublisherOptions {
    /**
     * Maximum number of events to buffer for async iterator subscribers.
     *
     * If the buffer exceeds this limit, the oldest event is dropped.
     * This prevents unbounded memory growth if consumers process events slowly.
     *
     * Set to:
     * - `0`: Disable buffering. Events must be consumed before the next one arrives.
     * - `1`: Only keep the latest event. Useful for real-time updates where only the most recent value matters.
     * - `Infinity`: Keep all events. Ensures no data loss, but may lead to high memory usage.
     *
     * @default 100
     */
    maxBufferedEvents?: number;
}
interface EventPublisherSubscribeIteratorOptions extends EventPublisherOptions {
    /**
     * Aborts the async iterator. Throws if aborted before or during pulling.
     */
    signal?: AbortSignal | undefined;
}
declare class EventPublisher<T extends Record<PropertyKey, any>> {
    #private;
    constructor(options?: EventPublisherOptions);
    get size(): number;
    /**
     * Emits an event and delivers the payload to all subscribed listeners.
     */
    publish<K extends keyof T>(event: K, payload: T[K]): void;
    /**
     * Subscribes to a specific event using a callback function.
     * Returns an unsubscribe function to remove the listener.
     *
     * @example
     * ```ts
     * const unsubscribe = publisher.subscribe('event', (payload) => {
     *   console.log(payload)
     * })
     *
     * // Later
     * unsubscribe()
     * ```
     */
    subscribe<K extends keyof T>(event: K, listener: (payload: T[K]) => void): () => void;
    /**
     * Subscribes to a specific event using an async iterator.
     * Useful for `for await...of` loops with optional buffering and abort support.
     *
     * @example
     * ```ts
     * for await (const payload of publisher.subscribe('event', { signal })) {
     *   console.log(payload)
     * }
     * ```
     */
    subscribe<K extends keyof T>(event: K, options?: EventPublisherSubscribeIteratorOptions): AsyncGenerator<T[K]> & AsyncIteratorObject<T[K]>;
}

declare class SequentialIdGenerator {
    private index;
    generate(): string;
}
/**
 * Compares two sequential IDs.
 * Returns:
 *  - negative if `a` < `b`
 *  - positive if `a` > `b`
 *  - 0 if equal
 */
declare function compareSequentialIds(a: string, b: string): number;

type SetOptional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
type IntersectPick<T, U> = Pick<T, keyof T & keyof U>;
type PromiseWithError<T, TError> = Promise<T> & {
    __error?: {
        type: TError;
    };
};
/**
 * The place where you can config the orpc types.
 *
 * - `throwableError` the error type that represent throwable errors should be `Error` or `null | undefined | {}` if you want more strict.
 */
interface Registry {
}
type ThrowableError = Registry extends {
    throwableError: infer T;
} ? T : Error;
type InferAsyncIterableYield<T> = T extends AsyncIterable<infer U> ? U : never;

type InterceptableOptions = Record<string, any>;
type InterceptorOptions<TOptions extends InterceptableOptions, TResult> = Omit<TOptions, 'next'> & {
    next(options?: TOptions): TResult;
};
type Interceptor<TOptions extends InterceptableOptions, TResult> = (options: InterceptorOptions<TOptions, TResult>) => TResult;
/**
 * Can used for interceptors or middlewares
 */
declare function onStart<T, TOptions extends {
    next(): any;
}, TRest extends any[]>(callback: NoInfer<(options: TOptions, ...rest: TRest) => Promisable<void>>): (options: TOptions, ...rest: TRest) => T | Promise<Awaited<ReturnType<TOptions['next']>>>;
/**
 * Can used for interceptors or middlewares
 */
declare function onSuccess<T, TOptions extends {
    next(): any;
}, TRest extends any[]>(callback: NoInfer<(result: Awaited<ReturnType<TOptions['next']>>, options: TOptions, ...rest: TRest) => Promisable<void>>): (options: TOptions, ...rest: TRest) => T | Promise<Awaited<ReturnType<TOptions['next']>>>;
/**
 * Can used for interceptors or middlewares
 */
declare function onError<T, TOptions extends {
    next(): any;
}, TRest extends any[]>(callback: NoInfer<(error: ReturnType<TOptions['next']> extends PromiseWithError<any, infer E> ? E : ThrowableError, options: TOptions, ...rest: TRest) => Promisable<void>>): (options: TOptions, ...rest: TRest) => T | Promise<Awaited<ReturnType<TOptions['next']>>>;
type OnFinishState<TResult, TError> = [error: TError, data: undefined, isSuccess: false] | [error: null, data: TResult, isSuccess: true];
/**
 * Can used for interceptors or middlewares
 */
declare function onFinish<T, TOptions extends {
    next(): any;
}, TRest extends any[]>(callback: NoInfer<(state: OnFinishState<Awaited<ReturnType<TOptions['next']>>, ReturnType<TOptions['next']> extends PromiseWithError<any, infer E> ? E : ThrowableError>, options: TOptions, ...rest: TRest) => Promisable<void>>): (options: TOptions, ...rest: TRest) => T | Promise<Awaited<ReturnType<TOptions['next']>>>;
declare function intercept<TOptions extends InterceptableOptions, TResult>(interceptors: Interceptor<TOptions, TResult>[], options: NoInfer<TOptions>, main: NoInfer<(options: TOptions) => TResult>): TResult;

/**
 * Only import types from @opentelemetry/api to avoid runtime dependencies.
 */

interface OtelConfig {
    tracer: Tracer;
    trace: TraceAPI;
    context: ContextAPI;
    propagation: PropagationAPI;
}
/**
 * Sets the global OpenTelemetry config.
 * Call this once at app startup. Use `undefined` to disable tracing.
 */
declare function setGlobalOtelConfig(config: OtelConfig | undefined): void;
/**
 * Gets the global OpenTelemetry config.
 * Returns `undefined` if OpenTelemetry is not configured, initialized, or enabled.
 */
declare function getGlobalOtelConfig(): OtelConfig | undefined;
/**
 * Starts a new OpenTelemetry span with the given name and options.
 *
 * @returns The new span, or `undefined` if no tracer is set.
 */
declare function startSpan(name: string, options?: SpanOptions, context?: Context): Span | undefined;
interface SetSpanErrorOptions {
    /**
     * Span error status is not set if error is due to cancellation by the signal.
     */
    signal?: AbortSignal;
}
/**
 * Records and sets the error status on the given span.
 * If the span is `undefined`, it does nothing.
 */
declare function setSpanError(span: Span | undefined, error: unknown, options?: SetSpanErrorOptions): void;
declare function setSpanAttribute(span: Span | undefined, key: string, value: AttributeValue | undefined): void;
/**
 * Converts an error to an OpenTelemetry Exception.
 */
declare function toOtelException(error: unknown): Exclude<Exception, string>;
/**
 * Converts a value to a string suitable for OpenTelemetry span attributes.
 */
declare function toSpanAttributeValue(data: unknown): string;
interface RunWithSpanOptions extends SpanOptions, SetSpanErrorOptions {
    /**
     * The name of the span to create.
     */
    name: string;
    /**
     * Context to use for the span.
     */
    context?: Context;
}
/**
 * Runs a function within the context of a new OpenTelemetry span.
 * The span is ended automatically, and errors are recorded to the span.
 */
declare function runWithSpan<T>({ name, context, ...options }: RunWithSpanOptions, fn: (span?: Span) => Promisable<T>): Promise<T>;
/**
 * Runs a function within the context of an existing OpenTelemetry span.
 */
declare function runInSpanContext<T>(span: Span | undefined, fn: () => Promisable<T>): Promise<T>;

declare function isAsyncIteratorObject(maybe: unknown): maybe is AsyncIteratorObject<any, any, any>;
interface AsyncIteratorClassNextFn<T, TReturn> {
    (): Promise<IteratorResult<T, TReturn>>;
}
interface AsyncIteratorClassCleanupFn {
    (reason: 'return' | 'throw' | 'next' | 'dispose'): Promise<void>;
}
declare const fallbackAsyncDisposeSymbol: unique symbol;
declare const asyncDisposeSymbol: typeof Symbol extends {
    asyncDispose: infer T;
} ? T : typeof fallbackAsyncDisposeSymbol;
declare class AsyncIteratorClass<T, TReturn = unknown, TNext = unknown> implements AsyncIteratorObject<T, TReturn, TNext>, AsyncGenerator<T, TReturn, TNext> {
    #private;
    constructor(next: AsyncIteratorClassNextFn<T, TReturn>, cleanup: AsyncIteratorClassCleanupFn);
    next(): Promise<IteratorResult<T, TReturn>>;
    return(value?: any): Promise<IteratorResult<T, TReturn>>;
    throw(err: any): Promise<IteratorResult<T, TReturn>>;
    /**
     * asyncDispose symbol only available in esnext, we should fallback to Symbol.for('asyncDispose')
     */
    [asyncDisposeSymbol](): Promise<void>;
    [Symbol.asyncIterator](): this;
}
declare function replicateAsyncIterator<T, TReturn, TNext>(source: AsyncIterator<T, TReturn, TNext>, count: number): (AsyncIteratorClass<T, TReturn, TNext>)[];
interface AsyncIteratorWithSpanOptions extends SetSpanErrorOptions {
    /**
     * The name of the span to create.
     */
    name: string;
}
declare function asyncIteratorWithSpan<T, TReturn, TNext>({ name, ...options }: AsyncIteratorWithSpanOptions, iterator: AsyncIterator<T, TReturn, TNext>): AsyncIteratorClass<T, TReturn, TNext>;

declare function parseEmptyableJSON(text: string | null | undefined): unknown;
declare function stringifyJSON<T>(value: T | {
    toJSON(): T;
}): undefined extends T ? undefined | string : string;

type Segment = string | number;
declare function findDeepMatches(check: (value: unknown) => boolean, payload: unknown, segments?: Segment[], maps?: Segment[][], values?: unknown[]): {
    maps: Segment[][];
    values: unknown[];
};
/**
 * Get constructor of the value
 *
 */
declare function getConstructor(value: unknown): Function | null | undefined;
/**
 * Check if the value is an object even it created by `Object.create(null)` or more tricky way.
 */
declare function isObject(value: unknown): value is Record<PropertyKey, unknown>;
/**
 * Check if the value satisfy a `object` type in typescript
 */
declare function isTypescriptObject(value: unknown): value is object & Record<PropertyKey, unknown>;
declare function clone<T>(value: T): T;
declare function get(object: unknown, path: readonly PropertyKey[]): unknown;
declare function isPropertyKey(value: unknown): value is PropertyKey;
declare const NullProtoObj: ({
    new <T extends Record<PropertyKey, unknown>>(): T;
});

type Value<T, TArgs extends any[] = []> = T | ((...args: TArgs) => T);
declare function value<T, TArgs extends any[]>(value: Value<T, TArgs>, ...args: NoInfer<TArgs>): T extends Value<infer U, any> ? U : never;
/**
 * Returns the value if it is defined, otherwise returns the fallback
 */
declare function fallback<T>(value: T | undefined, fallback: T): T;

/**
 * Prevents objects from being awaitable by intercepting the `then` method
 * when called by the native await mechanism. This is useful for preventing
 * accidental awaiting of objects that aren't meant to be promises.
 */
declare function preventNativeAwait<T extends object>(target: T): T;
/**
 * Create a proxy that overlays one object (`overlay`) on top of another (`target`).
 *
 * - Properties from `overlay` take precedence.
 * - Properties not in `overlay` fall back to `target`.
 * - Methods from either object are bound to `overlay` so `this` is consistent.
 *
 * Useful when you want to override or extend behavior without fully copying/merging objects.
 */
declare function overlayProxy<T extends object, U extends object>(target: Value<T>, partial: U): U & Omit<T, keyof U>;

interface AsyncIdQueueCloseOptions {
    id?: string;
    reason?: unknown;
}
declare class AsyncIdQueue<T> {
    private readonly openIds;
    private readonly queues;
    private readonly waiters;
    get length(): number;
    get waiterIds(): string[];
    hasBufferedItems(id: string): boolean;
    open(id: string): void;
    isOpen(id: string): boolean;
    push(id: string, item: T): void;
    pull(id: string): Promise<T>;
    close({ id, reason }?: AsyncIdQueueCloseOptions): void;
    assertOpen(id: string): void;
}

/**
 * Converts a `ReadableStream` into an `AsyncIteratorClass`.
 */
declare function streamToAsyncIteratorClass<T>(stream: ReadableStream<T>): AsyncIteratorClass<T>;
/**
 * Converts an `AsyncIterator` into a `ReadableStream`.
 */
declare function asyncIteratorToStream<T>(iterator: AsyncIterator<T>): ReadableStream<T>;
/**
 * Converts an `AsyncIterator` into a `ReadableStream`, ensuring that
 * all emitted object values are *unproxied* before enqueuing.
 */
declare function asyncIteratorToUnproxiedDataStream<T>(iterator: AsyncIterator<T>): ReadableStream<T>;

declare function tryDecodeURIComponent(value: string): string;

export { AbortError, AsyncIdQueue, AsyncIteratorClass, EventPublisher, NullProtoObj, ORPC_NAME, ORPC_SHARED_PACKAGE_NAME, ORPC_SHARED_PACKAGE_VERSION, SequentialIdGenerator, asyncIteratorToStream, asyncIteratorToUnproxiedDataStream, asyncIteratorWithSpan, clone, compareSequentialIds, defer, fallback, findDeepMatches, get, getConstructor, getGlobalOtelConfig, intercept, isAsyncIteratorObject, isObject, isPropertyKey, isTypescriptObject, onError, onFinish, onStart, onSuccess, once, overlayProxy, parseEmptyableJSON, preventNativeAwait, readAsBuffer, replicateAsyncIterator, resolveMaybeOptionalOptions, runInSpanContext, runWithSpan, sequential, setGlobalOtelConfig, setSpanAttribute, setSpanError, splitInHalf, startSpan, streamToAsyncIteratorClass, stringifyJSON, toArray, toOtelException, toSpanAttributeValue, tryDecodeURIComponent, value };
export type { AnyFunction, AsyncIdQueueCloseOptions, AsyncIteratorClassCleanupFn, AsyncIteratorClassNextFn, AsyncIteratorWithSpanOptions, EventPublisherOptions, EventPublisherSubscribeIteratorOptions, InferAsyncIterableYield, InterceptableOptions, Interceptor, InterceptorOptions, IntersectPick, MaybeOptionalOptions, OmitChainMethodDeep, OnFinishState, OtelConfig, PromiseWithError, Registry, RunWithSpanOptions, Segment, SetOptional, SetSpanErrorOptions, ThrowableError, Value };
