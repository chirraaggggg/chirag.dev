import { stringifyJSON, once, value } from '@orpc/shared';
import { O as OpenAPIGenerator } from '../shared/openapi.1iT1iSZi.mjs';
import '@orpc/client';
import '@orpc/client/standard';
import '@orpc/contract';
import '@orpc/openapi-client/standard';
import '@orpc/server';
import '@orpc/interop/json-schema-typed/draft-2020-12';

class OpenAPIReferencePlugin {
  generator;
  specGenerateOptions;
  specPath;
  docsPath;
  docsTitle;
  docsHead;
  docsScriptUrl;
  docsConfig;
  renderDocsHtml;
  constructor(options = {}) {
    this.specGenerateOptions = options.specGenerateOptions;
    this.docsPath = options.docsPath ?? "/";
    this.docsTitle = options.docsTitle ?? "API Reference";
    this.docsConfig = options.docsConfig ?? void 0;
    this.docsScriptUrl = options.docsScriptUrl ?? "https://cdn.jsdelivr.net/npm/@scalar/api-reference";
    this.docsHead = options.docsHead ?? "";
    this.specPath = options.specPath ?? "/spec.json";
    this.generator = new OpenAPIGenerator(options);
    const esc = (s) => s.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    this.renderDocsHtml = options.renderDocsHtml ?? ((specUrl, title, head, scriptUrl, config, spec) => {
      const finalConfig = {
        content: stringifyJSON(spec),
        ...config
      };
      return `
        <!doctype html>
        <html>
          <head>
            <meta charset="utf-8" />
            <meta name="viewport" content="width=device-width, initial-scale=1" />
            <title>${esc(title)}</title>
            ${head}
          </head>
          <body>
            <div id="app" data-config="${esc(stringifyJSON(finalConfig))}"></div>

            <script src="${esc(scriptUrl)}"><\/script>

            <script>
              Scalar.createApiReference('#app', JSON.parse(document.getElementById('app').dataset.config))
            <\/script>
          </body>
        </html>
      `;
    });
  }
  init(options, router) {
    options.interceptors ??= [];
    options.interceptors.push(async (options2) => {
      const res = await options2.next();
      if (res.matched || options2.request.method !== "GET") {
        return res;
      }
      const prefix = options2.prefix ?? "";
      const requestPathname = options2.request.url.pathname.replace(/\/$/, "") || "/";
      const docsUrl = new URL(`${prefix}${this.docsPath}`.replace(/\/$/, ""), options2.request.url.origin);
      const specUrl = new URL(`${prefix}${this.specPath}`.replace(/\/$/, ""), options2.request.url.origin);
      const generateSpec = once(async () => {
        return await this.generator.generate(router, {
          servers: [{ url: new URL(prefix, options2.request.url.origin).toString() }],
          ...await value(this.specGenerateOptions, options2)
        });
      });
      if (requestPathname === specUrl.pathname) {
        const spec = await generateSpec();
        return {
          matched: true,
          response: {
            status: 200,
            headers: {},
            body: new File([stringifyJSON(spec)], "spec.json", { type: "application/json" })
          }
        };
      }
      if (requestPathname === docsUrl.pathname) {
        const html = this.renderDocsHtml(
          specUrl.toString(),
          await value(this.docsTitle, options2),
          await value(this.docsHead, options2),
          await value(this.docsScriptUrl, options2),
          await value(this.docsConfig, options2),
          await generateSpec()
        );
        return {
          matched: true,
          response: {
            status: 200,
            headers: {},
            body: new File([html], "api-reference.html", { type: "text/html" })
          }
        };
      }
      return res;
    });
  }
}

export { OpenAPIReferencePlugin };
