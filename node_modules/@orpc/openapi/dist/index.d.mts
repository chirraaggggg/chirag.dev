import { OpenAPI, AnyContractProcedure } from '@orpc/contract';
export { OpenAPI } from '@orpc/contract';
export { e as CompositeSchemaConverter, C as ConditionalSchemaConverter, b as OpenAPIGenerator, a as OpenAPIGeneratorGenerateOptions, O as OpenAPIGeneratorOptions, c as SchemaConvertOptions, d as SchemaConverter, S as SchemaConverterComponent } from './shared/openapi.CfjfVeBJ.mjs';
import { HTTPPath, HTTPMethod } from '@orpc/client';
import { JSONSchema } from '@orpc/interop/json-schema-typed/draft-2020-12';
export { JSONSchema, ContentEncoding as JSONSchemaContentEncoding, Format as JSONSchemaFormat, TypeName as JSONSchemaTypeName } from '@orpc/interop/json-schema-typed/draft-2020-12';
import { JsonifiedClient } from '@orpc/openapi-client';
import { AnyRouter, ClientContext, Lazyable, CreateProcedureClientOptions, InferRouterInitialContext, Schema, ErrorMap, Meta, RouterClient } from '@orpc/server';
import { MaybeOptionalOptions } from '@orpc/shared';
import '@orpc/openapi-client/standard';

type OverrideOperationValue = Partial<OpenAPI.OperationObject> | ((current: OpenAPI.OperationObject, procedure: AnyContractProcedure) => OpenAPI.OperationObject);
/**
 * Customize The Operation Object by proxy an error map item or a middleware.
 *
 * @see {@link https://orpc.unnoq.com/docs/openapi/openapi-specification#customizing-operation-objects Customizing Operation Objects Docs}
 */
declare function customOpenAPIOperation<T extends object>(o: T, extend: OverrideOperationValue): T;
declare function getCustomOpenAPIOperation(o: object): OverrideOperationValue | undefined;
declare function applyCustomOpenAPIOperation(operation: OpenAPI.OperationObject, contract: AnyContractProcedure): OpenAPI.OperationObject;

/**
 * @internal
 */
type ObjectSchema = JSONSchema & {
    type: 'object';
} & object;
/**
 * @internal
 */
type FileSchema = JSONSchema & {
    type: 'string';
    contentMediaType: string;
} & object;
/**
 * @internal
 */
declare const LOGIC_KEYWORDS: string[];

/**
 * @internal
 */
declare function toOpenAPIPath(path: HTTPPath): string;
/**
 * @internal
 */
declare function toOpenAPIMethod(method: HTTPMethod): Lowercase<HTTPMethod>;
/**
 * @internal
 */
declare function toOpenAPIContent(schema: JSONSchema): Record<string, OpenAPI.MediaTypeObject>;
/**
 * @internal
 */
declare function toOpenAPIEventIteratorContent([yieldsRequired, yieldsSchema]: [boolean, JSONSchema], [returnsRequired, returnsSchema]: [boolean, JSONSchema]): Record<string, OpenAPI.MediaTypeObject>;
/**
 * @internal
 */
declare function toOpenAPIParameters(schema: ObjectSchema, parameterIn: 'path' | 'query' | 'header' | 'cookie'): OpenAPI.ParameterObject[];
/**
 * @internal
 */
declare function checkParamsSchema(schema: ObjectSchema, params: string[]): boolean;
/**
 * @internal
 */
declare function toOpenAPISchema(schema: JSONSchema): OpenAPI.SchemaObject & object;
declare function resolveOpenAPIJsonSchemaRef(doc: OpenAPI.Document, schema: JSONSchema): JSONSchema;

declare function createJsonifiedRouterClient<T extends AnyRouter, TClientContext extends ClientContext>(router: Lazyable<T | undefined>, ...rest: MaybeOptionalOptions<CreateProcedureClientOptions<InferRouterInitialContext<T>, Schema<unknown, unknown>, ErrorMap, Meta, TClientContext>>): JsonifiedClient<RouterClient<T, TClientContext>>;

/**
 *@internal
 */
declare function isFileSchema(schema: JSONSchema): schema is FileSchema;
/**
 * @internal
 */
declare function isObjectSchema(schema: JSONSchema): schema is ObjectSchema;
/**
 * @internal
 */
declare function isAnySchema(schema: JSONSchema): boolean;
/**
 * @internal
 */
declare function separateObjectSchema(schema: ObjectSchema, separatedProperties: string[]): [matched: ObjectSchema, rest: ObjectSchema];
/**
 * @internal
 */
declare function filterSchemaBranches(schema: JSONSchema, check: (schema: JSONSchema) => boolean, matches?: JSONSchema[]): [matches: JSONSchema[], rest: JSONSchema | undefined];
declare function applySchemaOptionality(required: boolean, schema: JSONSchema): JSONSchema;
/**
 * Takes a JSON schema and, if it's primarily a union type (anyOf, oneOf),
 * recursively expands it into an array of its constituent, non-union base schemas.
 * If the schema is not a simple union or is a base type, it's returned as a single-element array.
 */
declare function expandUnionSchema(schema: JSONSchema): JSONSchema[];
declare function expandArrayableSchema(schema: JSONSchema): undefined | [items: JSONSchema, array: JSONSchema & {
    type: 'array';
    items?: JSONSchema;
}];
declare function isPrimitiveSchema(schema: JSONSchema): boolean;

declare const oo: {
    spec: typeof customOpenAPIOperation;
};

export { LOGIC_KEYWORDS, applyCustomOpenAPIOperation, applySchemaOptionality, checkParamsSchema, createJsonifiedRouterClient, customOpenAPIOperation, expandArrayableSchema, expandUnionSchema, filterSchemaBranches, getCustomOpenAPIOperation, isAnySchema, isFileSchema, isObjectSchema, isPrimitiveSchema, oo, resolveOpenAPIJsonSchemaRef, separateObjectSchema, toOpenAPIContent, toOpenAPIEventIteratorContent, toOpenAPIMethod, toOpenAPIParameters, toOpenAPIPath, toOpenAPISchema };
export type { FileSchema, ObjectSchema, OverrideOperationValue };
