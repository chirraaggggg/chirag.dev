import { custom, ZodFirstPartyTypeKind } from 'zod/v3';
import wcmatch from 'wildcard-match';
import { isObject, guard, toArray } from '@orpc/shared';
import { JsonSchemaXNativeType } from '@orpc/json-schema';
import { JSONSchemaFormat } from '@orpc/openapi';
import escapeStringRegexp from 'escape-string-regexp';

const CUSTOM_JSON_SCHEMA_SYMBOL = Symbol("ORPC_CUSTOM_JSON_SCHEMA");
const CUSTOM_JSON_SCHEMA_INPUT_SYMBOL = Symbol("ORPC_CUSTOM_JSON_SCHEMA_INPUT");
const CUSTOM_JSON_SCHEMA_OUTPUT_SYMBOL = Symbol("ORPC_CUSTOM_JSON_SCHEMA_OUTPUT");
function getCustomJsonSchema(def, options) {
  if (options.strategy === "input" && CUSTOM_JSON_SCHEMA_INPUT_SYMBOL in def) {
    return def[CUSTOM_JSON_SCHEMA_INPUT_SYMBOL];
  }
  if (options.strategy === "output" && CUSTOM_JSON_SCHEMA_OUTPUT_SYMBOL in def) {
    return def[CUSTOM_JSON_SCHEMA_OUTPUT_SYMBOL];
  }
  if (CUSTOM_JSON_SCHEMA_SYMBOL in def) {
    return def[CUSTOM_JSON_SCHEMA_SYMBOL];
  }
  return void 0;
}
function customJsonSchema(schema, custom, options = {}) {
  const SYMBOL = options.strategy === "input" ? CUSTOM_JSON_SCHEMA_INPUT_SYMBOL : options.strategy === "output" ? CUSTOM_JSON_SCHEMA_OUTPUT_SYMBOL : CUSTOM_JSON_SCHEMA_SYMBOL;
  const This = schema.constructor;
  const newSchema = new This({
    ...schema._def,
    [SYMBOL]: custom
  });
  return newSchema;
}

const CUSTOM_ZOD_DEF_SYMBOL = Symbol("ORPC_CUSTOM_ZOD_DEF");
function setCustomZodDef(def, custom) {
  Object.assign(def, { [CUSTOM_ZOD_DEF_SYMBOL]: custom });
}
function getCustomZodDef(def) {
  return def[CUSTOM_ZOD_DEF_SYMBOL];
}
function composeParams(defaultMessage, params) {
  return (val) => {
    const message = defaultMessage(val);
    if (!params) {
      return {
        message
      };
    }
    if (typeof params === "function") {
      return {
        message,
        ...params(val)
      };
    }
    if (typeof params === "object") {
      return {
        message,
        ...params
      };
    }
    return {
      message: params
    };
  };
}

function blob(params) {
  const schema = custom(
    (val) => val instanceof Blob,
    composeParams(
      () => "Input is not a blob",
      params
    )
  );
  setCustomZodDef(schema._def, { type: "blob" });
  return schema;
}

function file(params) {
  const schema = custom(
    (val) => val instanceof File,
    composeParams(
      () => "Input is not a file",
      params
    )
  );
  setCustomZodDef(schema._def, { type: "file" });
  return Object.assign(schema, {
    type: (mimeType, params2) => {
      const isMatch = wcmatch(mimeType);
      const refinedSchema = schema.refine(
        (val) => isMatch(val.type.split(";")[0]),
        composeParams(
          (val) => `Expected a file of type ${mimeType} but got a file of type ${val.type || "unknown"}`,
          params2
        )
      );
      setCustomZodDef(refinedSchema._def, { type: "file", mimeType });
      return refinedSchema;
    }
  });
}

function regexp(params) {
  const schema = custom(
    (val) => val instanceof RegExp,
    composeParams(
      () => "Input is not a regexp",
      params
    )
  );
  setCustomZodDef(schema._def, { type: "regexp" });
  return schema;
}

function url(params) {
  const schema = custom(
    (val) => val instanceof URL,
    composeParams(
      () => "Input is not a URL",
      params
    )
  );
  setCustomZodDef(schema._def, { type: "url" });
  return schema;
}

class ZodSmartCoercionPlugin {
  init(options) {
    options.clientInterceptors ??= [];
    options.clientInterceptors.unshift((options2) => {
      const inputSchema = options2.procedure["~orpc"].inputSchema;
      if (!inputSchema || inputSchema["~standard"].vendor !== "zod" || "_zod" in inputSchema) {
        return options2.next();
      }
      const coercedInput = zodCoerceInternal(inputSchema, options2.input);
      return options2.next({ ...options2, input: coercedInput });
    });
  }
}
function zodCoerceInternal(schema, value) {
  const customZodDef = getCustomZodDef(schema._def);
  switch (customZodDef?.type) {
    case "regexp": {
      if (typeof value === "string") {
        return safeToRegExp(value);
      }
      return value;
    }
    case "url": {
      if (typeof value === "string") {
        return safeToURL(value);
      }
      return value;
    }
  }
  const typeName = schema._def.typeName;
  switch (typeName) {
    case ZodFirstPartyTypeKind.ZodNumber: {
      if (typeof value === "string") {
        return safeToNumber(value);
      }
      return value;
    }
    case ZodFirstPartyTypeKind.ZodBigInt: {
      if (typeof value === "string") {
        return safeToBigInt(value);
      }
      return value;
    }
    case ZodFirstPartyTypeKind.ZodBoolean: {
      if (typeof value === "string") {
        return safeToBoolean(value);
      }
      return value;
    }
    case ZodFirstPartyTypeKind.ZodDate: {
      if (typeof value === "string") {
        return safeToDate(value);
      }
      return value;
    }
    case ZodFirstPartyTypeKind.ZodLiteral: {
      const schema_ = schema;
      const expectedValue = schema_._def.value;
      if (typeof value === "string" && typeof expectedValue !== "string") {
        if (typeof expectedValue === "bigint") {
          return safeToBigInt(value);
        } else if (typeof expectedValue === "number") {
          return safeToNumber(value);
        } else if (typeof expectedValue === "boolean") {
          return safeToBoolean(value);
        }
      }
      return value;
    }
    case ZodFirstPartyTypeKind.ZodNativeEnum: {
      const schema_ = schema;
      if (Object.values(schema_._def.values).includes(value)) {
        return value;
      }
      if (typeof value === "string") {
        for (const expectedValue of Object.values(schema_._def.values)) {
          if (expectedValue.toString() === value) {
            return expectedValue;
          }
        }
      }
      return value;
    }
    case ZodFirstPartyTypeKind.ZodObject: {
      const schema_ = schema;
      if (isObject(value)) {
        const newObj = {};
        const keys = /* @__PURE__ */ new Set([
          ...Object.keys(value),
          ...Object.keys(schema_.shape)
        ]);
        for (const k of keys) {
          newObj[k] = zodCoerceInternal(
            schema_.shape[k] ?? schema_._def.catchall,
            value[k]
          );
        }
        return newObj;
      }
      return value;
    }
    case ZodFirstPartyTypeKind.ZodRecord: {
      const schema_ = schema;
      if (isObject(value)) {
        const newObj = {};
        for (const [k, v] of Object.entries(value)) {
          const key = zodCoerceInternal(schema_._def.keyType, k);
          const val = zodCoerceInternal(schema_._def.valueType, v);
          newObj[key] = val;
        }
        return newObj;
      }
      return value;
    }
    case ZodFirstPartyTypeKind.ZodArray: {
      const schema_ = schema;
      if (Array.isArray(value)) {
        return value.map((v) => zodCoerceInternal(schema_._def.type, v));
      }
      return value;
    }
    case ZodFirstPartyTypeKind.ZodTuple: {
      const schema_ = schema;
      if (Array.isArray(value)) {
        return value.map((v, i) => {
          const s = schema_._def.items[i] ?? schema_._def.rest;
          return s ? zodCoerceInternal(s, v) : v;
        });
      }
      return value;
    }
    case ZodFirstPartyTypeKind.ZodSet: {
      const schema_ = schema;
      if (Array.isArray(value)) {
        return new Set(
          value.map((v) => zodCoerceInternal(schema_._def.valueType, v))
        );
      }
      return value;
    }
    case ZodFirstPartyTypeKind.ZodMap: {
      const schema_ = schema;
      if (Array.isArray(value) && value.every((i) => Array.isArray(i) && i.length === 2)) {
        return new Map(
          value.map(([k, v]) => [
            zodCoerceInternal(schema_._def.keyType, k),
            zodCoerceInternal(schema_._def.valueType, v)
          ])
        );
      }
      return value;
    }
    case ZodFirstPartyTypeKind.ZodUnion:
    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion: {
      const schema_ = schema;
      if (schema_.safeParse(value).success) {
        return value;
      }
      const results = [];
      for (const s of schema_._def.options) {
        const newValue = zodCoerceInternal(s, value);
        const result = schema_.safeParse(newValue);
        if (result.success) {
          return newValue;
        }
        results.push([newValue, result.error.issues.length]);
      }
      if (results.length === 0) {
        return value;
      }
      return results.sort((a, b) => a[1] - b[1])[0][0];
    }
    case ZodFirstPartyTypeKind.ZodIntersection: {
      const schema_ = schema;
      return zodCoerceInternal(
        schema_._def.right,
        zodCoerceInternal(schema_._def.left, value)
      );
    }
    case ZodFirstPartyTypeKind.ZodReadonly: {
      const schema_ = schema;
      return zodCoerceInternal(schema_._def.innerType, value);
    }
    case ZodFirstPartyTypeKind.ZodPipeline: {
      const schema_ = schema;
      return zodCoerceInternal(schema_._def.in, value);
    }
    case ZodFirstPartyTypeKind.ZodEffects: {
      const schema_ = schema;
      return zodCoerceInternal(schema_._def.schema, value);
    }
    case ZodFirstPartyTypeKind.ZodBranded: {
      const schema_ = schema;
      return zodCoerceInternal(schema_._def.type, value);
    }
    case ZodFirstPartyTypeKind.ZodCatch: {
      const schema_ = schema;
      return zodCoerceInternal(schema_._def.innerType, value);
    }
    case ZodFirstPartyTypeKind.ZodDefault: {
      const schema_ = schema;
      return zodCoerceInternal(schema_._def.innerType, value);
    }
    case ZodFirstPartyTypeKind.ZodNullable: {
      if (value === null) {
        return null;
      }
      const schema_ = schema;
      return zodCoerceInternal(schema_._def.innerType, value);
    }
    case ZodFirstPartyTypeKind.ZodOptional: {
      if (value === void 0) {
        return void 0;
      }
      const schema_ = schema;
      return zodCoerceInternal(schema_._def.innerType, value);
    }
    case ZodFirstPartyTypeKind.ZodLazy: {
      const schema_ = schema;
      if (value !== void 0) {
        return zodCoerceInternal(schema_._def.getter(), value);
      }
      return value;
    }
  }
  return value;
}
function safeToBigInt(value) {
  return guard(() => BigInt(value)) ?? value;
}
function safeToNumber(value) {
  const num = Number(value);
  return Number.isNaN(num) || num.toString() !== value ? value : num;
}
function safeToBoolean(value) {
  const lower = value.toLowerCase();
  if (lower === "false" || lower === "off" || lower === "f") {
    return false;
  }
  if (lower === "true" || lower === "on" || lower === "t") {
    return true;
  }
  return value;
}
function safeToRegExp(value) {
  if (value.startsWith("/")) {
    const match = value.match(/^\/(.*)\/([a-z]*)$/);
    if (match) {
      const [, pattern, flags] = match;
      return new RegExp(pattern, flags);
    }
  }
  return value;
}
function safeToURL(value) {
  return guard(() => new URL(value)) ?? value;
}
function safeToDate(value) {
  const date = new Date(value);
  if (!Number.isNaN(date.getTime()) && date.toISOString().startsWith(value)) {
    return date;
  }
  return value;
}

class ZodToJsonSchemaConverter {
  maxLazyDepth;
  maxStructureDepth;
  unsupportedJsonSchema;
  anyJsonSchema;
  constructor(options = {}) {
    this.maxLazyDepth = options.maxLazyDepth ?? 3;
    this.maxStructureDepth = options.maxStructureDepth ?? 10;
    this.unsupportedJsonSchema = options.unsupportedJsonSchema ?? { not: {} };
    this.anyJsonSchema = options.anyJsonSchema ?? {};
  }
  condition(schema) {
    return schema !== void 0 && schema["~standard"].vendor === "zod" && !("_zod" in schema);
  }
  convert(schema, options, lazyDepth = 0, isHandledCustomJSONSchema = false, isHandledZodDescription = false, structureDepth = 0) {
    const def = schema._def;
    if (structureDepth > this.maxStructureDepth) {
      return [false, this.anyJsonSchema];
    }
    if (!options.minStructureDepthForRef || options.minStructureDepthForRef <= structureDepth) {
      const components = toArray(options.components);
      for (const component of components) {
        if (component.schema === schema && component.allowedStrategies.includes(options.strategy)) {
          return [component.required, { $ref: component.ref }];
        }
      }
    }
    if (!isHandledZodDescription && "description" in def && typeof def.description === "string") {
      const [required, json] = this.convert(
        schema,
        options,
        lazyDepth,
        isHandledCustomJSONSchema,
        true,
        structureDepth
      );
      return [required, { ...json, description: def.description }];
    }
    if (!isHandledCustomJSONSchema) {
      const customJSONSchema = getCustomJsonSchema(def, options);
      if (customJSONSchema) {
        const [required, json] = this.convert(
          schema,
          options,
          lazyDepth,
          true,
          isHandledZodDescription,
          structureDepth
        );
        return [required, { ...json, ...customJSONSchema }];
      }
    }
    const customSchema = this.#handleCustomZodDef(def);
    if (customSchema) {
      return [true, customSchema];
    }
    const typeName = this.#getZodTypeName(def);
    switch (typeName) {
      case ZodFirstPartyTypeKind.ZodString: {
        const schema_ = schema;
        const json = { type: "string" };
        for (const check of schema_._def.checks) {
          switch (check.kind) {
            case "base64":
              json.contentEncoding = "base64";
              break;
            case "cuid":
              json.pattern = "^[0-9A-HJKMNP-TV-Z]{26}$";
              break;
            case "email":
              json.format = JSONSchemaFormat.Email;
              break;
            case "url":
              json.format = JSONSchemaFormat.URI;
              break;
            case "uuid":
              json.format = JSONSchemaFormat.UUID;
              break;
            case "regex":
              json.pattern = check.regex.source;
              break;
            case "min":
              json.minLength = check.value;
              break;
            case "max":
              json.maxLength = check.value;
              break;
            case "length":
              json.minLength = check.value;
              json.maxLength = check.value;
              break;
            case "includes":
              json.pattern = escapeStringRegexp(check.value);
              break;
            case "startsWith":
              json.pattern = `^${escapeStringRegexp(check.value)}`;
              break;
            case "endsWith":
              json.pattern = `${escapeStringRegexp(check.value)}$`;
              break;
            case "emoji":
              json.pattern = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
              break;
            case "nanoid":
              json.pattern = "^[a-zA-Z0-9_-]{21}$";
              break;
            case "cuid2":
              json.pattern = "^[0-9a-z]+$";
              break;
            case "ulid":
              json.pattern = "^[0-9A-HJKMNP-TV-Z]{26}$";
              break;
            case "datetime":
              json.format = JSONSchemaFormat.DateTime;
              break;
            case "date":
              json.format = JSONSchemaFormat.Date;
              break;
            case "time":
              json.format = JSONSchemaFormat.Time;
              break;
            case "duration":
              json.format = JSONSchemaFormat.Duration;
              break;
            case "ip": {
              if (check.version === "v4") {
                json.format = JSONSchemaFormat.IPv4;
              } else if (check.version === "v6") {
                json.format = JSONSchemaFormat.IPv6;
              } else {
                json.anyOf = [
                  { format: JSONSchemaFormat.IPv4 },
                  { format: JSONSchemaFormat.IPv6 }
                ];
              }
              break;
            }
            case "jwt":
              json.pattern = "^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$";
              break;
            case "base64url":
              json.pattern = "^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$";
              break;
            default: {
              check.kind;
            }
          }
        }
        return [true, json];
      }
      case ZodFirstPartyTypeKind.ZodNumber: {
        const schema_ = schema;
        const json = { type: "number" };
        for (const check of schema_._def.checks) {
          switch (check.kind) {
            case "int":
              json.type = "integer";
              break;
            case "min":
              json.minimum = check.value;
              break;
            case "max":
              json.maximum = check.value;
              break;
            case "multipleOf":
              json.multipleOf = check.value;
              break;
            default: {
              check.kind;
            }
          }
        }
        return [true, json];
      }
      case ZodFirstPartyTypeKind.ZodBigInt: {
        const json = {
          "type": "string",
          "pattern": "^-?[0-9]+$",
          "x-native-type": JsonSchemaXNativeType.BigInt
        };
        return [true, json];
      }
      case ZodFirstPartyTypeKind.ZodNaN: {
        return options.strategy === "input" ? [true, this.unsupportedJsonSchema] : [true, { type: "null" }];
      }
      case ZodFirstPartyTypeKind.ZodBoolean: {
        return [true, { type: "boolean" }];
      }
      case ZodFirstPartyTypeKind.ZodDate: {
        const schema2 = {
          "type": "string",
          "format": JSONSchemaFormat.DateTime,
          "x-native-type": JsonSchemaXNativeType.Date
        };
        return [true, schema2];
      }
      case ZodFirstPartyTypeKind.ZodNull: {
        return [true, { type: "null" }];
      }
      case ZodFirstPartyTypeKind.ZodLiteral: {
        const schema_ = schema;
        if (schema_._def.value === void 0) {
          return [false, this.unsupportedJsonSchema];
        }
        return [true, { const: schema_._def.value }];
      }
      case ZodFirstPartyTypeKind.ZodVoid:
      case ZodFirstPartyTypeKind.ZodUndefined: {
        return [false, this.unsupportedJsonSchema];
      }
      case ZodFirstPartyTypeKind.ZodUnknown:
      case ZodFirstPartyTypeKind.ZodAny: {
        return [false, this.anyJsonSchema];
      }
      case ZodFirstPartyTypeKind.ZodEnum: {
        const schema_ = schema;
        return [true, { enum: schema_._def.values }];
      }
      case ZodFirstPartyTypeKind.ZodNativeEnum: {
        const schema_ = schema;
        return [true, { enum: Object.values(schema_._def.values) }];
      }
      case ZodFirstPartyTypeKind.ZodArray: {
        const schema_ = schema;
        const def2 = schema_._def;
        const json = { type: "array" };
        const [itemRequired, itemJson] = this.convert(def2.type, options, lazyDepth, false, false, structureDepth + 1);
        json.items = this.#toArrayItemJsonSchema(itemRequired, itemJson, options.strategy);
        if (def2.exactLength) {
          json.maxItems = def2.exactLength.value;
          json.minItems = def2.exactLength.value;
        }
        if (def2.minLength) {
          json.minItems = def2.minLength.value;
        }
        if (def2.maxLength) {
          json.maxItems = def2.maxLength.value;
        }
        return [true, json];
      }
      case ZodFirstPartyTypeKind.ZodTuple: {
        const schema_ = schema;
        const prefixItems = [];
        const json = { type: "array" };
        for (const item of schema_._def.items) {
          const [itemRequired, itemJson] = this.convert(item, options, lazyDepth, false, false, structureDepth + 1);
          prefixItems.push(
            this.#toArrayItemJsonSchema(itemRequired, itemJson, options.strategy)
          );
        }
        if (prefixItems?.length) {
          json.prefixItems = prefixItems;
        }
        if (schema_._def.rest) {
          const [itemRequired, itemJson] = this.convert(schema_._def.rest, options, lazyDepth, false, false, structureDepth + 1);
          json.items = this.#toArrayItemJsonSchema(itemRequired, itemJson, options.strategy);
        }
        return [true, json];
      }
      case ZodFirstPartyTypeKind.ZodObject: {
        const schema_ = schema;
        const json = { type: "object" };
        const properties = {};
        const required = [];
        for (const [key, value] of Object.entries(schema_.shape)) {
          const [itemRequired, itemJson] = this.convert(value, options, lazyDepth, false, false, structureDepth + 1);
          properties[key] = itemJson;
          if (itemRequired) {
            required.push(key);
          }
        }
        if (Object.keys(properties).length) {
          json.properties = properties;
        }
        if (required.length) {
          json.required = required;
        }
        const catchAllTypeName = this.#getZodTypeName(schema_._def.catchall._def);
        if (catchAllTypeName === ZodFirstPartyTypeKind.ZodNever) {
          if (schema_._def.unknownKeys === "strict") {
            json.additionalProperties = false;
          }
        } else {
          const [_, addJson] = this.convert(schema_._def.catchall, options, lazyDepth, false, false, structureDepth + 1);
          json.additionalProperties = addJson;
        }
        return [true, json];
      }
      case ZodFirstPartyTypeKind.ZodRecord: {
        const schema_ = schema;
        const json = { type: "object" };
        const [__, keyJson] = this.convert(schema_._def.keyType, options, lazyDepth, false, false, structureDepth + 1);
        if (Object.entries(keyJson).some(([k, v]) => k !== "type" || v !== "string")) {
          json.propertyNames = keyJson;
        }
        const [_, itemJson] = this.convert(schema_._def.valueType, options, lazyDepth, false, false, structureDepth + 1);
        json.additionalProperties = itemJson;
        return [true, json];
      }
      case ZodFirstPartyTypeKind.ZodSet: {
        const schema_ = schema;
        const json = {
          "type": "array",
          "uniqueItems": true,
          "x-native-type": JsonSchemaXNativeType.Set
        };
        const [itemRequired, itemJson] = this.convert(schema_._def.valueType, options, lazyDepth, false, false, structureDepth + 1);
        json.items = this.#toArrayItemJsonSchema(itemRequired, itemJson, options.strategy);
        return [true, json];
      }
      case ZodFirstPartyTypeKind.ZodMap: {
        const schema_ = schema;
        const [keyRequired, keyJson] = this.convert(schema_._def.keyType, options, lazyDepth, false, false, structureDepth + 1);
        const [valueRequired, valueJson] = this.convert(schema_._def.valueType, options, lazyDepth, false, false, structureDepth + 1);
        const json = {
          "type": "array",
          "items": {
            type: "array",
            prefixItems: [
              this.#toArrayItemJsonSchema(keyRequired, keyJson, options.strategy),
              this.#toArrayItemJsonSchema(valueRequired, valueJson, options.strategy)
            ],
            maxItems: 2,
            minItems: 2
          },
          "x-native-type": JsonSchemaXNativeType.Map
        };
        return [true, json];
      }
      case ZodFirstPartyTypeKind.ZodUnion:
      case ZodFirstPartyTypeKind.ZodDiscriminatedUnion: {
        const schema_ = schema;
        const anyOf = [];
        let required = true;
        for (const item of schema_._def.options) {
          const [itemRequired, itemJson] = this.convert(item, options, lazyDepth, false, false, structureDepth);
          if (!itemRequired) {
            required = false;
            if (itemJson !== this.unsupportedJsonSchema) {
              anyOf.push(itemJson);
            }
          } else {
            anyOf.push(itemJson);
          }
        }
        if (anyOf.length === 1) {
          return [required, anyOf[0]];
        }
        return [required, { anyOf }];
      }
      case ZodFirstPartyTypeKind.ZodIntersection: {
        const schema_ = schema;
        const allOf = [];
        let required = false;
        for (const item of [schema_._def.left, schema_._def.right]) {
          const [itemRequired, itemJson] = this.convert(item, options, lazyDepth, false, false, structureDepth);
          allOf.push(itemJson);
          if (itemRequired) {
            required = true;
          }
        }
        return [required, { allOf }];
      }
      case ZodFirstPartyTypeKind.ZodLazy: {
        const currentLazyDepth = lazyDepth + 1;
        if (currentLazyDepth > this.maxLazyDepth) {
          return [false, this.anyJsonSchema];
        }
        const schema_ = schema;
        return this.convert(schema_._def.getter(), options, currentLazyDepth, false, false, structureDepth);
      }
      case ZodFirstPartyTypeKind.ZodOptional: {
        const schema_ = schema;
        const [_, inner] = this.convert(schema_._def.innerType, options, lazyDepth, false, false, structureDepth);
        return [false, inner];
      }
      case ZodFirstPartyTypeKind.ZodReadonly: {
        const schema_ = schema;
        const [required, json] = this.convert(schema_._def.innerType, options, lazyDepth, false, false, structureDepth);
        return [required, { ...json, readOnly: true }];
      }
      case ZodFirstPartyTypeKind.ZodDefault: {
        const schema_ = schema;
        const [_, json] = this.convert(schema_._def.innerType, options, lazyDepth, false, false, structureDepth);
        return [false, { default: schema_._def.defaultValue(), ...json }];
      }
      case ZodFirstPartyTypeKind.ZodEffects: {
        const schema_ = schema;
        if (schema_._def.effect.type === "transform" && options.strategy === "output") {
          return [false, this.anyJsonSchema];
        }
        return this.convert(schema_._def.schema, options, lazyDepth, false, false, structureDepth);
      }
      case ZodFirstPartyTypeKind.ZodCatch: {
        const schema_ = schema;
        return this.convert(schema_._def.innerType, options, lazyDepth, false, false, structureDepth);
      }
      case ZodFirstPartyTypeKind.ZodBranded: {
        const schema_ = schema;
        return this.convert(schema_._def.type, options, lazyDepth, false, false, structureDepth);
      }
      case ZodFirstPartyTypeKind.ZodPipeline: {
        const schema_ = schema;
        return this.convert(
          options.strategy === "input" ? schema_._def.in : schema_._def.out,
          options,
          lazyDepth,
          false,
          false,
          structureDepth
        );
      }
      case ZodFirstPartyTypeKind.ZodNullable: {
        const schema_ = schema;
        const [required, json] = this.convert(schema_._def.innerType, options, lazyDepth, false, false, structureDepth);
        return [required, { anyOf: [json, { type: "null" }] }];
      }
    }
    return [true, this.unsupportedJsonSchema];
  }
  #handleCustomZodDef(def) {
    const customZodDef = getCustomZodDef(def);
    if (!customZodDef) {
      return void 0;
    }
    switch (customZodDef.type) {
      case "blob": {
        return { type: "string", contentMediaType: "*/*" };
      }
      case "file": {
        return { type: "string", contentMediaType: customZodDef.mimeType ?? "*/*" };
      }
      case "regexp": {
        return {
          "type": "string",
          "pattern": "^\\/(.*)\\/([a-z]*)$",
          "x-native-type": JsonSchemaXNativeType.RegExp
        };
      }
      case "url": {
        return {
          "type": "string",
          "format": JSONSchemaFormat.URI,
          "x-native-type": JsonSchemaXNativeType.Url
        };
      }
    }
  }
  #getZodTypeName(def) {
    return def.typeName;
  }
  #toArrayItemJsonSchema(required, schema, strategy) {
    if (required) {
      return schema;
    }
    return strategy === "input" ? { anyOf: [schema, this.unsupportedJsonSchema] } : { anyOf: [schema, { type: "null" }] };
  }
}

const oz = {
  file,
  blob,
  url,
  regexp,
  openapi: customJsonSchema
};

export { ZodSmartCoercionPlugin, ZodToJsonSchemaConverter, blob, composeParams, customJsonSchema, file, getCustomJsonSchema, getCustomZodDef, oz, regexp, setCustomZodDef, url };
