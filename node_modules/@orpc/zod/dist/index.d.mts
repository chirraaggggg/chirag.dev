import { JSONSchema, ConditionalSchemaConverter, SchemaConvertOptions } from '@orpc/openapi';
import { ZodTypeAny, input, output, ZodTypeDef, CustomErrorParams, ZodType, ZodEffects } from 'zod/v3';
import { Context } from '@orpc/server';
import { StandardHandlerPlugin, StandardHandlerOptions } from '@orpc/server/standard';
import { AnySchema } from '@orpc/contract';

declare function getCustomJsonSchema(def: ZodTypeDef, options: {
    strategy: 'input' | 'output' | 'both';
}): Exclude<JSONSchema, boolean> | undefined;
declare function customJsonSchema<T extends ZodTypeAny, TStrategy extends 'input' | 'output' | 'both' = 'both'>(schema: T, custom: Exclude<JSONSchema<TStrategy extends 'input' ? input<T> : TStrategy extends 'output' ? output<T> : input<T> & output<T>>, boolean>, options?: {
    strategy?: TStrategy;
}): T;

type CustomParams = CustomErrorParams & {
    fatal?: boolean;
};
type CustomZodDef = {
    type: 'blob' | 'regexp' | 'url';
} | {
    type: 'file';
    mimeType?: string;
};
declare function setCustomZodDef<T extends ZodTypeDef>(def: T, custom: CustomZodDef): void;
declare function getCustomZodDef(def: ZodTypeDef): CustomZodDef | undefined;
declare function composeParams<T = unknown>(defaultMessage: (input: T) => string, params: undefined | string | CustomParams | ((input: T) => CustomParams)): (input: T) => CustomParams;

declare function blob(params?: string | CustomParams | ((input: unknown) => CustomParams)): ZodType<Blob, ZodTypeDef, Blob>;

declare function file(params?: string | CustomParams | ((input: unknown) => CustomParams)): ZodType<File, ZodTypeDef, File> & {
    type(mimeType: string, params?: string | CustomParams | ((input: unknown) => CustomParams)): ZodEffects<ZodType<File, ZodTypeDef, File>, File, File>;
};

declare function regexp(params?: string | CustomParams | ((input: unknown) => CustomParams)): ZodType<RegExp, ZodTypeDef, RegExp>;

declare function url(params?: string | CustomParams | ((input: unknown) => CustomParams)): ZodType<URL, ZodTypeDef, URL>;

declare class ZodSmartCoercionPlugin<TContext extends Context> implements StandardHandlerPlugin<TContext> {
    init(options: StandardHandlerOptions<TContext>): void;
}

interface ZodToJsonSchemaOptions {
    /**
     * Max depth of lazy type
     *
     * Used `{}` when exceed max depth
     *
     * @default 3
     */
    maxLazyDepth?: number;
    /**
     * Max depth of nested types
     *
     * Used anyJsonSchema (`{}`) when exceed max depth
     *
     * @default 10
     */
    maxStructureDepth?: number;
    /**
     * The schema to be used to represent the any | unknown type.
     *
     * @default { }
     */
    anyJsonSchema?: Exclude<JSONSchema, boolean>;
    /**
     * The schema to be used when the Zod schema is unsupported.
     *
     * @default { not: {} }
     */
    unsupportedJsonSchema?: Exclude<JSONSchema, boolean>;
}
declare class ZodToJsonSchemaConverter implements ConditionalSchemaConverter {
    #private;
    private readonly maxLazyDepth;
    private readonly maxStructureDepth;
    private readonly unsupportedJsonSchema;
    private readonly anyJsonSchema;
    constructor(options?: ZodToJsonSchemaOptions);
    condition(schema: AnySchema | undefined): boolean;
    convert(schema: AnySchema | undefined, options: SchemaConvertOptions, lazyDepth?: number, isHandledCustomJSONSchema?: boolean, isHandledZodDescription?: boolean, structureDepth?: number): [required: boolean, jsonSchema: Exclude<JSONSchema, boolean>];
}

declare const oz: {
    file: typeof file;
    blob: typeof blob;
    url: typeof url;
    regexp: typeof regexp;
    openapi: typeof customJsonSchema;
};

export { ZodSmartCoercionPlugin, ZodToJsonSchemaConverter, blob, composeParams, customJsonSchema, file, getCustomJsonSchema, getCustomZodDef, oz, regexp, setCustomZodDef, url };
export type { CustomParams, CustomZodDef, ZodToJsonSchemaOptions };
