import { Context } from '@orpc/server';
import { StandardHandlerPlugin, StandardHandlerOptions } from '@orpc/server/standard';
import { AnySchema } from '@orpc/contract';
import { JSONSchema, SchemaConvertOptions, ConditionalSchemaConverter } from '@orpc/openapi';
import { Interceptor } from '@orpc/shared';
import * as zod_v4_core from 'zod/v4/core';
import { $ZodType, $input, $output } from 'zod/v4/core';

/**
 * @deprecated Use [Smart Coercion Plugin](https://orpc.unnoq.com/docs/openapi/plugins/smart-coercion) instead.
 */
declare class experimental_ZodSmartCoercionPlugin<TContext extends Context> implements StandardHandlerPlugin<TContext> {
    #private;
    init(options: StandardHandlerOptions<TContext>): void;
}

interface ZodToJsonSchemaConverterOptions {
    /**
     * Max depth of lazy type.
     *
     * Used anyJsonSchema (`{}`) when exceed max depth
     *
     * @default 2
     */
    maxLazyDepth?: number;
    /**
     * Max depth of nested types.
     *
     * Used anyJsonSchema (`{}`) when exceed max depth
     *
     * @default 10
     */
    maxStructureDepth?: number;
    /**
     * The schema to be used to represent the any | unknown type.
     *
     * @default { }
     */
    anyJsonSchema?: Exclude<JSONSchema, boolean>;
    /**
     * The schema to be used when the Zod schema is unsupported.
     *
     * @default { not: {} }
     */
    unsupportedJsonSchema?: Exclude<JSONSchema, boolean>;
    /**
     * The schema to be used to represent the undefined type.
     *
     * @default { not: {} }
     */
    undefinedJsonSchema?: Exclude<JSONSchema, boolean>;
    interceptors?: Interceptor<{
        schema: $ZodType;
        options: SchemaConvertOptions;
        lazyDepth: number;
        isHandledCustomJSONSchema: boolean;
    }, [
        required: boolean,
        jsonSchema: Exclude<JSONSchema, boolean>
    ]>[];
}
declare class ZodToJsonSchemaConverter implements ConditionalSchemaConverter {
    #private;
    private readonly maxLazyDepth;
    private readonly maxStructureDepth;
    private readonly anyJsonSchema;
    private readonly unsupportedJsonSchema;
    private readonly undefinedJsonSchema;
    private readonly interceptors;
    constructor(options?: ZodToJsonSchemaConverterOptions);
    condition(schema: AnySchema | undefined): boolean;
    convert(schema: AnySchema | undefined, options: SchemaConvertOptions): [required: boolean, jsonSchema: Exclude<JSONSchema, boolean>];
}

/**
 * Zod registry for customizing generated JSON schema, can use both for .input and .output
 *
 * @example
 * ```ts
 * import { JSON_SCHEMA_REGISTRY } from '@orpc/zod/zod4'
 *
 * const user = z.object({
 *   name: z.string(),
 *   age: z.number(),
 * })
 *
 * JSON_SCHEMA_REGISTRY.add(user, {
 *   examples: [{ name: 'John', age: 20 }],
 * })
 * ```
 */
declare const JSON_SCHEMA_REGISTRY: zod_v4_core.$ZodRegistry<{
    $anchor?: string;
    $comment?: string;
    $defs?: Record<string, JSONSchema>;
    $dynamicAnchor?: string;
    $dynamicRef?: string;
    $id?: string;
    $ref?: string;
    $schema?: string;
    $vocabulary?: Record<string, string>;
    additionalItems?: JSONSchema;
    additionalProperties?: JSONSchema;
    allOf?: (JSONSchema<typeof $input | typeof $output, JSONSchema.TypeValue>[] | readonly JSONSchema<typeof $input | typeof $output, JSONSchema.TypeValue>[]) | undefined;
    anyOf?: (JSONSchema<typeof $input | typeof $output, JSONSchema.TypeValue>[] | readonly JSONSchema<typeof $input | typeof $output, JSONSchema.TypeValue>[]) | undefined;
    const?: typeof $input | typeof $output | undefined;
    contains?: JSONSchema<typeof $input | typeof $output, JSONSchema.TypeValue> | undefined;
    contentEncoding?: "7bit" | "8bit" | "base64" | "binary" | "ietf-token" | "quoted-printable" | "x-token";
    contentMediaType?: string;
    contentSchema?: JSONSchema<typeof $input | typeof $output, JSONSchema.TypeValue> | undefined;
    default?: typeof $input | typeof $output | undefined;
    definitions?: Record<string, JSONSchema>;
    dependencies?: Record<string, (string[] | readonly string[]) | JSONSchema>;
    dependentRequired?: Record<string, string[] | readonly string[]>;
    dependentSchemas?: Record<string, JSONSchema>;
    deprecated?: boolean;
    description?: string;
    else?: JSONSchema<typeof $input | typeof $output, JSONSchema.TypeValue> | undefined;
    enum?: ((typeof $input | typeof $output)[] | readonly (typeof $input | typeof $output)[]) | undefined;
    examples?: ((typeof $input | typeof $output)[] | readonly (typeof $input | typeof $output)[]) | undefined;
    exclusiveMaximum?: number;
    exclusiveMinimum?: number;
    format?: string;
    if?: JSONSchema<typeof $input | typeof $output, JSONSchema.TypeValue> | undefined;
    items?: JSONSchema;
    maxContains?: number;
    maximum?: number;
    maxItems?: number;
    maxLength?: number;
    maxProperties?: number;
    minContains?: number;
    minimum?: number;
    minItems?: number;
    minLength?: number;
    minProperties?: number;
    multipleOf?: number;
    not?: JSONSchema<typeof $input | typeof $output, JSONSchema.TypeValue> | undefined;
    oneOf?: (JSONSchema<typeof $input | typeof $output, JSONSchema.TypeValue>[] | readonly JSONSchema<typeof $input | typeof $output, JSONSchema.TypeValue>[]) | undefined;
    pattern?: string;
    patternProperties?: Record<string, JSONSchema>;
    prefixItems?: (JSONSchema<any, JSONSchema.TypeValue>[] | readonly JSONSchema<any, JSONSchema.TypeValue>[]) | JSONSchema;
    properties?: Record<string, JSONSchema>;
    propertyNames?: JSONSchema;
    readOnly?: boolean;
    required?: string[] | readonly string[];
    then?: JSONSchema<typeof $input | typeof $output, JSONSchema.TypeValue> | undefined;
    title?: string;
    type?: JSONSchema.TypeValue | undefined;
    unevaluatedItems?: JSONSchema;
    unevaluatedProperties?: JSONSchema;
    uniqueItems?: boolean;
    writeOnly?: boolean;
}, zod_v4_core.$ZodType<unknown, unknown, zod_v4_core.$ZodTypeInternals<unknown, unknown>>>;
/**
 * Zod registry for customizing generated JSON schema, only useful for .input
 *
 * @example
 * ```ts
 * import { JSON_SCHEMA_INPUT_REGISTRY } from '@orpc/zod/zod4'
 *
 * const user = z.object({
 *   name: z.string(),
 *   age: z.string().transform(v => Number(v)),
 * })
 *
 * JSON_SCHEMA_REGISTRY.add(user, {
 *   examples: [{ name: 'John', age: "20" }],
 * })
 * ```
 */
declare const JSON_SCHEMA_INPUT_REGISTRY: zod_v4_core.$ZodRegistry<{
    $anchor?: string;
    $comment?: string;
    $defs?: Record<string, JSONSchema>;
    $dynamicAnchor?: string;
    $dynamicRef?: string;
    $id?: string;
    $ref?: string;
    $schema?: string;
    $vocabulary?: Record<string, string>;
    additionalItems?: JSONSchema;
    additionalProperties?: JSONSchema;
    allOf?: (JSONSchema<typeof $input, JSONSchema.TypeValue>[] | readonly JSONSchema<typeof $input, JSONSchema.TypeValue>[]) | undefined;
    anyOf?: (JSONSchema<typeof $input, JSONSchema.TypeValue>[] | readonly JSONSchema<typeof $input, JSONSchema.TypeValue>[]) | undefined;
    const?: typeof $input | undefined;
    contains?: JSONSchema<typeof $input, JSONSchema.TypeValue> | undefined;
    contentEncoding?: "7bit" | "8bit" | "base64" | "binary" | "ietf-token" | "quoted-printable" | "x-token";
    contentMediaType?: string;
    contentSchema?: JSONSchema<typeof $input, JSONSchema.TypeValue> | undefined;
    default?: typeof $input | undefined;
    definitions?: Record<string, JSONSchema>;
    dependencies?: Record<string, (string[] | readonly string[]) | JSONSchema>;
    dependentRequired?: Record<string, string[] | readonly string[]>;
    dependentSchemas?: Record<string, JSONSchema>;
    deprecated?: boolean;
    description?: string;
    else?: JSONSchema<typeof $input, JSONSchema.TypeValue> | undefined;
    enum?: ((typeof $input)[] | readonly (typeof $input)[]) | undefined;
    examples?: ((typeof $input)[] | readonly (typeof $input)[]) | undefined;
    exclusiveMaximum?: number;
    exclusiveMinimum?: number;
    format?: string;
    if?: JSONSchema<typeof $input, JSONSchema.TypeValue> | undefined;
    items?: JSONSchema;
    maxContains?: number;
    maximum?: number;
    maxItems?: number;
    maxLength?: number;
    maxProperties?: number;
    minContains?: number;
    minimum?: number;
    minItems?: number;
    minLength?: number;
    minProperties?: number;
    multipleOf?: number;
    not?: JSONSchema<typeof $input, JSONSchema.TypeValue> | undefined;
    oneOf?: (JSONSchema<typeof $input, JSONSchema.TypeValue>[] | readonly JSONSchema<typeof $input, JSONSchema.TypeValue>[]) | undefined;
    pattern?: string;
    patternProperties?: Record<string, JSONSchema>;
    prefixItems?: (JSONSchema<any, JSONSchema.TypeValue>[] | readonly JSONSchema<any, JSONSchema.TypeValue>[]) | JSONSchema;
    properties?: Record<string, JSONSchema>;
    propertyNames?: JSONSchema;
    readOnly?: boolean;
    required?: string[] | readonly string[];
    then?: JSONSchema<typeof $input, JSONSchema.TypeValue> | undefined;
    title?: string;
    type?: JSONSchema.TypeValue | undefined;
    unevaluatedItems?: JSONSchema;
    unevaluatedProperties?: JSONSchema;
    uniqueItems?: boolean;
    writeOnly?: boolean;
}, zod_v4_core.$ZodType<unknown, unknown, zod_v4_core.$ZodTypeInternals<unknown, unknown>>>;
/**
 * Zod registry for customizing generated JSON schema, only useful for .input
 *
 * @example
 * ```ts
 * import { JSON_SCHEMA_OUTPUT_REGISTRY } from '@orpc/zod/zod4'
 *
 * const user = z.object({
 *   name: z.string(),
 *   age: z.string().transform(v => Number(v)),
 * })
 *
 * JSON_SCHEMA_OUTPUT_REGISTRY.add(user, {
 *   examples: [{ name: 'John', age: 20 }],
 * })
 * ```
 */
declare const JSON_SCHEMA_OUTPUT_REGISTRY: zod_v4_core.$ZodRegistry<{
    $anchor?: string;
    $comment?: string;
    $defs?: Record<string, JSONSchema>;
    $dynamicAnchor?: string;
    $dynamicRef?: string;
    $id?: string;
    $ref?: string;
    $schema?: string;
    $vocabulary?: Record<string, string>;
    additionalItems?: JSONSchema;
    additionalProperties?: JSONSchema;
    allOf?: (JSONSchema<typeof $output, JSONSchema.TypeValue>[] | readonly JSONSchema<typeof $output, JSONSchema.TypeValue>[]) | undefined;
    anyOf?: (JSONSchema<typeof $output, JSONSchema.TypeValue>[] | readonly JSONSchema<typeof $output, JSONSchema.TypeValue>[]) | undefined;
    const?: typeof $output | undefined;
    contains?: JSONSchema<typeof $output, JSONSchema.TypeValue> | undefined;
    contentEncoding?: "7bit" | "8bit" | "base64" | "binary" | "ietf-token" | "quoted-printable" | "x-token";
    contentMediaType?: string;
    contentSchema?: JSONSchema<typeof $output, JSONSchema.TypeValue> | undefined;
    default?: typeof $output | undefined;
    definitions?: Record<string, JSONSchema>;
    dependencies?: Record<string, (string[] | readonly string[]) | JSONSchema>;
    dependentRequired?: Record<string, string[] | readonly string[]>;
    dependentSchemas?: Record<string, JSONSchema>;
    deprecated?: boolean;
    description?: string;
    else?: JSONSchema<typeof $output, JSONSchema.TypeValue> | undefined;
    enum?: ((typeof $output)[] | readonly (typeof $output)[]) | undefined;
    examples?: ((typeof $output)[] | readonly (typeof $output)[]) | undefined;
    exclusiveMaximum?: number;
    exclusiveMinimum?: number;
    format?: string;
    if?: JSONSchema<typeof $output, JSONSchema.TypeValue> | undefined;
    items?: JSONSchema;
    maxContains?: number;
    maximum?: number;
    maxItems?: number;
    maxLength?: number;
    maxProperties?: number;
    minContains?: number;
    minimum?: number;
    minItems?: number;
    minLength?: number;
    minProperties?: number;
    multipleOf?: number;
    not?: JSONSchema<typeof $output, JSONSchema.TypeValue> | undefined;
    oneOf?: (JSONSchema<typeof $output, JSONSchema.TypeValue>[] | readonly JSONSchema<typeof $output, JSONSchema.TypeValue>[]) | undefined;
    pattern?: string;
    patternProperties?: Record<string, JSONSchema>;
    prefixItems?: (JSONSchema<any, JSONSchema.TypeValue>[] | readonly JSONSchema<any, JSONSchema.TypeValue>[]) | JSONSchema;
    properties?: Record<string, JSONSchema>;
    propertyNames?: JSONSchema;
    readOnly?: boolean;
    required?: string[] | readonly string[];
    then?: JSONSchema<typeof $output, JSONSchema.TypeValue> | undefined;
    title?: string;
    type?: JSONSchema.TypeValue | undefined;
    unevaluatedItems?: JSONSchema;
    unevaluatedProperties?: JSONSchema;
    uniqueItems?: boolean;
    writeOnly?: boolean;
}, zod_v4_core.$ZodType<unknown, unknown, zod_v4_core.$ZodTypeInternals<unknown, unknown>>>;

export { JSON_SCHEMA_INPUT_REGISTRY, JSON_SCHEMA_OUTPUT_REGISTRY, JSON_SCHEMA_REGISTRY, ZodToJsonSchemaConverter, experimental_ZodSmartCoercionPlugin };
export type { ZodToJsonSchemaConverterOptions };
