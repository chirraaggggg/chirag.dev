"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.mts
var index_exports = {};
__export(index_exports, {
  KyselyTypeORMDialect: () => KyselyTypeORMDialect,
  KyselyTypeORMDriver: () => KyselyTypeORMDriver
});
module.exports = __toCommonJS(index_exports);

// src/isolation-levels.mts
var ISOLATION_LEVELS = {
  "read committed": "READ COMMITTED",
  "read uncommitted": "READ UNCOMMITTED",
  "repeatable read": "REPEATABLE READ",
  serializable: "SERIALIZABLE",
  snapshot: null
};

// src/type-utils.mts
function isObject(thing) {
  return typeof thing === "object" && thing !== null && !Array.isArray(thing);
}

// src/connection.mts
var KyselyTypeORMConnection = class {
  #queryRunner;
  constructor(queryRunner) {
    this.#queryRunner = queryRunner;
  }
  async beginTransaction(settings) {
    const { isolationLevel: kyselyIsolationLevel } = settings;
    const isolationLevel = kyselyIsolationLevel && ISOLATION_LEVELS[kyselyIsolationLevel];
    if (isolationLevel === null) {
      throw new Error(
        `Isolation level '${kyselyIsolationLevel}' is not supported!`
      );
    }
    await this.#queryRunner.startTransaction(isolationLevel);
  }
  async commitTransaction() {
    await this.#queryRunner.commitTransaction();
  }
  async release() {
    await this.#queryRunner.release();
  }
  async rollbackTransaction() {
    await this.#queryRunner.rollbackTransaction();
  }
  async executeQuery(compiledQuery) {
    const result = await this.#queryRunner.query(
      compiledQuery.sql,
      [...compiledQuery.parameters],
      true
    );
    const { affected, raw, records } = result;
    return {
      insertId: Number.isInteger(raw) ? BigInt(raw) : isObject(raw) && "insertId" in raw && Number.isInteger(raw.insertId) ? BigInt(raw.insertId) : void 0,
      numAffectedRows: Number.isInteger(affected) ? (
        // biome-ignore lint/style/noNonNullAssertion: it's alright.
        BigInt(affected)
      ) : void 0,
      numChangedRows: isObject(raw) && "changedRows" in raw && Number.isInteger(raw.changedRows) ? BigInt(raw.changedRows) : void 0,
      rows: records || []
    };
  }
  async *streamQuery(compiledQuery) {
    for await (const row of await this.#queryRunner.stream(compiledQuery.sql, [
      ...compiledQuery.parameters
    ])) {
      yield { rows: [row] };
    }
  }
};

// src/driver.mts
var KyselyTypeORMDriver = class {
  #config;
  constructor(config) {
    this.#config = config;
  }
  async acquireConnection() {
    const queryRunner = this.#config.typeORMDataSource.createQueryRunner();
    await queryRunner.connect();
    return new KyselyTypeORMConnection(queryRunner);
  }
  async beginTransaction(connection, settings) {
    await connection.beginTransaction(settings);
  }
  async commitTransaction(connection) {
    await connection.commitTransaction();
  }
  async destroy() {
    if (this.#config.typeORMDataSource.isInitialized) {
      await this.#config.typeORMDataSource.destroy();
    }
  }
  async init() {
    if (!this.#config.typeORMDataSource.isInitialized) {
      await this.#config.typeORMDataSource.initialize();
    }
  }
  async releaseConnection(connection) {
    await connection.release();
  }
  async rollbackTransaction(connection) {
    await connection.rollbackTransaction();
  }
};

// src/supported-dialects.mts
var SUPPORTED_DIALECTS = [
  "better-sqlite3",
  "mssql",
  "mysql",
  "postgres",
  "sqlite"
];
function isDialectSupported(dialect) {
  return SUPPORTED_DIALECTS.includes(dialect);
}
function assertSupportedDialect(dialect) {
  if (!isDialectSupported(dialect)) {
    throw new Error(`Unsupported dialect: ${dialect}!`);
  }
}

// src/dialect.mts
var KyselyTypeORMDialect = class {
  #config;
  constructor(config) {
    assertSupportedDialect(config.typeORMDataSource.options.type);
    this.#config = config;
  }
  createAdapter() {
    return this.#config.kyselySubDialect.createAdapter();
  }
  createDriver() {
    return new KyselyTypeORMDriver(this.#config);
  }
  // biome-ignore lint/suspicious/noExplicitAny: this is fine.
  createIntrospector(db) {
    return this.#config.kyselySubDialect.createIntrospector(db);
  }
  createQueryCompiler() {
    const queryCompiler = this.#config.kyselySubDialect.createQueryCompiler();
    if (this.#config.typeORMDataSource.options.type === "mssql") {
      ;
      queryCompiler.getCurrentParameterPlaceholder = function() {
        return `@${this.numParameters - 1}`;
      };
    }
    return queryCompiler;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  KyselyTypeORMDialect,
  KyselyTypeORMDriver
});
